{"version":3,"file":"static/js/578.5f4bf256.chunk.js","mappings":"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","sources":["../node_modules/jwt-decode/lib/atob.js","../node_modules/jwt-decode/lib/base64_url_decode.js","../node_modules/jwt-decode/lib/index.js","../node_modules/@egjs/agent/src/utils.ts","../node_modules/@egjs/agent/src/presets.ts","../node_modules/@egjs/agent/src/userAgent.ts","../node_modules/@egjs/agent/src/userAgentData.ts","../node_modules/@egjs/agent/src/agent.ts","../node_modules/framework-utils/src/index.ts","../node_modules/@daybrush/utils/src/consts.ts","../node_modules/@daybrush/utils/src/utils.ts","../node_modules/@daybrush/utils/src/dom.ts","../node_modules/@scena/matrix/src/index.ts","../node_modules/css-to-mat/src/CssToMatrix.ts","../node_modules/@egjs/list-differ/src/PolyMap.ts","../node_modules/@egjs/list-differ/src/HashMap.ts","../node_modules/@egjs/list-differ/src/consts.ts","../node_modules/@egjs/list-differ/src/Link.ts","../node_modules/@egjs/list-differ/src/Result.ts","../node_modules/@egjs/list-differ/src/utils.ts","../node_modules/@egjs/list-differ/src/ListDiffer.ts","../node_modules/@egjs/children-differ/src/consts.ts","../node_modules/@egjs/children-differ/src/ChildrenDiffer.ts","../node_modules/overlap-area/src/utils.ts","../node_modules/overlap-area/src/index.ts","../node_modules/@scena/event-emitter/src/EventEmitter.ts","../node_modules/@scena/dragscroll/src/DragScroll.ts","../node_modules/gesto/node_modules/tslib/tslib.es6.js","../node_modules/gesto/src/utils.ts","../node_modules/gesto/src/ClientStore.ts","../node_modules/gesto/src/Gesto.ts","../node_modules/css-styled/src/utils.ts","../node_modules/css-styled/src/styled.ts","../node_modules/react-css-styled/src/react-css-styled/StyledElement.tsx","../node_modules/react-css-styled/src/react-css-styled/styled.tsx","../node_modules/react-moveable/src/ables/AbleManager.ts","../node_modules/react-moveable/src/consts.ts","../node_modules/react-moveable/src/gesto/CustomGesto.ts","../node_modules/react-moveable/src/gesto/GestoUtils.ts","../node_modules/react-moveable/src/utils.tsx","../node_modules/react-moveable/src/gesto/GestoData.ts","../node_modules/react-moveable/src/ables/Pinchable.ts","../node_modules/react-moveable/src/groupUtils.ts","../node_modules/react-moveable/src/ables/snappable/utils.ts","../node_modules/react-moveable/src/ables/snappable/snap.ts","../node_modules/react-moveable/src/ables/snappable/innerBounds.ts","../node_modules/react-moveable/src/ables/snappable/bounds.ts","../node_modules/react-moveable/src/ables/snappable/render.tsx","../node_modules/react-moveable/src/ables/snappable/snapBounds.ts","../node_modules/react-moveable/src/ables/snappable/getTotalGuidelines.ts","../node_modules/@egjs/children-differ/src/utils.ts","../node_modules/react-moveable/src/ables/Snappable.tsx","../node_modules/react-moveable/src/renderDirections.tsx","../node_modules/react-moveable/src/ables/Draggable.tsx","../node_modules/react-moveable/src/ables/Resizable.ts","../node_modules/react-moveable/src/ables/Rotatable.tsx","../node_modules/react-moveable/src/ables/Scalable.ts","../node_modules/react-moveable/src/ables/Warpable.tsx","../node_modules/react-moveable/src/classNames.ts","../node_modules/react-moveable/src/ables/DragArea.tsx","../node_modules/react-moveable/src/ables/Origin.tsx","../node_modules/react-moveable/src/ables/Scrollable.ts","../node_modules/react-moveable/src/ables/Default.ts","../node_modules/react-moveable/src/ables/Padding.tsx","../node_modules/react-moveable/src/ables/roundable/borderRadius.tsx","../node_modules/react-moveable/src/ables/clippable/utils.tsx","../node_modules/react-moveable/src/ables/Clippable.tsx","../node_modules/react-moveable/src/ables/OriginDraggable.tsx","../node_modules/react-moveable/src/ables/Roundable.tsx","../node_modules/react-moveable/src/ables/BeforeRenderable.ts","../node_modules/react-moveable/src/ables/Renderable.ts","../node_modules/react-moveable/src/gesto/getAbleGesto.ts","../node_modules/react-moveable/src/EventManager.ts","../node_modules/react-moveable/src/utils/getMatrixStackInfo.ts","../node_modules/react-moveable/src/utils/calculateMatrixStack.ts","../node_modules/react-moveable/src/utils/getElementInfo.ts","../node_modules/react-moveable/src/utils/getMoveableTargetInfo.ts","../node_modules/react-moveable/src/utils/persist.ts","../node_modules/react-moveable/src/MoveableManager.tsx","../node_modules/react-moveable/src/ables/Groupable.tsx","../node_modules/react-moveable/src/ables/Clickable.ts","../node_modules/react-moveable/src/ables/edgeDraggable.tsx","../node_modules/react-moveable/src/ables/IndividualGroupable.tsx","../node_modules/react-moveable/src/ables/consts.ts","../node_modules/react-moveable/src/Snappable/utils.ts","../node_modules/react-moveable/src/MoveableGroup.tsx","../node_modules/react-moveable/src/MoveableIndividualGroup.tsx","../node_modules/react-moveable/src/InitialMoveable.tsx","../node_modules/react-moveable/src/Moveable.tsx","../node_modules/react-reveal/Fade.js","../node_modules/@headlessui/react/dist/hooks/use-id.js","../node_modules/@headlessui/react/dist/components/keyboard.js","../node_modules/@headlessui/react/dist/utils/calculate-active-index.js","../node_modules/@headlessui/react/dist/utils/bugs.js","../node_modules/@headlessui/react/dist/utils/owner.js","../node_modules/@headlessui/react/dist/utils/focus-management.js","../node_modules/@headlessui/react/dist/hooks/use-document-event.js","../node_modules/@headlessui/react/dist/hooks/use-outside-click.js","../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js","../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js","../node_modules/@headlessui/react/dist/components/menu/menu.js","../node_modules/@headlessui/react/dist/hooks/use-owner.js","../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js","../node_modules/@headlessui/react/dist/hooks/use-is-mounted.js","../node_modules/@headlessui/react/dist/components/transitions/utils/transition.js","../node_modules/@headlessui/react/dist/utils/once.js","../node_modules/@headlessui/react/dist/hooks/use-transition.js","../node_modules/@headlessui/react/dist/components/transitions/transition.js","../node_modules/@headlessui/react/dist/hooks/use-disposables.js","../node_modules/@headlessui/react/dist/hooks/use-event.js","../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js","../node_modules/@headlessui/react/dist/hooks/use-latest-value.js","../node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js","../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js","../node_modules/@headlessui/react/dist/internal/open-closed.js","../node_modules/@headlessui/react/dist/utils/class-names.js","../node_modules/@headlessui/react/dist/utils/micro-task.js","../node_modules/@headlessui/react/dist/utils/disposables.js","../node_modules/@headlessui/react/dist/utils/env.js","../node_modules/@headlessui/react/dist/utils/match.js","../node_modules/@headlessui/react/dist/utils/render.js","../node_modules/react-loading-skeleton/dist/index.mjs"],"sourcesContent":["/**\n * The code was extracted from:\n * https://github.com/davidchambers/Base64.js\n */\n\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nfunction InvalidCharacterError(message) {\n    this.message = message;\n}\n\nInvalidCharacterError.prototype = new Error();\nInvalidCharacterError.prototype.name = \"InvalidCharacterError\";\n\nfunction polyfill(input) {\n    var str = String(input).replace(/=+$/, \"\");\n    if (str.length % 4 == 1) {\n        throw new InvalidCharacterError(\n            \"'atob' failed: The string to be decoded is not correctly encoded.\"\n        );\n    }\n    for (\n        // initialize result and counters\n        var bc = 0, bs, buffer, idx = 0, output = \"\";\n        // get next character\n        (buffer = str.charAt(idx++));\n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n        ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4) ?\n        (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n        0\n    ) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n    }\n    return output;\n}\n\nexport default (typeof window !== \"undefined\" &&\n    window.atob &&\n    window.atob.bind(window)) ||\npolyfill;","import atob from \"./atob\";\n\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(\n        atob(str).replace(/(.)/g, function(m, p) {\n            var code = p.charCodeAt(0).toString(16).toUpperCase();\n            if (code.length < 2) {\n                code = \"0\" + code;\n            }\n            return \"%\" + code;\n        })\n    );\n}\n\nexport default function(str) {\n    var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw \"Illegal base64url string!\";\n    }\n\n    try {\n        return b64DecodeUnicode(output);\n    } catch (err) {\n        return atob(output);\n    }\n}","\"use strict\";\n\nimport base64_url_decode from \"./base64_url_decode\";\n\nexport function InvalidTokenError(message) {\n    this.message = message;\n}\n\nInvalidTokenError.prototype = new Error();\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\n\nexport default function(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified\");\n    }\n\n    options = options || {};\n    var pos = options.header === true ? 0 : 1;\n    try {\n        return JSON.parse(base64_url_decode(token.split(\".\")[pos]));\n    } catch (e) {\n        throw new InvalidTokenError(\"Invalid token specified: \" + e.message);\n    }\n}","import { PresetInfo, PresetResult, NavigatorUABrandVersion } from \"./types\";\n\nexport function some<T>(arr: T[], callback: (value: T, index: number) => any): boolean {\n    const length = arr.length;\n\n    for (let i = 0; i < length; ++i) {\n        if (callback(arr[i], i)) {\n            return true;\n        }\n    }\n\n    return false;\n}\nexport function find<T>(arr: T[], callback: (value: T, index: number) => any): T | null {\n    const length = arr.length;\n\n    for (let i = 0; i < length; ++i) {\n        if (callback(arr[i], i)) {\n            return arr[i];\n        }\n    }\n    return null;\n}\nexport function getUserAgentString(agent?: string): string {\n    let userAgent = agent;\n    if (typeof userAgent === \"undefined\") {\n        if (typeof navigator === \"undefined\" || !navigator) {\n            return \"\";\n        }\n\n        userAgent = navigator.userAgent || \"\";\n    }\n    return userAgent!.toLowerCase();\n}\nexport function execRegExp(pattern: string, text: string): RegExpExecArray | null {\n    try {\n        return new RegExp(pattern, \"g\").exec(text);\n    } catch (e) {\n        return null;\n    }\n}\nexport function hasUserAgentData(): boolean {\n    if (typeof navigator === \"undefined\" || !navigator || !navigator.userAgentData) {\n        return false;\n    }\n    const userAgentData = navigator.userAgentData;\n    const brands = (userAgentData.brands || userAgentData.uaList);\n\n    return !!(brands && brands.length);\n}\nexport function findVersion(versionTest: string, userAgent: string): string {\n    const result = execRegExp(`(${versionTest})((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))`, userAgent);\n\n    return result ? result[3] : \"\";\n}\nexport function convertVersion(text: string): string {\n    return text.replace(/_/g, \".\");\n}\nexport function findPreset(presets: PresetInfo[], userAgent: string): PresetResult {\n    let userPreset: PresetInfo | null = null;\n    let version = \"-1\";\n\n    some(presets, preset => {\n        const result = execRegExp(`(${preset.test})((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?`, userAgent);\n\n        if (!result || preset.brand) {\n            return false;\n        }\n        userPreset = preset;\n        version = result[3] || \"-1\";\n\n        if (preset.versionAlias) {\n            version = preset.versionAlias;\n        } else if (preset.versionTest) {\n            version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;\n        }\n        version = convertVersion(version);\n        return true;\n    });\n\n    return {\n        preset: userPreset,\n        version,\n    };\n}\nexport function findPresetBrand(presets: PresetInfo[], brands: NavigatorUABrandVersion[]): NavigatorUABrandVersion {\n    const brandInfo = {\n        brand: \"\",\n        version: \"-1\",\n    };\n    some(presets, preset => {\n        const result = findBrand(brands, preset);\n\n        if (!result) {\n            return false;\n        }\n\n        brandInfo.brand = preset.id;\n        brandInfo.version = preset.versionAlias || result.version;\n\n        return brandInfo.version !== \"-1\";\n    });\n\n    return brandInfo;\n}\nexport function findBrand(brands: NavigatorUABrandVersion[], preset: PresetInfo): NavigatorUABrandVersion | null {\n    return find(brands, ({ brand }) => {\n        return execRegExp(`${preset.test}`, brand.toLowerCase());\n    });\n}\n","import { PresetInfo } from \"./types\";\n\nexport const BROWSER_PRESETS: PresetInfo[] = [\n    {\n        test: \"phantomjs\",\n        id: \"phantomjs\",\n    },\n    {\n        test: \"whale\",\n        id: \"whale\",\n    }, {\n        test: \"edgios|edge|edg\",\n        id: \"edge\",\n    },\n    {\n        test: \"msie|trident|windows phone\",\n        id: \"ie\",\n        versionTest: \"iemobile|msie|rv\",\n    },\n    {\n        test: \"miuibrowser\",\n        id: \"miui browser\",\n    },\n    {\n        test: \"samsungbrowser\",\n        id: \"samsung internet\",\n    },\n    {\n        test: \"samsung\",\n        id: \"samsung internet\",\n        versionTest: \"version\",\n    },\n    {\n        test: \"chrome|crios\",\n        id: \"chrome\",\n    },\n    {\n        test: \"firefox|fxios\",\n        id: \"firefox\",\n    },\n    {\n        test: \"android\",\n        id: \"android browser\",\n        versionTest: \"version\",\n    },\n    {\n        test: \"safari|iphone|ipad|ipod\",\n        id: \"safari\",\n        versionTest: \"version\",\n    },\n];\n\n// chromium's engine(blink) is based on applewebkit 537.36.\nexport const CHROMIUM_PRESETS: PresetInfo[] = [\n    {\n        test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n        id: \"chrome\",\n        versionTest: \"chrome\",\n    },\n    {\n        test: \"chromium\",\n        id: \"chrome\",\n    },\n    {\n        test: \"whale\",\n        id: \"chrome\",\n        versionAlias: \"-1\",\n        brand: true,\n    },\n];\nexport const WEBKIT_PRESETS: PresetInfo[] = [\n    {\n        test: \"applewebkit\",\n        id: \"webkit\",\n        versionTest: \"applewebkit|safari\",\n    },\n];\nexport const WEBVIEW_PRESETS: PresetInfo[] = [\n    {\n        test: \"(?=(iphone|ipad))(?!(.*version))\",\n        id: \"webview\",\n    },\n    {\n        test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n        id: \"webview\",\n    },\n    {\n        // test webview\n        test: \"webview\",\n        id: \"webview\",\n    },\n];\nexport const OS_PRESETS: PresetInfo[] = [\n    {\n        test: \"windows phone\",\n        id: \"windows phone\",\n    },\n    {\n        test: \"windows 2000\",\n        id: \"window\",\n        versionAlias: \"5.0\",\n    },\n    {\n        test: \"windows nt\",\n        id: \"window\",\n    },\n    {\n        test: \"win32|windows\",\n        id: \"window\",\n    },\n    {\n        test: \"iphone|ipad|ipod\",\n        id: \"ios\",\n        versionTest: \"iphone os|cpu os\",\n    },\n    {\n        test: \"macos|macintel|mac os x\",\n        id: \"mac\",\n    },\n    {\n        test: \"android|linux armv81\",\n        id: \"android\",\n    },\n    {\n        test: \"tizen\",\n        id: \"tizen\",\n    },\n    {\n        test: \"webos|web0s\",\n        id: \"webos\",\n    },\n    // {\n    //     test: \"linux|ubuntu|debian\",\n    //     id: \"linux\",\n    //     versionAlias: \"-1\",\n    // },\n];\n","import { AgentInfo } from \"./types\";\nimport { getUserAgentString, findPreset } from \"./utils\";\nimport { WEBVIEW_PRESETS, CHROMIUM_PRESETS, BROWSER_PRESETS, OS_PRESETS, WEBKIT_PRESETS } from \"./presets\";\n\nexport function isWebView(userAgent: string): boolean {\n    return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;\n}\n\nexport function getLegacyAgent(userAgent?: string): AgentInfo {\n    const nextAgent = getUserAgentString(userAgent);\n    const isMobile = !!/mobi/g.exec(nextAgent);\n    const browser = {\n        name: \"unknown\",\n        version: \"-1\",\n        majorVersion: -1,\n        webview: isWebView(nextAgent),\n        chromium: false,\n        chromiumVersion: \"-1\",\n        webkit: false,\n        webkitVersion: \"-1\",\n    };\n    const os = {\n        name: \"unknown\",\n        version: \"-1\",\n        majorVersion: -1,\n    };\n    const {\n        preset: browserPreset,\n        version: browserVersion,\n    } = findPreset(BROWSER_PRESETS, nextAgent);\n\n    const {\n        preset: osPreset,\n        version: osVersion,\n    } = findPreset(OS_PRESETS, nextAgent);\n\n    const chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);\n\n    browser.chromium = !!chromiumPreset.preset;\n    browser.chromiumVersion = chromiumPreset.version;\n    if (!browser.chromium) {\n        const webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);\n\n        browser.webkit = !!webkitPreset.preset;\n        browser.webkitVersion = webkitPreset.version;\n    }\n\n    if (osPreset) {\n        os.name = osPreset.id;\n        os.version = osVersion;\n        os.majorVersion = parseInt(osVersion, 10);\n    }\n    if (browserPreset) {\n        browser.name = browserPreset.id;\n        browser.version = browserVersion;\n\n        // Early whale bugs\n        if (browser.webview && os.name === \"ios\" && browser.name !== \"safari\") {\n            browser.webview = false;\n        }\n    }\n    browser.majorVersion = parseInt(browser.version, 10);\n\n    return {\n        browser,\n        os,\n        isMobile,\n        isHints: false,\n    };\n}\n","import { UADataValues, AgentInfo, AgentBrowserInfo, AgentOSInfo } from \"./types\";\nimport { some, find, findBrand, convertVersion, findPresetBrand, getUserAgentString } from \"./utils\";\nimport { BROWSER_PRESETS, OS_PRESETS, CHROMIUM_PRESETS, WEBKIT_PRESETS, WEBVIEW_PRESETS } from \"./presets\";\nimport { isWebView } from \"./userAgent\";\n\nexport function getClientHintsAgent(osData?: UADataValues): AgentInfo {\n    const userAgentData = navigator.userAgentData;\n    const brands = [...(userAgentData.uaList || userAgentData.brands)!];\n    const fullVersionList = osData && osData.fullVersionList;\n    const isMobile = userAgentData.mobile || false;\n    const firstBrand = brands[0];\n    const platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();\n    const browser: AgentBrowserInfo = {\n        name: firstBrand.brand,\n        version: firstBrand.version,\n        majorVersion: -1,\n        webkit: false,\n        webkitVersion: \"-1\",\n        chromium: false,\n        chromiumVersion: \"-1\",\n        webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString()),\n    };\n    const os: AgentOSInfo = {\n        name: \"unknown\",\n        version: \"-1\",\n        majorVersion: -1,\n    };\n    browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, preset => findBrand(brands, preset));\n\n    const chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);\n\n    browser.chromium = !!chromiumBrand.brand;\n    browser.chromiumVersion = chromiumBrand.version;\n    if (!browser.chromium) {\n        const webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);\n\n        browser.webkit = !!webkitBrand.brand;\n        browser.webkitVersion = webkitBrand.version;\n    }\n\n    const platfomResult = find(OS_PRESETS, preset => {\n        return new RegExp(`${preset.test}`, \"g\").exec(platform);\n    });\n    os.name = platfomResult ? platfomResult.id : \"\";\n\n    if (osData) {\n        os.version = osData.platformVersion;\n    }\n    if (fullVersionList && fullVersionList.length) {\n        const browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);\n\n        browser.name = browserBrandByFullVersionList.brand || browser.name;\n        browser.version = browserBrandByFullVersionList.version || browser.version;\n    } else {\n        const browserBrand = findPresetBrand(BROWSER_PRESETS, brands);\n\n        browser.name = browserBrand.brand || browser.name;\n        browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;\n    }\n    if (browser.webkit) {\n        os.name = isMobile ? \"ios\" : \"mac\";\n    }\n    if (os.name === \"ios\" && browser.webview) {\n        browser.version = \"-1\";\n    }\n\n    os.version = convertVersion(os.version);\n    browser.version = convertVersion(browser.version);\n    os.majorVersion = parseInt(os.version, 10);\n    browser.majorVersion = parseInt(browser.version, 10);\n\n    return {\n        browser,\n        os,\n        isMobile,\n        isHints: true,\n    };\n}\n","import { AgentInfo } from \"./types\";\nimport { hasUserAgentData } from \"./utils\";\nimport { getClientHintsAgent } from \"./userAgentData\";\nimport { getLegacyAgent } from \"./userAgent\";\n\n/**\n * @namespace eg.agent\n */\n\n/**\n* Extracts accuate browser and operating system information from the user agent string or client hints.\n* @ko     client hints     .\n* @function eg.agent#getAccurateAgent\n* @param - Callback function to get the accuate agent <ko>    callback </ko>\n* @return - get the accuate agent promise. If Promise are not supported, null is returned. <ko>   promise . Promise    , null . </ko>\n* @example\nimport { getAccurateAgent } from \"@egjs/agent\";\n// eg.agent.getAccurateAgent()\ngetAccurateAgent().then(agent => {\n   const { os, browser, isMobile } = agent;\n});\ngetAccurateAgent(agent => {\n    const { os, browser, isMobile } = agent;\n});\n*/\nexport function getAccurateAgent(callback?: (result: AgentInfo) => void): Promise<AgentInfo> | null {\n    if (hasUserAgentData()) {\n        return navigator.userAgentData.getHighEntropyValues([\n            \"architecture\",\n            \"model\",\n            \"platform\",\n            \"platformVersion\",\n            \"uaFullVersion\",\n            \"fullVersionList\",\n        ]).then(info => {\n            const agentInfo = getClientHintsAgent(info);\n\n            callback && callback(agentInfo);\n            return agentInfo;\n        });\n    }\n    callback && callback(agent());\n    if (typeof Promise === \"undefined\" || !Promise) {\n        return null;\n    }\n    return Promise.resolve(agent());\n}\n\n\n\n/**\n * Extracts browser and operating system information from the user agent string.\n * @ko       .\n * @function eg.agent#agent\n * @param - user agent string to parse <ko>  </ko>\n * @return - agent Info <ko>   </ko>\n * @example\nimport agent from \"@egjs/agent\";\n// eg.agent();\nconst { os, browser, isMobile } = agent();\n */\nfunction agent(userAgent?: string): AgentInfo {\n    if (typeof userAgent === \"undefined\" && hasUserAgentData()) {\n        return getClientHintsAgent();\n    } else {\n        return getLegacyAgent(userAgent);\n    }\n}\nexport { getLegacyAgent };\n\nexport default agent;\n\nexport * from \"./types\";\n","export function prefixNames(prefix: string, ...classNames: string[]) {\n    return classNames\n        .map((className) =>\n            className\n                .split(\" \")\n                .map((name) => (name ? `${prefix}${name}` : \"\"))\n                .join(\" \")\n        )\n        .join(\" \");\n}\n\nexport function prefixCSS(prefix: string, css: string) {\n    return css.replace(/([^}{]*){/gm, (_, selector) => {\n        return `${selector.replace(/\\.([^{,\\s\\d.]+)/g, `.${prefix}$1`)}{`;\n    });\n}\n\n/* react */\nexport function ref(target: any, name: string) {\n    return (e: any) => {\n        e && (target[name] = e);\n    };\n}\nexport function refs(target: any, name: string, i: number) {\n    return (e: any) => {\n        e && (target[name][i] = e);\n    };\n}\n\n/* Class Decorator */\nexport function Properties(\n    properties: any[],\n    action: (prototype: any, property: string) => any\n) {\n    return (component: any) => {\n        const prototype = component.prototype;\n\n        properties.forEach((property) => {\n            action(prototype, property);\n        });\n    };\n}\n\n/* Property Decorator */\nexport function withMethods(\n    methods: readonly string[],\n    duplicate: { [name: string]: string } = {}\n) {\n    return (prototype: any, propertyName: string) => {\n        methods.forEach((name) => {\n            const methodName = duplicate[name] || name;\n\n            if (methodName in prototype) {\n                return;\n            }\n            prototype[methodName] = function (...args) {\n                const result = this[propertyName][name](...args);\n\n                if (result === this[propertyName]) {\n                    return this;\n                } else {\n                    return result;\n                }\n            };\n        });\n    };\n}\n\nexport type ParametersType<Func, Return> = Func extends (\n    ...params: infer Params\n) => any\n    ? (...params: Params) => Return\n    : never;\n\nexport type ExcludeInterface<Obj1, Obj2> = {\n    [key in Exclude<keyof Obj1, keyof Obj2>]: Obj1[key];\n};\n\nexport type EntriesObject<T> = {\n    [key in keyof T]: [key, Readonly<T[key]>];\n};\nexport type FindKey<E, V> = E extends [infer U, V] ? U & string : never;\nexport type InvertObject<\n    T extends Record<string, any>,\n    En extends Record<string, any> = EntriesObject<T>\n    > = {\n        [key in En[keyof En][1]]: FindKey<En[keyof En], key>\n    };\n\nexport type Entries<\n    Obj extends { [key: string]: any },\n    Key = keyof Obj\n> = Key extends string ? [Key, Obj[Key]] : never;\n\nexport type ReverseKey<\n    Key extends string,\n    Obj extends { [key: string]: any },\n    E = Entries<Obj>\n> = E extends [infer Value, Key] ? Value : never;\n\nexport type UniqueMethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any }\n> = {\n    [key in keyof ExcludeInterface<Methods, Duplicate>]: Methods[key] extends (\n        ...params: any[]\n    ) => Target\n        ? ParametersType<Methods[key], ReturnTarget>\n        : Methods[key];\n};\n\nexport type ChangedMethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any }\n> = {\n    [key in Duplicate[keyof Duplicate]]: Methods[ReverseKey<key, Duplicate> &\n        keyof Methods] extends (...params: any[]) => Target\n        ? ParametersType<\n              Methods[ReverseKey<key, Duplicate> & keyof Methods],\n              ReturnTarget\n          >\n        : Methods[ReverseKey<key, Duplicate> & keyof Methods];\n};\n\nexport type MethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any } = {}\n> = UniqueMethodInterface<Methods, Target, ReturnTarget, Duplicate> &\n    ChangedMethodInterface<Methods, Target, ReturnTarget, Duplicate>;\n","/**\n* @namespace\n* @name Consts\n*/\n\nimport { IObject, OpenCloseCharacter } from \"./types\";\n\n/**\n* get string \"rgb\"\n* @memberof Color\n* @example\nimport {RGB} from \"@daybrush/utils\";\n\nconsole.log(RGB); // \"rgb\"\n*/\nexport const RGB = \"rgb\";\n/**\n* get string \"rgba\"\n* @memberof Color\n* @example\nimport {RGBA} from \"@daybrush/utils\";\n\nconsole.log(RGBA); // \"rgba\"\n*/\nexport const RGBA = \"rgba\";\n/**\n* get string \"hsl\"\n* @memberof Color\n* @example\nimport {HSL} from \"@daybrush/utils\";\n\nconsole.log(HSL); // \"hsl\"\n*/\nexport const HSL = \"hsl\";\n/**\n* get string \"hsla\"\n* @memberof Color\n* @example\nimport {HSLA} from \"@daybrush/utils\";\n\nconsole.log(HSLA); // \"hsla\"\n*/\nexport const HSLA = \"hsla\";\n/**\n* gets an array of color models.\n* @memberof Color\n* @example\nimport {COLOR_MODELS} from \"@daybrush/utils\";\n\nconsole.log(COLOR_MODELS); // [\"rgb\", \"rgba\", \"hsl\", \"hsla\"];\n*/\nexport const COLOR_MODELS = [RGB, RGBA, HSL, HSLA];\n\n/**\n* get string \"function\"\n* @memberof Consts\n* @example\nimport {FUNCTION} from \"@daybrush/utils\";\n\nconsole.log(FUNCTION); // \"function\"\n*/\nexport const FUNCTION = \"function\";\n/**\n* get string \"property\"\n* @memberof Consts\n* @example\nimport {PROPERTY} from \"@daybrush/utils\";\n\nconsole.log(PROPERTY); // \"property\"\n*/\nexport const PROPERTY = \"property\";\n/**\n* get string \"array\"\n* @memberof Consts\n* @example\nimport {ARRAY} from \"@daybrush/utils\";\n\nconsole.log(ARRAY); // \"array\"\n*/\nexport const ARRAY = \"array\";\n/**\n* get string \"object\"\n* @memberof Consts\n* @example\nimport {OBJECT} from \"@daybrush/utils\";\n\nconsole.log(OBJECT); // \"object\"\n*/\nexport const OBJECT = \"object\";\n/**\n* get string \"string\"\n* @memberof Consts\n* @example\nimport {STRING} from \"@daybrush/utils\";\n\nconsole.log(STRING); // \"string\"\n*/\nexport const STRING = \"string\";\n/**\n* get string \"number\"\n* @memberof Consts\n* @example\nimport {NUMBER} from \"@daybrush/utils\";\n\nconsole.log(NUMBER); // \"number\"\n*/\nexport const NUMBER = \"number\";\n/**\n* get string \"undefined\"\n* @memberof Consts\n* @example\nimport {UNDEFINED} from \"@daybrush/utils\";\n\nconsole.log(UNDEFINED); // \"undefined\"\n*/\nexport const UNDEFINED = \"undefined\";\n\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @example\nimport {IS_WINDOW} from \"@daybrush/utils\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\nexport const IS_WINDOW = typeof window !== UNDEFINED;\n\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @name document\n* @example\nimport {IS_WINDOW} from \"@daybrush/utils\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\nconst doc = (typeof document !== UNDEFINED && document) as Document; // FIXME: this type maybe false\n\nexport {doc as document};\n\nconst prefixes: string[] = [\"webkit\", \"ms\", \"moz\", \"o\"];\n\n/**\n * @namespace CrossBrowser\n */\n\n/**\n* Get a CSS property with a vendor prefix that supports cross browser.\n* @function\n* @param {string} property - A CSS property\n* @return {string} CSS property with cross-browser vendor prefix\n* @memberof CrossBrowser\n* @example\nimport {getCrossBrowserProperty} from \"@daybrush/utils\";\n\nconsole.log(getCrossBrowserProperty(\"transform\")); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\nconsole.log(getCrossBrowserProperty(\"filter\")); // \"filter\", \"-webkit-filter\"\n*/\nexport const getCrossBrowserProperty =  /*#__PURE__*/(property: string) => {\n  if (!doc) {\n    return \"\";\n  }\n  const styles = (doc.body || doc.documentElement).style as any;\n  const length = prefixes.length;\n\n  if (typeof styles[property] !== UNDEFINED) {\n    return property;\n  }\n  for (let i = 0; i < length; ++i) {\n    const name = `-${prefixes[i]}-${property}`;\n\n    if (typeof styles[name] !== UNDEFINED) {\n      return name;\n    }\n  }\n  return \"\";\n};\n\n/**\n* get string \"transfrom\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {TRANSFORM} from \"@daybrush/utils\";\n\nconsole.log(TRANSFORM); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\n*/\nexport const TRANSFORM = /*#__PURE__*/getCrossBrowserProperty(\"transform\");\n/**\n* get string \"filter\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {FILTER} from \"@daybrush/utils\";\n\nconsole.log(FILTER); // \"filter\", \"-ms-filter\", \"-webkit-filter\"\n*/\nexport const FILTER = /*#__PURE__*/getCrossBrowserProperty(\"filter\");\n/**\n* get string \"animation\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {ANIMATION} from \"@daybrush/utils\";\n\nconsole.log(ANIMATION); // \"animation\", \"-ms-animation\", \"-webkit-animation\"\n*/\nexport const ANIMATION = /*#__PURE__*/getCrossBrowserProperty(\"animation\");\n/**\n* get string \"keyframes\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {KEYFRAMES} from \"@daybrush/utils\";\n\nconsole.log(KEYFRAMES); // \"keyframes\", \"-ms-keyframes\", \"-webkit-keyframes\"\n*/\nexport const KEYFRAMES = /*#__PURE__*/ANIMATION.replace(\"animation\", \"keyframes\");\n\nexport const OPEN_CLOSED_CHARACTERS: OpenCloseCharacter[] = [\n  { open: \"(\", close: \")\" },\n  { open: `\"`, close: `\"`},\n  { open: `'`, close: `'`},\n  { open: `\\\\\"`, close: `\\\\\"`},\n  { open: `\\\\'`, close: `\\\\'`},\n];\nexport const TINY_NUM = 0.0000001;\nexport const REVERSE_TINY_NUM = 1 / TINY_NUM;\nexport const DEFAULT_UNIT_PRESETS: IObject<(pos: number, size?: number) => number> = {\n  \"cm\": pos => pos * 96 / 2.54,\n  \"mm\": pos => pos * 96 / 254,\n  \"in\": pos => pos * 96,\n  \"pt\": pos => pos * 96 / 72,\n  \"pc\": pos => pos * 96 / 6,\n  \"%\": (pos, size) => pos * size! / 100,\n  \"vw\": (pos, size = window.innerWidth) => pos / 100 * size,\n  \"vh\": (pos, size = window.innerHeight) => pos / 100 * size,\n  \"vmax\": (pos, size = Math.max(window.innerWidth, window.innerHeight)) => pos / 100 * size,\n  \"vmin\": (pos, size = Math.min(window.innerWidth, window.innerHeight)) => pos / 100 * size,\n};\n","import {\n  UNDEFINED, STRING,\n  OBJECT, FUNCTION,\n  IS_WINDOW, OPEN_CLOSED_CHARACTERS, NUMBER,\n  DEFAULT_UNIT_PRESETS,\n  TINY_NUM\n} from \"./consts\";\nimport {\n  FlattedElement,\n  IArrayFormat, IObject, OpenCloseCharacter,\n  SplitOptions,\n} from \"./types\";\n/**\n* @namespace\n* @name Utils\n*/\n\n/**\n * Returns the inner product of two numbers(`a1`, `a2`) by two criteria(`b1`, `b2`).\n * @memberof Utils\n * @param - The first number\n * @param - The second number\n * @param - The first number to base on the inner product\n * @param - The second number to base on the inner product\n * @return - Returns the inner product\nimport { dot } from \"@daybrush/utils\";\n\nconsole.log(dot(0, 15, 2, 3)); // 6\nconsole.log(dot(5, 15, 2, 3)); // 9\nconsole.log(dot(5, 15, 1, 1)); // 10\n */\nexport function dot(a1: number, a2: number, b1: number, b2: number) {\n  return (a1 * b2 + a2 * b1) / (b1 + b2);\n}\n/**\n* Check the type that the value is undefined.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {boolean} true if the type is correct, false otherwise\n* @example\nimport {isUndefined} from \"@daybrush/utils\";\n\nconsole.log(isUndefined(undefined)); // true\nconsole.log(isUndefined(\"\")); // false\nconsole.log(isUndefined(1)); // false\nconsole.log(isUndefined(null)); // false\n*/\nexport function isUndefined(value: any): value is undefined {\n  return (typeof value === UNDEFINED);\n}\n/**\n* Check the type that the value is object.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isObject} from \"@daybrush/utils\";\n\nconsole.log(isObject({})); // true\nconsole.log(isObject(undefined)); // false\nconsole.log(isObject(\"\")); // false\nconsole.log(isObject(null)); // false\n*/\nexport function isObject(value: any): value is IObject<any> {\n  return value && (typeof value === OBJECT);\n}\n/**\n* Check the type that the value is isArray.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isArray} from \"@daybrush/utils\";\n\nconsole.log(isArray([])); // true\nconsole.log(isArray({})); // false\nconsole.log(isArray(undefined)); // false\nconsole.log(isArray(null)); // false\n*/\nexport function isArray(value: any): value is any[] {\n  return Array.isArray(value);\n}\n/**\n* Check the type that the value is string.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isString} from \"@daybrush/utils\";\n\nconsole.log(isString(\"1234\")); // true\nconsole.log(isString(undefined)); // false\nconsole.log(isString(1)); // false\nconsole.log(isString(null)); // false\n*/\nexport function isString(value: any): value is string {\n  return typeof value === STRING;\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === NUMBER;\n}\n\n/**\n* Check the type that the value is function.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isFunction} from \"@daybrush/utils\";\n\nconsole.log(isFunction(function a() {})); // true\nconsole.log(isFunction(() => {})); // true\nconsole.log(isFunction(\"1234\")); // false\nconsole.log(isFunction(1)); // false\nconsole.log(isFunction(null)); // false\n*/\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === FUNCTION;\n}\nfunction isEqualSeparator(\n  character: string,\n  separator: string,\n) {\n  const isCharacterSpace = character === \"\" || character == \" \";\n  const isSeparatorSpace = separator === \"\" || separator == \" \";\n\n  return (isSeparatorSpace && isCharacterSpace) || character === separator;\n}\nfunction findOpen(\n  openCharacter: OpenCloseCharacter,\n  texts: string[],\n  index: number,\n  length: number,\n  openCloseCharacters: OpenCloseCharacter[],\n) {\n  const isIgnore = findIgnore(openCharacter, texts, index);\n\n  if (!isIgnore) {\n    return findClose(openCharacter, texts, index + 1, length, openCloseCharacters);\n  }\n  return index;\n}\nfunction findIgnore(\n  character: OpenCloseCharacter,\n  texts: string[],\n  index: number,\n) {\n  if (!character.ignore) {\n    return null;\n  }\n  const otherText = texts.slice(Math.max(index - 3, 0), index + 3).join(\"\");\n\n  return new RegExp(character.ignore).exec(otherText);\n\n}\nfunction findClose(\n  closeCharacter: OpenCloseCharacter,\n  texts: string[],\n  index: number,\n  length: number,\n  openCloseCharacters: OpenCloseCharacter[],\n) {\n  for (let i = index; i < length; ++i) {\n    const character = texts[i].trim();\n\n    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i)) {\n      return i;\n    }\n    let nextIndex = i;\n    // re open\n    const openCharacter = find(openCloseCharacters, ({ open }) => open === character);\n\n    if (openCharacter) {\n      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);\n    }\n    if (nextIndex === -1) {\n      break;\n    }\n    i = nextIndex;\n  }\n  return -1;\n}\n\nexport function splitText(\n  text: string,\n  splitOptions: string | SplitOptions,\n): string[] {\n  const {\n    separator = \",\",\n    isSeparateFirst,\n    isSeparateOnlyOpenClose,\n    isSeparateOpenClose = isSeparateOnlyOpenClose,\n    openCloseCharacters = OPEN_CLOSED_CHARACTERS,\n  } = isString(splitOptions) ? {\n    separator: splitOptions,\n  } as SplitOptions : splitOptions;\n  const openClosedText = openCloseCharacters.map(({ open, close }) => {\n    if (open === close) {\n      return open;\n    }\n    return `${open}|${close}`;\n  }).join(\"|\");\n  const regexText = `(\\\\s*${separator}\\\\s*|${openClosedText}|\\\\s+)`;\n  const regex = new RegExp(regexText, \"g\");\n  const texts = text.split(regex).filter(Boolean);\n  const length = texts.length;\n  const values: string[] = [];\n  let tempValues: string[] = [];\n\n  function resetTemp() {\n    if (tempValues.length) {\n      values.push(tempValues.join(\"\"));\n      tempValues = [];\n\n      return true;\n    }\n    return false;\n  }\n  for (let i = 0; i < length; ++i) {\n    const character = texts[i].trim();\n    let nextIndex = i;\n\n\n    const openCharacter = find(openCloseCharacters, ({ open }) => open === character);\n    const closeCharacter = find(openCloseCharacters, ({ close }) => close === character);\n\n    if (openCharacter) {\n      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);\n\n      if (nextIndex !== -1 && isSeparateOpenClose) {\n        if (resetTemp() && isSeparateFirst) {\n          break;\n        }\n        values.push(texts.slice(i, nextIndex + 1).join(\"\"));\n        i = nextIndex;\n\n        if (isSeparateFirst) {\n          break;\n        }\n        continue;\n      }\n    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i)) {\n      const nextOpenCloseCharacters = [...openCloseCharacters];\n\n      nextOpenCloseCharacters.splice(openCloseCharacters.indexOf(closeCharacter), 1);\n\n      return splitText(\n        text,\n        {\n          separator,\n          isSeparateFirst,\n          isSeparateOnlyOpenClose,\n          isSeparateOpenClose,\n          openCloseCharacters: nextOpenCloseCharacters,\n        });\n    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {\n      resetTemp();\n      if (isSeparateFirst) {\n        break;\n      }\n      continue;\n    }\n\n    if (nextIndex === -1) {\n      nextIndex = length - 1;\n    }\n    tempValues.push(texts.slice(i, nextIndex + 1).join(\"\"));\n    i = nextIndex;\n  }\n  if (tempValues.length) {\n    values.push(tempValues.join(\"\"));\n  }\n  return values;\n}\n\n/**\n* divide text by space.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {spliceSpace} from \"@daybrush/utils\";\n\nconsole.log(splitSpace(\"a b c d e f g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitSpace(\"'a,b' c 'd,e' f g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\nexport function splitSpace(text: string) {\n  // divide comma(space)\n  return splitText(text, \"\");\n}\n\n/**\n* divide text by comma.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {splitComma} from \"@daybrush/utils\";\n\nconsole.log(splitComma(\"a,b,c,d,e,f,g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitComma(\"'a,b',c,'d,e',f,g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\nexport function splitComma(text: string): string[] {\n  // divide comma(,)\n  // \"[^\"]*\"|'[^']*'\n  return splitText(text, \",\");\n}\n/**\n* divide text by bracket \"(\", \")\".\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {object} divided texts\n* @example\nimport {splitBracket} from \"@daybrush/utils\";\n\nconsole.log(splitBracket(\"a(1, 2)\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"\"}\nconsole.log(splitBracket(\"a(1, 2)b\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"b\"}\n*/\nexport function splitBracket(text: string) {\n  const matches = (/([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g).exec(text);\n\n  if (!matches || matches.length < 4) {\n    return {};\n  } else {\n    return { prefix: matches[1], value: matches[2], suffix: matches[3] };\n  }\n}\n/**\n* divide text by number and unit.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {} divided texts\n* @example\nimport {splitUnit} from \"@daybrush/utils\";\n\nconsole.log(splitUnit(\"10px\"));\n// {prefix: \"\", value: 10, unit: \"px\"}\nconsole.log(splitUnit(\"-10px\"));\n// {prefix: \"\", value: -10, unit: \"px\"}\nconsole.log(splitUnit(\"a10%\"));\n// {prefix: \"a\", value: 10, unit: \"%\"}\n*/\nexport function splitUnit(text: string): { prefix: string, unit: string, value: number } {\n  const matches = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(text);\n\n  if (!matches) {\n    return { prefix: \"\", unit: \"\", value: NaN };\n  }\n  const prefix = matches[1];\n  const value = matches[2];\n  const unit = matches[3];\n\n  return { prefix, unit, value: parseFloat(value) };\n}\n\n/**\n* transform strings to camel-case\n* @memberof Utils\n* @param {String} text - string\n* @return {String} camel-case string\n* @example\nimport {camelize} from \"@daybrush/utils\";\n\nconsole.log(camelize(\"transform-origin\")); // transformOrigin\nconsole.log(camelize(\"abcd_efg\")); // abcdEfg\nconsole.log(camelize(\"abcd efg\")); // abcdEfg\n*/\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]([a-z])/g, (all, letter) => letter.toUpperCase());\n}\n/**\n* transform a camelized string into a lowercased string.\n* @memberof Utils\n* @param {string} text - a camel-cased string\n* @param {string} [separator=\"-\"] - a separator\n* @return {string}  a lowercased string\n* @example\nimport {decamelize} from \"@daybrush/utils\";\n\nconsole.log(decamelize(\"transformOrigin\")); // transform-origin\nconsole.log(decamelize(\"abcdEfg\", \"_\")); // abcd_efg\n*/\nexport function decamelize(str: string, separator: string = \"-\") {\n  return str.replace(/([a-z])([A-Z])/g, (all, letter, letter2) => `${letter}${separator}${letter2.toLowerCase()}`);\n}\n\n/**\n* transforms something in an array into an array.\n* @memberof Utils\n* @param - Array form\n* @return an array\n* @example\nimport {toArray} from \"@daybrush/utils\";\n\nconst arr1 = toArray(document.querySelectorAll(\".a\")); // Element[]\nconst arr2 = toArray(document.querySelectorAll<HTMLElement>(\".a\")); // HTMLElement[]\n*/\nexport function toArray<T>(value: IArrayFormat<T>): T[] {\n  return [].slice.call(value);\n}\n\n/**\n* Date.now() method\n* @memberof CrossBrowser\n* @return {number} milliseconds\n* @example\nimport {now} from \"@daybrush/utils\";\n\nconsole.log(now()); // 12121324241(milliseconds)\n*/\nexport function now() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\n\n/**\n* Returns the index of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findIndex` was called upon.\n* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.\n* @param - Returns defaultIndex if not found by the function.\n* @example\nimport { findIndex } from \"@daybrush/utils\";\n\nfindIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1\n*/\nexport function findIndex<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defaultIndex: number = -1,\n): number {\n  const length = arr.length;\n\n  for (let i = 0; i < length; ++i) {\n    if (callback(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return defaultIndex;\n}\n\n/**\n* Returns the reverse direction index of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findLastIndex` was called upon.\n* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.\n* @param - Returns defaultIndex if not found by the function.\n* @example\nimport { findLastIndex } from \"@daybrush/utils\";\n\nfindLastIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1\n*/\nexport function findLastIndex<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defaultIndex: number = -1,\n): number {\n  const length = arr.length;\n\n  for (let i = length - 1; i >= 0; --i) {\n    if (callback(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return defaultIndex;\n}\n\n/**\n* Returns the value of the reverse direction element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findLast` was called upon.\n* @param - A function to execute on each value in the array,\n* @param - Returns defalutValue if not found by the function.\n* @example\nimport { find } from \"@daybrush/utils\";\n\nfind([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}\n*/\nexport function findLast<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defalutValue?: T,\n): T | undefined {\n  const index = findLastIndex(arr, callback);\n\n  return index > - 1 ? arr[index] : defalutValue;\n}\n/**\n* Returns the value of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `find` was called upon.\n* @param - A function to execute on each value in the array,\n* @param - Returns defalutValue if not found by the function.\n* @example\nimport { find } from \"@daybrush/utils\";\n\nfind([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}\n*/\nexport function find<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defalutValue?: T,\n): T | undefined {\n  const index = findIndex(arr, callback);\n\n  return index > - 1 ? arr[index] : defalutValue;\n}\n\n/**\n* window.requestAnimationFrame() method with cross browser.\n* @function\n* @memberof CrossBrowser\n* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.\n* @return {number} id\n* @example\nimport {requestAnimationFrame} from \"@daybrush/utils\";\n\nrequestAnimationFrame((timestamp) => {\n  console.log(timestamp);\n});\n*/\nexport const requestAnimationFrame = /*#__PURE__*/(() => {\n  const firstTime = now();\n\n  const raf = IS_WINDOW\n    && (window.requestAnimationFrame || (window as any).webkitRequestAnimationFrame\n      || (window as any).mozRequestAnimationFrame || (window as any).msRequestAnimationFrame);\n\n  return raf ? (raf.bind(window) as (callback: FrameRequestCallback) => number) : ((callback: FrameRequestCallback) => {\n    const currTime = now();\n    const id = setTimeout(() => {\n      callback(currTime - firstTime);\n    }, 1000 / 60);\n\n    return id as any as number;\n  });\n})();\n\n/**\n* window.cancelAnimationFrame() method with cross browser.\n* @function\n* @memberof CrossBrowser\n* @param {number} handle - the id obtained through requestAnimationFrame method\n* @return {void}\n* @example\nimport { requestAnimationFrame, cancelAnimationFrame } from \"@daybrush/utils\";\n\nconst id = requestAnimationFrame((timestamp) => {\n  console.log(timestamp);\n});\n\ncancelAnimationFrame(id);\n*/\nexport const cancelAnimationFrame = /*#__PURE__*/(() => {\n  const caf = IS_WINDOW\n    && (window.cancelAnimationFrame || (window as any).webkitCancelAnimationFrame\n      || (window as any).mozCancelAnimationFrame || (window as any).msCancelAnimationFrame);\n\n  return caf\n    ? caf.bind(window) as (handle: number) => void\n    : ((handle: number) => { clearTimeout(handle); });\n})();\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function getKeys(obj: IObject<any>): string[] {\n  return Object.keys(obj);\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function getValues(obj: IObject<any>): any[] {\n  const keys = getKeys(obj);\n\n  return keys.map(key => obj[key]);\n}\n/**\n* @function\n* @memberof Utils\n*/\nexport function getEntries(obj: IObject<any>): [string, any][] {\n  const keys = getKeys(obj);\n\n  return keys.map(key => [key, obj[key]]);\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function sortOrders(keys: Array<string | number>, orders: Array<string | number> = []) {\n  keys.sort((a, b) => {\n    const index1 = orders.indexOf(a);\n    const index2 = orders.indexOf(b);\n\n    if (index2 === -1 && index1 === -1) {\n      return 0;\n    }\n    if (index1 === -1) {\n      return 1;\n    }\n    if (index2 === -1) {\n      return -1;\n    }\n    return index1 - index2;\n  });\n}\n\n/**\n* convert unit size to px size\n* @function\n* @memberof Utils\n*/\nexport function convertUnitSize(pos: string, size: number | IObject<((pos: number) => number) | number>) {\n  const { value, unit } = splitUnit(pos);\n\n  if (isObject(size)) {\n    const sizeFunction = size[unit];\n    if (sizeFunction) {\n      if (isFunction(sizeFunction)) {\n        return sizeFunction(value);\n      } else if (DEFAULT_UNIT_PRESETS[unit]) {\n        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);\n      }\n    }\n  } else if (unit === \"%\") {\n    return value * size / 100;\n  }\n  if (DEFAULT_UNIT_PRESETS[unit]) {\n    return DEFAULT_UNIT_PRESETS[unit](value);\n  }\n  return value;\n}\n\n/**\n* calculate between min, max\n* @function\n* @memberof Utils\n*/\nexport function between(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(value, max));\n}\n\nexport function checkBoundSize(targetSize: number[], compareSize: number[], isMax: boolean, ratio = targetSize[0] / targetSize[1]) {\n  return [\n    [throttle(compareSize[0], TINY_NUM), throttle(compareSize[0] / ratio, TINY_NUM)],\n    [throttle(compareSize[1] * ratio, TINY_NUM), throttle(compareSize[1], TINY_NUM)],\n  ].filter(size => size.every((value, i) => {\n    const defaultSize = compareSize[i];\n    const throttledSize = throttle(defaultSize, TINY_NUM);\n\n    return isMax ? value <= defaultSize || value <= throttledSize : value >= defaultSize || value >= throttledSize;\n  }))[0] || targetSize;\n}\n\n/**\n* calculate bound size\n* @function\n* @memberof Utils\n*/\nexport function calculateBoundSize(\n  size: number[],\n  minSize: number[],\n  maxSize: number[],\n  keepRatio?: number | boolean,\n): number[] {\n  if (!keepRatio) {\n    return size.map((value, i) => between(value, minSize[i], maxSize[i]));\n  }\n  let [width, height] = size;\n\n  const ratio = keepRatio === true ? width / height : keepRatio;\n  // width : height = minWidth : minHeight;\n  const [minWidth, minHeight] = checkBoundSize(size, minSize, false, ratio);\n  const [maxWidth, maxHeight] = checkBoundSize(size, maxSize, true, ratio);\n\n  if (width < minWidth || height < minHeight) {\n    width = minWidth;\n    height = minHeight;\n  } else if (width > maxWidth || height > maxHeight) {\n    width = maxWidth;\n    height = maxHeight;\n  }\n  return [width, height];\n}\n\n\n/**\n* Add all the numbers.\n* @function\n* @memberof Utils\n*/\nexport function sum(nums: number[]): number {\n  const length = nums.length;\n  let total = 0;\n\n  for (let i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n  return total;\n}\n\n/**\n* Average all numbers.\n* @function\n* @memberof Utils\n*/\nexport function average(nums: number[]) {\n  const length = nums.length;\n  let total = 0;\n\n  for (let i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n  return length ? total / length : 0;\n}\n/**\n* Get the angle of two points. (0 <= rad < 359)\n* @function\n* @memberof Utils\n*/\nexport function getRad(pos1: number[], pos2: number[]): number {\n  const distX = pos2[0] - pos1[0];\n  const distY = pos2[1] - pos1[1];\n  const rad = Math.atan2(distY, distX);\n\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n/**\n* Get the average point of all points.\n* @function\n* @memberof Utils\n*/\nexport function getCenterPoint(points: number[][]): number[] {\n  return [0, 1].map(i => average(points.map(pos => pos[i])));\n}\n/**\n* Gets the direction of the shape.\n* @function\n* @memberof Utils\n*/\nexport function getShapeDirection(points: number[][]): 1 | -1 {\n  const center = getCenterPoint(points);\n  const pos1Rad = getRad(center, points[0]);\n  const pos2Rad = getRad(center, points[1]);\n\n  return (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) || (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n    ? 1 : -1;\n}\n\n/**\n* Get the distance between two points.\n* @function\n* @memberof Utils\n*/\nexport function getDist(a: number[], b?: number[]) {\n  return Math.sqrt(Math.pow((b ? b[0] : 0) - a[0], 2) + Math.pow((b ? b[1] : 0) - a[1], 2));\n}\n\n/**\n* throttle number depending on the unit.\n* @function\n* @memberof Utils\n*/\nexport function throttle(num: number, unit?: number) {\n  if (!unit) {\n    return num;\n  }\n  const reverseUnit = 1 / unit;\n  return Math.round(num / unit) / reverseUnit;\n}\n\n/**\n* throttle number array depending on the unit.\n* @function\n* @memberof Utils\n*/\nexport function throttleArray(nums: number[], unit?: number) {\n  nums.forEach((_, i) => {\n    nums[i] = throttle(nums[i], unit);\n  });\n  return nums;\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function counter(num: number): number[] {\n  const nums: number[] = [];\n\n  for (let i = 0; i < num; ++i) {\n    nums.push(i);\n  }\n\n  return nums;\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function replaceOnce(text: string, fromText: RegExp | string, toText: string | ((...args: any[]) => string)): string {\n  let isOnce = false;\n  return text.replace(fromText, (...args: any[]) => {\n    if (isOnce) {\n      return args[0];\n    }\n    isOnce = true;\n    return isString(toText) ? toText : toText(...args);\n  });\n}\n\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function flat<Type>(arr: Type[][]): Type[] {\n  return arr.reduce((prev, cur) => {\n    return prev.concat(cur);\n  }, []);\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function deepFlat<T extends any[]>(arr: T): Array<FlattedElement<T[0]>> {\n  return arr.reduce((prev, cur) => {\n    if (isArray(cur)) {\n      prev.push(...deepFlat(cur));\n    } else {\n      prev.push(cur);\n    }\n    return prev;\n  }, [] as any[]);\n}\n","import { document } from \"./consts\";\nimport { IObject, IEventMap } from \"./types\";\n\n/**\n * @namespace DOM\n */\n\nexport function $<K extends keyof HTMLElementTagNameMap>(selectors: K, multi: true):\n  NodeListOf<HTMLElementTagNameMap[K]>;\nexport function $<K extends keyof SVGElementTagNameMap>(selectors: K, multi: true): NodeListOf<SVGElementTagNameMap[K]>;\nexport function $<E extends Element = Element>(selectors: string, multi: true): NodeListOf<E>;\n\nexport function $<K extends keyof HTMLElementTagNameMap>(selectors: K, multi?: false): HTMLElementTagNameMap[K] | null;\nexport function $<K extends keyof SVGElementTagNameMap>(selectors: K, multi?: false): SVGElementTagNameMap[K] | null;\nexport function $<E extends Element = Element>(selectors: string, multi?: false): E | null;\n/**\n * Returns all element descendants of node that\n * match selectors.\n */\n\n/**\n * Checks if the specified class value exists in the element's class attribute.\n * @memberof DOM\n * @param - A DOMString containing one or more selectors to match\n * @param - If multi is true, a DOMString containing one or more selectors to match against.\n * @example\nimport {$} from \"@daybrush/utils\";\n\nconsole.log($(\"div\")); // div element\nconsole.log($(\"div\", true)); // [div, div] elements\n*/\nexport function $<E extends Element = Element>(selectors: string, multi?: boolean): E | NodeListOf<E> | null {\n  if (!document) {\n    return multi ? [] as any : null;\n  }\n  return multi ? document.querySelectorAll<E>(selectors) : document.querySelector<E>(selectors);\n}\n\n/**\n* Checks if the specified class value exists in the element's class attribute.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to search\n* @return {boolean} return false if the class is not found.\n* @example\nimport {hasClass} from \"@daybrush/utils\";\n\nconsole.log(hasClass(element, \"start\")); // true or false\n*/\nexport function hasClass(element: Element, className: string) {\n  if (element.classList) {\n    return element.classList.contains(className);\n  }\n  return !!element.className.match(new RegExp(`(\\\\s|^)${className}(\\\\s|$)`));\n}\n\n/**\n* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to add\n* @example\nimport {addClass} from \"@daybrush/utils\";\n\naddClass(element, \"start\");\n*/\nexport function addClass(element: Element, className: string) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    element.className += ` ${className}`;\n  }\n}\n\n/**\n* Removes the specified class value.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to remove\n* @example\nimport {removeClass} from \"@daybrush/utils\";\n\nremoveClass(element, \"start\");\n*/\nexport function removeClass(element: Element, className: string) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    const reg = new RegExp(`(\\\\s|^)${className}(\\\\s|$)`);\n\n    element.className = element.className.replace(reg, \" \");\n  }\n}\n\n/**\n* Gets the CSS properties from the element.\n* @memberof DOM\n* @param elements - elements\n* @param properites - the CSS properties\n* @return returns CSS properties and values.\n* @example\nimport {fromCSS} from \"@daybrush/utils\";\n\nconsole.log(fromCSS(element, [\"left\", \"opacity\", \"top\"])); // {\"left\": \"10px\", \"opacity\": 1, \"top\": \"10px\"}\n*/\nexport function fromCSS(\n  elements: Element | Element[] | NodeListOf<Element>, properties: string[]): IObject<any> {\n  if (!elements || !properties || !properties.length) {\n    return {};\n  }\n  let element;\n\n  if (elements instanceof Element) {\n    element = elements;\n  } else if (elements.length) {\n    element = elements[0];\n  } else {\n    return {};\n  }\n  const cssObject: IObject<any> = {};\n  const styles = window.getComputedStyle(element) as any;\n  const length = properties.length;\n\n  for (let i = 0; i < length; ++i) {\n    cssObject[properties[i]] = styles[properties[i]];\n  }\n  return cssObject;\n}\n\nexport function addEvent<K extends keyof IEventMap>(\n  el: EventTarget, type: K, listener: (e: IEventMap[K]) => void, options?: boolean | AddEventListenerOptions): void;\n/**\n* Sets up a function that will be called whenever the specified event is delivered to the target\n* @memberof DOM\n* @param - event target\n* @param - A case-sensitive string representing the event type to listen for.\n* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs\n* @param - An options object that specifies characteristics about the event listener.\n* @example\nimport {addEvent} from \"@daybrush/utils\";\n\naddEvent(el, \"click\", e => {\n  console.log(e);\n});\n*/\nexport function addEvent(\n  el: EventTarget,\n  type: string, listener: (e: Event) => void,\n  options?: boolean | AddEventListenerOptions) {\n  el.addEventListener(type, listener, options);\n}\n\nexport function removeEvent<K extends keyof IEventMap>(\n  el: EventTarget, type: K, listener: (e: IEventMap[K]) => void, options?: boolean | EventListenerOptions): void;\n/**\n* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()\n* @memberof DOM\n* @param - event target\n* @param - A case-sensitive string representing the event type to listen for.\n* @param - The EventListener function of the event handler to remove from the event target.\n* @param - An options object that specifies characteristics about the event listener.\n* @example\nimport {addEvent, removeEvent} from \"@daybrush/utils\";\nconst listener = e => {\n  console.log(e);\n};\naddEvent(el, \"click\", listener);\nremoveEvent(el, \"click\", listener);\n*/\nexport function removeEvent(\n  el: EventTarget, type: string,\n  listener: (e: Event) => void,\n  options?: boolean | EventListenerOptions,\n) {\n  el.removeEventListener(type, listener, options);\n}\n","import { average, throttle, TINY_NUM } from \"@daybrush/utils\";\n\nfunction add(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    fromIndex: number,\n    n: number,\n    k: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n        const fromX = fromIndex + i * n;\n        matrix[x] += matrix[fromX] * k;\n        inverseMatrix[x] += inverseMatrix[fromX] * k;\n    }\n}\n\nfunction swap(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    fromIndex: number,\n    n: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n        const fromX = fromIndex + i * n;\n        const v = matrix[x];\n        const iv = inverseMatrix[x];\n\n        matrix[x] = matrix[fromX];\n        matrix[fromX] = v;\n\n        inverseMatrix[x] = inverseMatrix[fromX];\n        inverseMatrix[fromX] = iv;\n    }\n}\n\nfunction divide(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    n: number,\n    k: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n\n        matrix[x] /= k;\n        inverseMatrix[x] /= k;\n    }\n}\n\n/**\n *\n * @namespace Matrix\n */\n/**\n * @memberof Matrix\n */\nexport function ignoreDimension(\n    matrix: number[],\n    m: number,\n    n: number = Math.sqrt(matrix.length),\n) {\n    const newMatrix = matrix.slice();\n\n    for (let i = 0; i < n; ++i) {\n        newMatrix[i * n + m - 1] = 0;\n        newMatrix[(m - 1) * n + i] = 0;\n    }\n    newMatrix[(m - 1) * (n + 1)] = 1;\n\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function invert(\n    matrix: number[],\n    n: number = Math.sqrt(matrix.length),\n) {\n    const newMatrix = matrix.slice();\n    const inverseMatrix = createIdentityMatrix(n);\n\n    for (let i = 0; i < n; ++i) {\n        // diagonal\n        const identityIndex = n * i + i;\n\n        if (!throttle(newMatrix[identityIndex], TINY_NUM)) {\n            // newMatrix[identityIndex] = 0;\n            for (let j = i + 1; j < n; ++j) {\n                if (newMatrix[n * i + j]) {\n                    swap(newMatrix, inverseMatrix, i, j, n);\n                    break;\n                }\n            }\n        }\n        if (!throttle(newMatrix[identityIndex], TINY_NUM)) {\n            // no inverse matrix\n            return [];\n        }\n        divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);\n        for (let j = 0; j < n; ++j) {\n            const targetStartIndex = j;\n            const targetIndex = j + i * n;\n            const target = newMatrix[targetIndex];\n\n            if (!throttle(target, TINY_NUM) || i === j) {\n                continue;\n            }\n            add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);\n        }\n    }\n\n    return inverseMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function transpose(matrix: number[], n: number = Math.sqrt(matrix.length)) {\n    const newMatrix: number[] = [];\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            newMatrix[j * n + i] = matrix[n * i + j];\n        }\n    }\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function getOrigin(matrix: number[], n: number = Math.sqrt(matrix.length)) {\n    const originMatrix: number[] = [];\n    const w = matrix[n * n - 1];\n    for (let i = 0; i < n - 1; ++i) {\n        originMatrix[i] = matrix[n * (n - 1) + i] / w;\n    }\n    originMatrix[n - 1] = 0;\n    return originMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function fromTranslation(pos: number[], n: number) {\n    const newMatrix = createIdentityMatrix(n);\n\n    for (let i = 0; i < n - 1; ++i) {\n        newMatrix[n * (n - 1) + i] = pos[i] || 0;\n    }\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertPositionMatrix(matrix: number[], n: number) {\n    const newMatrix = matrix.slice();\n\n    for (let i = matrix.length; i < n - 1; ++i) {\n        newMatrix[i] = 0;\n    }\n    newMatrix[n - 1] = 1;\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertDimension(matrix: number[], n: number = Math.sqrt(matrix.length), m: number) {\n    // n < m\n    if (n === m) {\n        return matrix;\n    }\n    const newMatrix = createIdentityMatrix(m);\n\n    const length = Math.min(n, m);\n    for (let i = 0; i < length - 1; ++i) {\n        for (let j = 0; j < length - 1; ++j) {\n            newMatrix[i * m + j] = matrix[i * n + j];\n        }\n\n        newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];\n        newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];\n    }\n    newMatrix[m * m - 1] = matrix[n * n - 1];\n\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function multiplies(n: number, ...matrixes: number[][]) {\n    let m: number[] = createIdentityMatrix(n);\n\n    matrixes.forEach(matrix => {\n        m = multiply(m, matrix, n);\n    });\n    return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function multiply(matrix: number[], matrix2: number[], n: number = Math.sqrt(matrix.length)) {\n    const newMatrix: number[] = [];\n    // 1 y: n\n    // 1 x: m\n    // 2 x: m\n    // 2 y: k\n    // n * m X m * k\n    const m = matrix.length / n;\n    const k = matrix2.length / m;\n\n    if (!m) {\n        return matrix2;\n    } else if (!k) {\n        return matrix;\n    }\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < k; ++j) {\n            newMatrix[j * n + i] = 0;\n            for (let l = 0; l < m; ++l) {\n                // m1 x: m(l), y: n(i)\n                // m2 x: k(j):  y: m(l)\n                // nw x: n(i), y: k(j)\n                newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];\n            }\n        }\n    }\n    // n * k\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function plus(pos1: number[], pos2: number[]) {\n    const length = Math.min(pos1.length, pos2.length);\n    const nextPos = pos1.slice();\n\n    for (let i = 0; i < length; ++i) {\n        nextPos[i] = nextPos[i] + pos2[i];\n    }\n    return nextPos;\n}\n\n/**\n * @memberof Matrix\n */\nexport function minus(pos1: number[], pos2: number[]) {\n    const length = Math.min(pos1.length, pos2.length);\n    const nextPos = pos1.slice();\n\n    for (let i = 0; i < length; ++i) {\n        nextPos[i] = nextPos[i] - pos2[i];\n    }\n    return nextPos;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertCSStoMatrix(a: number[], is2d: boolean = a.length === 6) {\n    if (is2d) {\n        return [\n            a[0], a[1], 0,\n            a[2], a[3], 0,\n            a[4], a[5], 1,\n        ];\n    }\n    return a;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertMatrixtoCSS(a: number[], is2d: boolean = a.length === 9) {\n    if (is2d) {\n        return [\n            a[0], a[1],\n            a[3], a[4],\n            a[6], a[7],\n        ];\n    }\n    return a;\n}\n\n/**\n * @memberof Matrix\n */\nexport function calculate(matrix: number[], matrix2: number[], n: number = matrix2.length) {\n    const result = multiply(matrix, matrix2, n);\n    const k = result[n - 1];\n    return result.map(v => v / k);\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotateX3d(matrix: number[], rad: number) {\n    return multiply(\n        matrix,\n        [\n            1, 0, 0, 0,\n            0, Math.cos(rad), Math.sin(rad), 0,\n            0, -Math.sin(rad), Math.cos(rad), 0,\n            0, 0, 0, 1,\n        ],\n        4,\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotateY3d(matrix: number[], rad: number) {\n    return multiply(\n        matrix,\n        [\n            Math.cos(rad), 0, -Math.sin(rad), 0,\n            0, 1, 0, 0,\n            Math.sin(rad), 0, Math.cos(rad), 0,\n            0, 0, 0, 1,\n        ],\n        4,\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotateZ3d(matrix: number[], rad: number) {\n    return multiply(\n        matrix,\n        createRotateMatrix(rad, 4),\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function scale3d(matrix: number[], [\n    sx = 1,\n    sy = 1,\n    sz = 1,\n]: number[]) {\n    return multiply(\n        matrix,\n        [\n            sx, 0, 0, 0,\n            0, sy, 0, 0,\n            0, 0, sz, 0,\n            0, 0, 0, 1,\n        ],\n        4,\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotate(pos: number[], rad: number) {\n    return calculate(\n        createRotateMatrix(rad, 3),\n        convertPositionMatrix(pos, 3),\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function translate3d(matrix, [\n    tx = 0,\n    ty = 0,\n    tz = 0,\n]: number[]) {\n    return multiply(\n        matrix,\n        [\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            tx, ty, tz, 1,\n        ],\n        4,\n    );\n}\n/**\n * @memberof Matrix\n */\nexport function matrix3d(matrix1: number[], matrix2: number[]) {\n    return multiply(matrix1, matrix2, 4);\n}\n\n/**\n * @memberof Matrix\n */\nexport function createRotateMatrix(rad: number, n: number) {\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    const m = createIdentityMatrix(n);\n\n    // cos -sin\n    // sin cos\n    m[0] = cos;\n    m[1] = sin;\n    m[n] = -sin;\n    m[n + 1] = cos;\n\n    return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createIdentityMatrix(n: number) {\n    const length = n * n;\n    const matrix: number[] = [];\n\n    for (let i = 0; i < length; ++i) {\n        matrix[i] = i % (n + 1) ? 0 : 1;\n    }\n    return matrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createScaleMatrix(scale: number[], n: number) {\n    const m = createIdentityMatrix(n);\n    const length = Math.min(scale.length, n - 1);\n\n    for (let i = 0; i < length; ++i) {\n        m[(n + 1) * i] = scale[i];\n    }\n    return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createOriginMatrix(origin: number[], n: number) {\n    const m = createIdentityMatrix(n);\n    const length = Math.min(origin.length, n - 1);\n\n    for (let i = 0; i < length; ++i) {\n        m[n * (n - 1) + i] = origin[i];\n    }\n    return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createWarpMatrix(\n    pos0: number[],\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    nextPos0: number[],\n    nextPos1: number[],\n    nextPos2: number[],\n    nextPos3: number[],\n) {\n    const [x0, y0] = pos0;\n    const [x1, y1] = pos1;\n    const [x2, y2] = pos2;\n    const [x3, y3] = pos3;\n\n    const [u0, v0] = nextPos0;\n    const [u1, v1] = nextPos1;\n    const [u2, v2] = nextPos2;\n    const [u3, v3] = nextPos3;\n\n    const matrix = [\n        x0, 0, x1, 0, x2, 0, x3, 0,\n        y0, 0, y1, 0, y2, 0, y3, 0,\n        1, 0, 1, 0, 1, 0, 1, 0,\n        0, x0, 0, x1, 0, x2, 0, x3,\n        0, y0, 0, y1, 0, y2, 0, y3,\n        0, 1, 0, 1, 0, 1, 0, 1,\n        -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3,\n        -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3,\n    ];\n    const inverseMatrix = invert(matrix, 8);\n\n    if (!inverseMatrix.length) {\n        return [];\n    }\n    const h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);\n\n    h[8] = 1;\n    return convertDimension(transpose(h), 3, 4);\n}\n\n/**\n * @memberof Matrix\n */\nexport function getCenter(points: number[][]) {\n    return [0, 1].map(i => average(points.map(pos => pos[i])));\n}\n","import { splitComma, splitBracket, splitUnit, splitSpace, isArray } from \"@daybrush/utils\";\nimport { MatrixInfo } from \"./types\";\nimport { calculate, invert, matrix3d, rotateX3d, rotateY3d, rotateZ3d, scale3d, translate3d } from \"@scena/matrix\";\n\nexport function createMatrix() {\n    return [\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1,\n    ];\n}\nexport function parseMat(transform: string | string[]): number[] {\n    return toMat(parse(transform));\n}\nexport function getElementMatrix(el: HTMLElement) {\n    return parseMat(getComputedStyle(el).transform!);\n}\nexport function calculateMatrixDist(matrix: number[], pos: number[]) {\n    const res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);\n    const w = res[3] || 1;\n\n    return [\n        res[0] / w,\n        res[1] / w,\n        res[2] / w,\n    ];\n}\nexport function getDistElementMatrix(el: HTMLElement, container = document.body): number[] {\n    let target: HTMLElement | null = el;\n    let matrix = createMatrix();\n\n    while (target) {\n        const transform = getComputedStyle(target).transform!;\n        matrix = matrix3d(parseMat(transform), matrix);\n\n        if (target === container) {\n            break;\n        }\n        target = target.parentElement;\n    }\n    matrix = invert(matrix, 4);\n\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n\n    return matrix;\n}\n\nexport function toMat(matrixInfos: MatrixInfo[]): number[] {\n    let target = createMatrix();\n\n    matrixInfos.forEach(info => {\n        const {\n            matrixFunction,\n            functionValue,\n        } = info;\n\n        if (!matrixFunction) {\n            return;\n        }\n        target = matrixFunction(target, functionValue);\n    });\n    return target;\n}\nexport function parse(transform: string | string[]): MatrixInfo[] {\n    const transforms = isArray(transform) ? transform : splitSpace(transform);\n\n    return transforms.map(t => {\n        const { prefix: name, value } = splitBracket(t);\n\n\n        let matrixFunction = null;\n        let functionName: string = name;\n        let functionValue: any = \"\";\n\n        if (name === \"translate\" || name === \"translateX\" || name === \"translate3d\") {\n            const [posX, posY = 0, posZ = 0] = splitComma(value!).map(v => parseFloat(v));\n\n            matrixFunction = translate3d;\n            functionValue = [posX, posY, posZ];\n        } else if (name === \"translateY\") {\n            const posY = parseFloat(value!);\n\n            matrixFunction = translate3d;\n            functionValue = [0, posY, 0];\n        } else if (name === \"translateZ\") {\n            const posZ = parseFloat(value!);\n\n            matrixFunction = translate3d;\n            functionValue = [0, 0, posZ];\n        } else if (name === \"scale\" || name === \"scale3d\") {\n            const [sx, sy = sx, sz = 1] = splitComma(value!).map(v => parseFloat(v)) as number[];\n\n            matrixFunction = scale3d;\n            functionValue = [sx, sy, sz];\n        } else if (name === \"scaleX\") {\n            const sx = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [sx, 1, 1];\n        } else if (name === \"scaleY\") {\n            const sy = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [1, sy, 1];\n        } else if (name === \"scaleZ\") {\n            const sz = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [1, 1, sz];\n        } else if (name === \"rotate\" || name === \"rotateZ\" || name === \"rotateX\" || name === \"rotateY\") {\n            const { unit, value: unitValue } = splitUnit(value!);\n            const rad = unit === \"rad\" ? unitValue : unitValue * Math.PI / 180;\n\n            if (name === \"rotate\" || name === \"rotateZ\") {\n                functionName = \"rotateZ\";\n                matrixFunction = rotateZ3d;\n            } else if (name === \"rotateX\") {\n                matrixFunction = rotateX3d;\n            } else if (name === \"rotateY\") {\n                matrixFunction = rotateY3d;\n            }\n            functionValue = rad;\n        } else if (name === \"matrix3d\") {\n            matrixFunction = matrix3d;\n            functionValue = splitComma(value!).map(v => parseFloat(v));\n        } else if (name === \"matrix\") {\n            const m = splitComma(value!).map(v => parseFloat(v));\n            matrixFunction = matrix3d;\n            functionValue = [\n                m[0], m[1], 0, 0,\n                m[2], m[3], 0, 0,\n                0, 0, 1, 0,\n                m[4], m[5], 0, 1,\n            ];\n        } else {\n            functionName = \"\";\n        }\n        return {\n            name: name!,\n            functionName,\n            value: value!,\n            matrixFunction,\n            functionValue,\n        };\n    });\n}\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport default class PolyMap<T> {\n  private keys: T[] = [];\n  private values: number[] = [];\n  public get(key: T): number {\n    return this.values[this.keys.indexOf(key)];\n  }\n  public set(key: T, value: number) {\n    const keys = this.keys;\n    const values = this.values;\n    const prevIndex = keys.indexOf(key);\n    const index = prevIndex === -1 ? keys.length : prevIndex;\n\n    keys[index] = key;\n    values[index] = value;\n  }\n}\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport default class HashMap<T> {\n  private object = {};\n  public get(key: number | string): T {\n    return this.object[key];\n  }\n  public set(key: number | string, value: T) {\n    this.object[key] = value;\n  }\n};\n\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport const SUPPORT_MAP = typeof Map === \"function\";\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport default class Link {\n  prev?: Link;\n  next?: Link;\n\n  public connect(prevLink?: Link, nextLink?: Link) {\n    this.prev = prevLink;\n    this.next = nextLink;\n\n    prevLink && (prevLink.next = this);\n    nextLink && (nextLink.prev = this);\n  }\n  public disconnect() {\n    // In double linked list, diconnect the interconnected relationship.\n    const prevLink = this.prev;\n    const nextLink = this.next;\n    prevLink && (prevLink.next = nextLink);\n    nextLink && (nextLink.prev = prevLink);\n  }\n  public getIndex() {\n    let link: Link | undefined = this;\n    let index = -1;\n\n    while (link) {\n      link = link.prev;\n      ++index;\n    }\n    return index;\n  }\n}\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport Link from \"./Link\";\n\nfunction orderChanged(changed: number[][], fixed: boolean[]) {\n  // It is roughly in the order of these examples.\n  // 4, 6, 0, 2, 1, 3, 5, 7\n  const fromLinks: Link[] = [];\n  // 0, 1, 2, 3, 4, 5, 6, 7\n  const toLinks: Link[] = [];\n\n  changed.forEach(([from, to]) => {\n    const link = new Link();\n\n    fromLinks[from] = link;\n    toLinks[to] = link;\n  });\n  // `fromLinks` are connected to each other by double linked list.\n  fromLinks.forEach((link, i) => {\n    link.connect(fromLinks[i - 1]);\n  });\n\n  return changed.filter((_, i) => !fixed[i]).map(([from, to], i) => {\n    if (from === to) {\n      return [0, 0];\n    }\n    const fromLink = fromLinks[from];\n    const toLink = toLinks[to - 1];\n    const fromIndex = fromLink.getIndex();\n\n    // Disconnect the link connected to `fromLink`.\n    fromLink.disconnect();\n\n    // Connect `fromLink` to the right of `toLink`.\n    if (!toLink) {\n      fromLink.connect(undefined, fromLinks[0]);\n    } else {\n      fromLink.connect(toLink, toLink.next);\n    }\n    const toIndex = fromLink.getIndex();\n    return [fromIndex, toIndex];\n  });\n}\n\nexport default class Result<T = any> {\n  public prevList: T[];\n  public list: T[];\n  public added: number[];\n  public removed: number[];\n  public changed: number[][];\n  public maintained: number[][];\n  private changedBeforeAdded: number[][];\n  private fixed: boolean[];\n\n  private cacheOrdered: number[][];\n  private cachePureChanged: number[][];\n  constructor(\n    prevList: T[],\n    list: T[],\n    added: number[],\n    removed: number[],\n    changed: number[][],\n    maintained: number[][],\n    changedBeforeAdded: number[][],\n    fixed: boolean[],\n  ) {\n    this.prevList = prevList;\n    this.list = list;\n    this.added = added;\n    this.removed = removed;\n    this.changed = changed;\n    this.maintained = maintained;\n    this.changedBeforeAdded = changedBeforeAdded;\n    this.fixed = fixed;\n  }\n  get ordered(): number[][] {\n    if (!this.cacheOrdered) {\n      this.caculateOrdered();\n    }\n    return this.cacheOrdered;\n  }\n  get pureChanged(): number[][] {\n    if (!this.cachePureChanged) {\n      this.caculateOrdered();\n    }\n    return this.cachePureChanged;\n  }\n  private caculateOrdered() {\n    const ordered = orderChanged(this.changedBeforeAdded, this.fixed);\n    const changed: number[][] = this.changed;\n    const pureChanged: number[][] = [];\n\n    this.cacheOrdered = ordered.filter(([from, to], i) => {\n      const [fromBefore, toBefore] = changed[i];\n\n      if (from !== to) {\n        pureChanged.push([fromBefore, toBefore]);\n        return true;\n      }\n    });\n    this.cachePureChanged = pureChanged;\n  }\n}\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport { MapInteface, DiffResult } from \"./types\";\nimport PolyMap from \"./PolyMap\";\nimport HashMap from \"./HashMap\";\nimport { SUPPORT_MAP } from \"./consts\";\nimport Result from \"./Result\";\n\n/**\n *\n * @memberof eg.ListDiffer\n * @static\n * @function\n * @param - Previous List <ko>   </ko>\n * @param - List to Update <ko>    </ko>\n * @param - This callback function returns the key of the item. <ko>     .</ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>\n * @example\n * import { diff } from \"@egjs/list-differ\";\n * // script => eg.ListDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\nexport function diff<T>(\n  prevList: T[],\n  list: T[],\n  findKeyCallback?: (e: T, i: number, arr: T[]) => any\n): DiffResult<T> {\n  const mapClass: new () => MapInteface<any, number> = SUPPORT_MAP ? Map : (findKeyCallback ? HashMap : PolyMap);\n  const callback = findKeyCallback || ((e: T) => e);\n  const added: number[] = [];\n  const removed: number[] = [];\n  const maintained: number[][] = [];\n  const prevKeys = prevList.map(callback);\n  const keys = list.map(callback);\n  const prevKeyMap: MapInteface<any, number> = new mapClass();\n  const keyMap: MapInteface<any, number> = new mapClass();\n  const changedBeforeAdded: number[][] = [];\n  const fixed: boolean[] = [];\n  const removedMap: object = {};\n  let changed: number[][] = [];\n  let addedCount = 0;\n  let removedCount = 0;\n\n  // Add prevKeys and keys to the hashmap.\n  prevKeys.forEach((key, prevListIndex) => {\n    prevKeyMap.set(key, prevListIndex);\n  });\n  keys.forEach((key, listIndex) => {\n    keyMap.set(key, listIndex);\n  });\n\n  // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.\n  prevKeys.forEach((key, prevListIndex) => {\n    const listIndex = keyMap.get(key);\n\n    // In prevList, but not in list, it is removed.\n    if (typeof listIndex === \"undefined\") {\n      ++removedCount;\n      removed.push(prevListIndex);\n    } else {\n      removedMap[listIndex] = removedCount;\n    }\n  });\n\n  // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.\n  keys.forEach((key, listIndex) => {\n    const prevListIndex = prevKeyMap.get(key);\n\n    // In list, but not in prevList, it is added.\n    if (typeof prevListIndex === \"undefined\") {\n      added.push(listIndex);\n      ++addedCount;\n    } else {\n      maintained.push([prevListIndex, listIndex]);\n      removedCount = removedMap[listIndex] || 0;\n\n      changedBeforeAdded.push([\n        prevListIndex - removedCount,\n        listIndex - addedCount,\n      ]);\n      fixed.push(listIndex === prevListIndex);\n      if (prevListIndex !== listIndex) {\n        changed.push([prevListIndex, listIndex]);\n      }\n    }\n  });\n  // Sort by ascending order of 'to(list's index).\n  removed.reverse();\n\n  return new Result(\n    prevList,\n    list,\n    added,\n    removed,\n    changed,\n    maintained,\n    changedBeforeAdded,\n    fixed,\n  );\n}\n","/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport { DiffResult, ListFormat } from \"./types\";\nimport { diff } from \"./utils\";\n\n/**\n * A module that checks diff when values are added, removed, or changed in an array.\n * @ko          .\n * @memberof eg\n */\nclass ListDiffer<T> {\n  private list: T[];\n  /**\n   * @param - Initializing Data Array. <ko>    .</ko>\n   * @param - This callback function returns the key of the item. <ko>     .</ko>\n   * @example\n   * import ListDiffer from \"@egjs/list-differ\";\n   * // script => eg.ListDiffer\n   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);\n   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);\n   * // List before update\n   * // [1, 2, 3, 4, 5]\n   * console.log(result.prevList);\n   * // Updated list\n   * // [4, 3, 6, 2, 1]\n   * console.log(result.list);\n   * // Index array of values added to `list`.\n   * // [0, 1, 5]\n   * console.log(result.added);\n   * // Index array of values removed in `prevList`.\n   * // [5]\n   * console.log(result.removed);\n   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.changed);\n   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n   * // [[4, 3], [3, 4], [2, 6]]\n   * console.log(result.pureChanged);\n   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n   * // [[4, 1], [4, 2], [4, 3]]\n   * console.log(result.ordered);\n   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.maintained);\n   */\n  constructor(\n    list: ListFormat<T> = [],\n    private findKeyCallback?: (e: T, i: number, arr: T[]) => number | string,\n  ) {\n    this.list = [].slice.call(list);\n  }\n  /**\n   * Update list.\n   * @ko   .\n   * @param - List to update <ko>   </ko>\n   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList` `list`   . </ko>\n   */\n  public update(list: ListFormat<T>): DiffResult<T> {\n    const newData: T[] = [].slice.call(list);\n    const result = diff<T>(this.list, newData, this.findKeyCallback);\n\n    this.list = newData;\n    return result;\n  }\n}\n\nexport default ListDiffer;\n","/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport const findKeyCallback = typeof Map === \"function\"\n  ? undefined\n  : (() => {\n    let childrenCount = 0;\n\n    return (el: Element) => (el as any).__DIFF_KEY__ || ((el as any).__DIFF_KEY__ = ++childrenCount);\n  })();\n","/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport ListDiffer, { ListFormat } from \"@egjs/list-differ\";\nimport { findKeyCallback } from \"./consts\";\n\n/**\n * A module that checks diff when child are added, removed, or changed .\n * @ko           .\n * @memberof eg\n * @extends eg.ListDiffer\n */\nclass ChildrenDiffer<T extends Element = Element> extends ListDiffer<T> {\n  /**\n   * @param - Initializing Children <ko>    </ko>\n   */\n  constructor(\n    list: ListFormat<T> = [],\n  ) {\n    super(list, findKeyCallback);\n  }\n}\nexport default ChildrenDiffer;\n","import { throttle, TINY_NUM } from \"@daybrush/utils\";\n\nexport function tinyThrottle(num: number) {\n    return throttle(num, TINY_NUM);\n}\n\nexport function isSameConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n) {\n    return linearConstants1.every((v, i) => tinyThrottle(v - linearConstants2[i]) === 0);\n}\n\nexport function isSamePoint(\n    point1: number[],\n    point2: number[],\n) {\n    return !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1]);\n}\n\nexport function flat<Type extends any>(arr: Type[][]): Type[] {\n    return arr.reduce<Type[]>((prev, current) => {\n        prev.push(...current);\n        return prev;\n    }, []);\n}\n","import { sum, findIndex, getShapeDirection, getDist, throttle, TINY_NUM, find } from \"@daybrush/utils\";\nimport { OverlapPointInfo, PointInfo, Rect } from \"./types\";\nimport { flat, isSameConstants, isSamePoint, tinyThrottle } from \"./utils\";\n\n/**\n * @namespace OverlapArea\n */\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\nexport function getAreaSize(points: number[][]): number {\n    if (points.length < 3) {\n        return 0;\n    }\n    return Math.abs(sum(points.map((point, i) => {\n        const nextPoint = points[i + 1] || points[0];\n\n        return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n    }))) / 2;\n}\n\n\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\nexport function fitPoints(points: number[][], rect: Rect): number[][] {\n    const { width, height, left, top } = rect;\n    const { minX, minY, maxX, maxY } = getMinMaxs(points);\n    const ratioX = width / (maxX - minX);\n    const ratioY = height / (maxY - minY);\n\n    return points.map(point => {\n        return [\n            left + (point[0] - minX) * ratioX,\n            top + (point[1] - minY) * ratioY,\n        ];\n    });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\nexport function getMinMaxs(points: number[][]): { minX: number, minY: number, maxX: number, maxY: number } {\n    const xs = points.map(point => point[0]);\n    const ys = points.map(point => point[1]);\n\n    return {\n        minX: Math.min(...xs),\n        minY: Math.min(...ys),\n        maxX: Math.max(...xs),\n        maxY: Math.max(...ys),\n    };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\nexport function isInside(pos: number[], points: number[][], excludeLine?: boolean): boolean {\n    const [x, y] = pos;\n    const {\n        minX,\n        maxX,\n    } = getMinMaxs(points);\n\n    const xLine = [[minX, y], [maxX, y]];\n    const xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n    const lines = convertLines(points);\n\n    interface IntersectionPosInfo {\n        pos: number[];\n        line: number[][];\n        type: \"intersection\" | \"point\" | \"line\";\n    }\n    const intersectionPosInfos: IntersectionPosInfo[] = [];\n\n    lines.forEach(line => {\n        const linearConstants = getLinearConstants(line[0], line[1]);\n        const standardPoint = line[0];\n\n        if (isSameConstants(xLinearConstants, linearConstants)) {\n            intersectionPosInfos.push({\n                pos: pos,\n                line,\n                type: \"line\",\n            });\n        } else {\n            const xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n\n            xPoints.forEach(point => {\n                if (line.some(linePoint => isSamePoint(linePoint, point))) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line,\n                        type: \"point\",\n                    });\n                } else if (tinyThrottle(standardPoint[1] - y) !== 0) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line,\n                        type: \"intersection\",\n                    });\n                }\n            })\n        }\n    });\n\n    if (!excludeLine) {\n        // on line\n        if (find(intersectionPosInfos, p => p[0] === x)) {\n            return true;\n        }\n    }\n    let intersectionCount = 0;\n    const xMap = {};\n\n    intersectionPosInfos.forEach(({ pos, type, line }) => {\n        if (pos[0] > x) {\n            return;\n        }\n        if (type === \"intersection\") {\n            ++intersectionCount;\n        } else if (type === \"line\") {\n            return;\n        } else if (type === \"point\") {\n            const point = find(line, linePoint => linePoint[1] !== y);\n            const prevValue = xMap[pos[0]];\n            const nextValue = point[1] > y ? 1 : -1;\n\n            if (!prevValue) {\n                xMap[pos[0]] = nextValue;\n            } else if (prevValue !== nextValue) {\n                ++intersectionCount;\n            }\n        }\n    });\n    return intersectionCount % 2 === 1;\n}\n/**\n * Get distance from point to constants. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getDistanceFromPointToConstants(\n    [a, b, c]: [number, number, number],\n    pos: number[],\n) {\n    return (a * pos[0] + b * pos[1] + c) / (a * a + b * b);\n}\n\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getLinearConstants(point1: number[], point2: number[]): [number, number, number] {\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    // ax + by + c = 0\n    // [a, b, c]\n    let dx = x2 - x1;\n    let dy = y2 - y1;\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n\n    // b > 0\n    // ax + by + c = 0\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    if (!dx) {\n        if (dy) {\n            // -x + 1 = 0\n            a = -1;\n            c = x1;\n        }\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -y1;\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = -a * x1 - y1;\n    }\n\n    return [a, b, c] as [number, number, number];\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\nexport function getIntersectionPointsByConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n): number[][] {\n    const [a1, b1, c1] = linearConstants1;\n    const [a2, b2, c2] = linearConstants2;\n\n    const isZeroA = a1 === 0 && a2 === 0;\n    const isZeroB = b1 === 0 && b2 === 0;\n    let results: number[][] = [];\n\n    if (isZeroA && isZeroB) {\n        return [];\n    } else if (isZeroA) {\n        // b1 * y + c1 = 0\n        // b2 * y + c2 = 0\n        const y1 = -c1 / b1;\n        const y2 = -c2 / b2;\n\n        if (y1 !== y2) {\n            return [];\n        } else {\n            return [\n                [-Infinity, y1],\n                [Infinity, y1],\n            ];\n        }\n    } else if (isZeroB) {\n        // a1 * x + c1 = 0\n        // a2 * x + c2 = 0\n        const x1 = -c1 / a1;\n        const x2 = -c2 / a2;\n\n        if (x1 !== x2) {\n            return [];\n        } else {\n            return [\n                [x1, -Infinity],\n                [x1, Infinity],\n            ];\n        }\n    } else if (a1 === 0) {\n        // b1 * y + c1 = 0\n        // y = - c1 / b1;\n        // a2 * x + b2 * y + c2 = 0\n        const y = -c1 / b1;\n        const x = -(b2 * y + c2) / a2;\n\n        results = [[x, y]];\n    } else if (a2 === 0) {\n        // b2 * y + c2 = 0\n        // y = - c2 / b2;\n        // a1 * x + b1 * y + c1 = 0\n        const y = -c2 / b2;\n        const x = -(b1 * y + c1) / a1;\n\n        results = [[x, y]];\n    } else if (b1 === 0) {\n        // a1 * x + c1 = 0\n        // x = - c1 / a1;\n        // a2 * x + b2 * y + c2 = 0\n        const x = - c1 / a1;\n        const y = -(a2 * x + c2) / b2;\n\n        results = [[x, y]];\n    } else if (b2 === 0) {\n        // a2 * x + c2 = 0\n        // x = - c2 / a2;\n        // a1 * x + b1 * y + c1 = 0\n        const x = - c2 / a2;\n        const y = -(a1 * x + c1) / b1;\n\n        results = [[x, y]];\n    } else {\n        // a1 * x + b1 * y + c1 = 0\n        // a2 * x + b2 * y + c2 = 0\n        // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n        // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n        // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n        const x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n        const y = -(a1 * x + c1) / b1;\n\n        results = [[x, y]];\n    }\n\n    return results.map(result => [result[0], result[1]]);\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */\nexport function getIntersectionPoints(\n    line1: number[][],\n    line2: number[][],\n    isLimit?: boolean,\n): number[][] {\n    const points = getIntersectionPointsByConstants(\n        getLinearConstants(line1[0], line1[1]),\n        getLinearConstants(line2[0], line2[1]),\n    );\n\n    if (isLimit) {\n        return getPointsOnLines(points, [line1, line2]);\n    }\n    return points;\n}\n\nexport function isPointOnLine(\n    pos: number[],\n    line: number[][],\n) {\n    const linearConstants = getLinearConstants(line[0], line[1]);\n\n    return tinyThrottle(getDistanceFromPointToConstants(linearConstants, pos)) === 0;\n}\n\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\nexport function getPointsOnLines(\n    points: number[][],\n    lines: number[][][],\n): number[][] {\n    const minMaxs = lines.map(line => [0, 1].map(order => [\n        Math.min(line[0][order], line[1][order]),\n        Math.max(line[0][order], line[1][order]),\n    ]));\n    let results: number[][] = [];\n\n    if (points.length === 2) {\n        const [x, y] = points[0];\n        if (!tinyThrottle(x - points[1][0])) {\n            /// Math.max(minY1, minY2)\n            const top = Math.max(...minMaxs.map(minMax => minMax[1][0]));\n            /// Math.min(maxY1, miax2)\n            const bottom = Math.min(...minMaxs.map(minMax => minMax[1][1]));\n\n            if (tinyThrottle(top - bottom) > 0) {\n                return [];\n            }\n            results = [\n                [x, top],\n                [x, bottom],\n            ];\n        } else if (!tinyThrottle(y - points[1][1])) {\n            /// Math.max(minY1, minY2)\n            const left = Math.max(...minMaxs.map(minMax => minMax[0][0]));\n            /// Math.min(maxY1, miax2)\n            const right = Math.min(...minMaxs.map(minMax => minMax[0][1]));\n\n            if (tinyThrottle(left - right) > 0) {\n                return [];\n            }\n            results = [\n                [left, y],\n                [right, y],\n            ];\n        }\n    }\n\n    if (!results.length) {\n        results = points.filter(point => {\n            const [pointX, pointY] = point;\n\n            return minMaxs.every(minMax => {\n                return (0 <= tinyThrottle(pointX - minMax[0][0]) && 0 <= tinyThrottle(minMax[0][1] - pointX))\n                && (0 <= tinyThrottle(pointY - minMax[1][0]) && 0 <= tinyThrottle(minMax[1][1] - pointY));\n            });\n        });\n    }\n\n    return results.map(result => [tinyThrottle(result[0]), tinyThrottle(result[1])]);\n\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/\nexport function convertLines(points: number[][]): number[][][] {\n    return [...points.slice(1), points[0]].map((point, i) => [points[i], point]);\n}\n\nfunction getOverlapPointInfos(points1: number[][], points2: number[][]): OverlapPointInfo[] {\n    const targetPoints1 = points1.slice();\n    const targetPoints2 = points2.slice();\n\n    if (getShapeDirection(targetPoints1) === -1) {\n        targetPoints1.reverse();\n    }\n    if (getShapeDirection(targetPoints2) === -1) {\n        targetPoints2.reverse();\n    }\n    const lines1 = convertLines(targetPoints1);\n    const lines2 = convertLines(targetPoints2);\n    const linearConstantsList1 = lines1.map(line1 => getLinearConstants(line1[0], line1[1]));\n    const linearConstantsList2 = lines2.map(line2 => getLinearConstants(line2[0], line2[1]));\n\n    const overlapInfos: OverlapPointInfo[] = [];\n\n    linearConstantsList1.forEach((linearConstants1, i) => {\n        const line1 = lines1[i];\n        const linePointInfos: OverlapPointInfo[] = [];\n        linearConstantsList2.forEach((linearConstants2, j) => {\n            const intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n            const points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n\n            linePointInfos.push(...points.map(pos => ({\n                index1: i,\n                index2: j,\n                pos,\n                type: \"intersection\" as const,\n            })));\n        });\n        linePointInfos.sort((a, b) => {\n            return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n        });\n\n        overlapInfos.push(...linePointInfos);\n\n        if (isInside(line1[1], targetPoints2)) {\n            overlapInfos.push({\n                index1: i,\n                index2: -1,\n                pos: line1[1],\n                type: \"inside\" as const,\n            });\n        }\n    });\n\n    lines2.forEach((line2, i) => {\n        if (!isInside(line2[1], targetPoints1)) {\n            return;\n        }\n        let isNext = false;\n        let index = findIndex(overlapInfos, ({ index2 }) => {\n            if (index2 === i) {\n                isNext = true;\n                return false;\n            }\n\n            if (isNext) {\n                return true;\n            }\n            return false;\n        });\n        if (index === -1) {\n            isNext = false;\n            index = findIndex(overlapInfos, ({ index1, index2 }) => {\n                if (index1 === -1 && index2 + 1 === i) {\n                    isNext = true;\n                    return false;\n                }\n\n                if (isNext) {\n                    return true;\n                }\n                return false;\n            });\n        }\n        if (index === -1) {\n            overlapInfos.push({\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\" as const,\n            });\n        } else {\n            overlapInfos.splice(index, 0, {\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\" as const,\n            });\n\n        }\n    });\n    const pointMap: Record<string, boolean> = {};\n\n    return overlapInfos.filter(({ pos }) => {\n        const key = `${pos[0]}x${pos[1]}`;\n\n        if (pointMap[key]) {\n            return false;\n        }\n        pointMap[key] = true;\n        return true;\n    });\n}\n\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapPoints(points1: number[][], points2: number[][]): number[][] {\n    const infos = getOverlapPointInfos(points1, points2);\n\n    return infos.map(({ pos }) => pos);\n}\n\nfunction isConnectedLine(line: OverlapPointInfo[]) {\n    const {\n        0: {\n            index1: prevIndex1,\n            index2: prevIndex2,\n        },\n        1: {\n            index1: nextIndex1,\n            index2: nextIndex2,\n        }\n    } = line;\n\n    if (prevIndex1 !== -1) {\n        // same line\n        if (prevIndex1 === nextIndex1) {\n            return true;\n        }\n        if (prevIndex1 + 1 === nextIndex1) {\n            return true;\n        }\n    }\n    if (prevIndex2 !== -1) {\n        // same line\n        if (prevIndex2 === nextIndex2) {\n            return true;\n        }\n        if (prevIndex2 + 1 === nextIndex2) {\n            return true;\n        }\n    }\n\n    return false;\n\n}\n/**\n* Get the areas of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapAreas(points1: number[][], points2: number[][]): number[][][] {\n    const infos = getOverlapPointInfos(points1, points2);\n    const areas: OverlapPointInfo[][] = [];\n    let area: OverlapPointInfo[];\n\n    getOverlapPointInfos(points1, points2).forEach((info, i, arr) => {\n        if (i === 0 || !isConnectedLine([arr[i - 1], info])) {\n            area = [info];\n            areas.push(area);\n        } else {\n            area.push(info);\n        }\n    });\n\n    return areas.map(area => area.map(({ pos }) => pos));\n}\nfunction findReversedAreas(points1: number[][], points2: number[][], index: number = 0, areas: number[][][] = []): number[][][] {\n    const isFirst = areas.length === 0;\n    const length = points1.length;\n    const nextIndex = points1[index] ? index : 0;\n    const nextPoints1 = [...points1.slice(nextIndex), ...points1.slice(0, nextIndex)];\n\n    for (let i = 0; i < length; ++i) {\n        const point1 = nextPoints1[i];\n\n        if (find(points2, point2 => point2[0] === point1[0] && point2[1] === point1[1])) {\n            continue;\n        }\n        if (areas.some(nextArea => find(nextArea, areaPoint => areaPoint[0] === point1[0] && areaPoint[1] === point1[1]))) {\n            if (isFirst) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        let nextArea: number[][];\n\n        if (isFirst) {\n            nextArea = [];\n            areas.push(nextArea);\n        } else {\n            nextArea = areas[areas.length - 1];\n        }\n        nextArea.push(point1);\n\n\n        const line = [point1, points1[index + 1] || points1[0]];\n        const nextPoint2 = points2.filter(point2 => {\n            return isPointOnLine(point2, line);\n        }).sort((a, b) => {\n            return getDist(point1, a) - getDist(point1, b);\n        })[0];\n\n        if (!nextPoint2) {\n            findReversedAreas(nextPoints1, points2, i + 1, areas);\n            break;\n        } else {\n            const point2Index = points2.indexOf(nextPoint2);\n\n            findReversedAreas(points2, points1, point2Index, areas);\n            if (!isFirst) {\n                break;\n            }\n        }\n    }\n    return areas;\n}\nexport function findConnectedAreas(points1: number[][], points2: number[][]) {\n    return findReversedAreas(points1, [...points2].reverse());\n}\n/**\n* Get non-overlapping areas of two shapes based on points1.\n* @memberof OverlapArea\n*/\nexport function getUnoverlapAreas(points1: number[][], points2: number[][]): number[][][] {\n    if (!points2.length) {\n        return [[...points1]];\n    }\n    const overlapAreas = getOverlapAreas(points1, points2);\n     let unoverlapAreas = [points1];\n\n    overlapAreas.forEach(overlapArea => {\n        const nextOverlapArea = [...overlapArea].reverse();\n\n        unoverlapAreas = flat(unoverlapAreas.map(area => {\n            const connectedAreas = findReversedAreas(area, nextOverlapArea);\n            const firstConnectedArea = connectedAreas[0];\n\n            if (connectedAreas.length === 1 && nextOverlapArea.every(point => firstConnectedArea.indexOf(point) === -1)) {\n                const lastPoint = firstConnectedArea[firstConnectedArea.length - 1];\n                const firstPoint = [...nextOverlapArea].sort((a, b) => {\n                    return getDist(lastPoint, a) - getDist(lastPoint, b);\n                })[0];\n                const firstIndex = nextOverlapArea.indexOf(firstPoint);\n\n                firstConnectedArea.push(\n                    ...nextOverlapArea.slice(firstIndex),\n                    ...nextOverlapArea.slice(0, firstIndex),\n                    nextOverlapArea[firstIndex],\n                    lastPoint,\n                );\n            }\n            return connectedAreas;\n        }));\n    });\n\n    return unoverlapAreas;\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapSize(points1: number[][], points2: number[][]): number {\n    const points = getOverlapPoints(points1, points2);\n\n    return getAreaSize(points);\n}\n","import { findIndex, isObject } from \"@daybrush/utils\";\nimport { EventListener, EventHash, EventInfo, EventOptions, OnEvent, TargetParam } from \"./types\";\n\n/**\n * Implement EventEmitter on object or component.\n */\nclass EventEmitter<Events extends {} = { [key: string]: { [key: string]: any } }> {\n\n    private _events: {\n        [name: string]: EventInfo[],\n    } = {};\n    public on<Name extends keyof Events, Param = Events[Name]>(\n        eventName: Name, listener: EventListener<Param, this>): this;\n    public on(events: EventHash<Events, this>): this;\n    /**\n     * Add a listener to the registered event.\n     * @param - Name of the event to be added\n     * @param - listener function of the event to be added\n     * @example\n     * import EventEmitter from \"@scena/event-emitter\";\n     * cosnt emitter = new EventEmitter();\n     *\n     * // Add listener in \"a\" event\n     * emitter.on(\"a\", () => {\n     * });\n     * // Add listeners\n     * emitter.on({\n     *  a: () => {},\n     *  b: () => {},\n     * });\n     */\n    public on(eventName: string | object, listener?: EventListener<Events[any], this>): this {\n        if (isObject(eventName)) {\n            for (const name in eventName) {\n                this.on<any>(name, eventName[name]);\n            }\n        } else {\n            this._addEvent(eventName, listener, {});\n        }\n        return this;\n    }\n    public off<Name extends keyof Events, Param = Events[Name]>(\n        eventName?: Name, listener?: EventListener<Param, this>): this;\n    public off(events: EventHash<Events, this>): this;\n    /**\n     * Remove listeners registered in the event target.\n     * @param - Name of the event to be removed\n     * @param - listener function of the event to be removed\n     * @example\n     * import EventEmitter from \"@scena/event-emitter\";\n     * cosnt emitter = new EventEmitter();\n     *\n     * // Remove all listeners.\n     * emitter.off();\n     *\n     * // Remove all listeners in \"A\" event.\n     * emitter.off(\"a\");\n     *\n     *\n     * // Remove \"listener\" listener in \"a\" event.\n     * emitter.off(\"a\", listener);\n     */\n    public off(eventName?: string | object, listener?: EventListener<Events[any], this>): this {\n        if (!eventName) {\n            this._events = {};\n        } else if(isObject(eventName)) {\n            for (const name in eventName) {\n                this.off<any>(name);\n            }\n        } else if (!listener) {\n            this._events[eventName] = [];\n        } else {\n            const events = this._events[eventName];\n\n            if (events) {\n                const index = findIndex(events, e => e.listener === listener);\n\n                if (index > -1) {\n                    events.splice(index, 1);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Add a disposable listener and Use promise to the registered event.\n     * @param - Name of the event to be added\n     * @param - disposable listener function of the event to be added\n     * @example\n     * import EventEmitter from \"@scena/event-emitter\";\n     * cosnt emitter = new EventEmitter();\n     *\n     * // Add a disposable listener in \"a\" event\n     * emitter.once(\"a\", () => {\n     * });\n     *\n     * // Use Promise\n     * emitter.once(\"a\").then(e => {\n     * });\n     */\n    public once<Name extends keyof Events & string, Param = Events[Name]>(\n        eventName: Name, listener?: EventListener<Param, this>): Promise<OnEvent<Param, this>> {\n        if (listener) {\n            this._addEvent(eventName, listener, { once: true });\n        }\n        return new Promise<OnEvent<Param, this>>(resolve => {\n            this._addEvent(eventName, resolve, { once: true });\n        });\n    }\n    public emit<Name extends keyof Events, Param = Events[Name]>(\n        eventName: {} extends Param ? Name : never): boolean;\n    public emit<Name extends keyof Events, Param = Events[Name]>(\n        eventName: Name, param: TargetParam<Param>): boolean;\n    /**\n     * Fires an event to call listeners.\n     * @param - Event name\n     * @param - Event parameter\n     * @return If false, stop the event.\n     * @example\n     *\n     * import EventEmitter from \"@scena/event-emitter\";\n     *\n     *\n     * const emitter = new EventEmitter();\n     *\n     * emitter.on(\"a\", e => {\n     * });\n     *\n     *\n     * emitter.emit(\"a\", {\n     *   a: 1,\n     * });\n     */\n    public emit(eventName: string, param: TargetParam<any> = {}): boolean {\n        const events = this._events[eventName];\n\n        if (!eventName || !events) {\n            return true;\n        }\n        let isStop = false;\n\n        param.eventType = eventName;\n        param.stop = () => {\n            isStop = true;\n        };\n        param.currentTarget = this;\n\n\n        [...events].forEach(info => {\n            info.listener(param);\n            if (info.once) {\n                this.off<any>(eventName, info.listener);\n            }\n        });\n\n        return !isStop;\n    }\n    public trigger<Name extends keyof Events, Param = Events[Name]>(eventName: {} extends TargetParam<Param> ? Name : never): boolean;\n    public trigger<Name extends keyof Events, Param = Events[Name]>(eventName: Name, param: TargetParam<Param>): boolean;\n    /**\n     * Fires an event to call listeners.\n     * @param - Event name\n     * @param - Event parameter\n     * @return If false, stop the event.\n     * @example\n     *\n     * import EventEmitter from \"@scena/event-emitter\";\n     *\n     *\n     * const emitter = new EventEmitter();\n     *\n     * emitter.on(\"a\", e => {\n     * });\n     *\n     *\n     * emitter.emit(\"a\", {\n     *   a: 1,\n     * });\n     *//**\n     * Fires an event to call listeners.\n     * @param - Event name\n     * @param - Event parameter\n     * @return If false, stop the event.\n     * @example\n     *\n     * import EventEmitter from \"@scena/event-emitter\";\n     *\n     *\n     * const emitter = new EventEmitter();\n     *\n     * emitter.on(\"a\", e => {\n     * });\n     *\n     * // emit\n     * emitter.trigger(\"a\", {\n     *   a: 1,\n     * });\n     */\n    public trigger<Name extends keyof Events>(eventName: Name, param: TargetParam<any>= {}): boolean {\n        return this.emit<any>(eventName, param);\n    }\n\n    private _addEvent(eventName: string, listener: EventListener<Events[any], this>, options: Partial<EventOptions>) {\n        const events = this._events;\n\n        events[eventName] = events[eventName] || [];\n\n        const listeners = events[eventName];\n\n        listeners.push({ listener, ...options });\n    }\n}\n\nexport default EventEmitter;\n","import EventEmitter from \"@scena/event-emitter\";\nimport { isFunction, isString, now } from \"@daybrush/utils\";\nimport { CheckScrollOptions, DragScrollEvents, DragScrollOptions, Rect } from \"./types\";\n\nfunction getDefaultScrollPosition(e: { container: HTMLElement, direction: number[] }) {\n    let container = e.container;\n\n    if (container === document.body) {\n        return [\n            container.scrollLeft || document.documentElement.scrollLeft,\n            container.scrollTop || document.documentElement.scrollTop,\n        ];\n    }\n    return [\n        container.scrollLeft,\n        container.scrollTop,\n    ];\n}\n\nfunction checkDefaultScrollEvent(container: HTMLElement | Window, callback: () => void) {\n    container.addEventListener(\"scroll\", callback);\n\n    return () => {\n        container.removeEventListener(\"scroll\", callback);\n    }\n}\n\nfunction getContainerElement(container: DragScrollOptions[\"container\"]): HTMLElement {\n    if (!container) {\n        return null;\n    } else if (isString(container)) {\n        return document.querySelector<HTMLElement>(container);\n    } if (isFunction(container)) {\n        return container();\n    } else if (container instanceof Element) {\n        return container;\n    } else if (\"current\" in container) {\n        return container.current;\n    } else if (\"value\" in container) {\n        return container.value;\n    }\n}\n\n/**\n * @sort 1\n */\nclass DragScroll extends EventEmitter<DragScrollEvents> {\n    private _startRect: Rect | null = null;\n    private _startPos: number[] = [];\n    private _prevTime: number = 0;\n    private _timer: number = 0;\n    private _prevScrollPos: number[] = [0, 0];\n    private _isWait = false;\n    private _flag = false;\n    private _currentOptions: DragScrollOptions | null = null;\n    private _lock = false;\n    private _unregister: (() => void) | null = null;\n    /**\n     */\n    public dragStart(e: any, options: DragScrollOptions) {\n        const container = getContainerElement(options.container);\n\n        if (!container) {\n            this._flag = false;\n            return;\n        }\n        let top = 0;\n        let left = 0;\n        let width = 0;\n        let height = 0;\n\n        if (container === document.body) {\n            width = window.innerWidth;\n            height = window.innerHeight;\n        } else {\n            const rect = container.getBoundingClientRect();\n\n            top = rect.top;\n            left = rect.left;\n            width = rect.width;\n            height = rect.height;\n        }\n\n        this._flag = true;\n        this._startPos = [e.clientX, e.clientY];\n        this._startRect = { top, left, width, height };\n        this._prevScrollPos = this._getScrollPosition([0, 0], options);\n        this._currentOptions = options;\n        this._registerScrollEvent(options);\n    }\n    public drag(e: any, options: DragScrollOptions) {\n        clearTimeout(this._timer);\n        if (!this._flag) {\n            return;\n        }\n        const {\n            clientX,\n            clientY,\n        } = e;\n        const {\n            threshold = 0,\n        } = options;\n        const {\n            _startRect,\n            _startPos,\n        } = this;\n\n\n        this._currentOptions = options;\n        const direction = [0, 0];\n\n        if (_startRect.top > clientY - threshold) {\n            if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {\n                direction[1] = -1;\n            }\n        } else if (_startRect.top + _startRect.height < clientY + threshold) {\n            if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {\n                direction[1] = 1;\n            }\n        }\n        if (_startRect.left > clientX - threshold) {\n            if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {\n                direction[0] = -1;\n            }\n        } else if (_startRect.left + _startRect.width < clientX + threshold) {\n            if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {\n                direction[0] = 1;\n            }\n        }\n\n        if (!direction[0] && !direction[1]) {\n            return false;\n        }\n        return this._continueDrag({\n            ...options,\n            direction,\n            inputEvent: e,\n            isDrag: true,\n        });\n    }\n    /**\n     */\n    public checkScroll(options: CheckScrollOptions) {\n        if (this._isWait) {\n            return false;\n        }\n        const {\n            prevScrollPos = this._prevScrollPos,\n            direction,\n            throttleTime = 0,\n            inputEvent,\n            isDrag,\n        } = options;\n        const nextScrollPos = this._getScrollPosition(direction || [0, 0], options);\n        const offsetX = nextScrollPos[0] - prevScrollPos[0];\n        const offsetY = nextScrollPos[1] - prevScrollPos[1];\n\n        const nextDirection = direction || [\n            offsetX ? Math.abs(offsetX) / offsetX : 0,\n            offsetY ? Math.abs(offsetY) / offsetY : 0,\n        ];\n        this._prevScrollPos = nextScrollPos;\n        this._lock = false;\n\n        if (!offsetX && !offsetY) {\n            return false;\n        }\n        /**\n         * @event DragScroll#move\n         */\n        this.emit(\"move\", {\n            offsetX: nextDirection[0] ? offsetX : 0,\n            offsetY: nextDirection[1] ? offsetY : 0,\n            inputEvent,\n        });\n\n        if (throttleTime && isDrag) {\n            clearTimeout(this._timer);\n            this._timer = window.setTimeout(() => {\n                this._continueDrag(options);\n            }, throttleTime);\n        }\n        return true;\n    }\n    /**\n     *\n     */\n    public dragEnd() {\n        this._flag = false;\n        this._lock = false;\n        clearTimeout(this._timer);\n        this._unregisterScrollEvent();\n    }\n    private _getScrollPosition(direction: number[], options: DragScrollOptions) {\n        const {\n            container,\n            getScrollPosition = getDefaultScrollPosition,\n        } = options;\n        return getScrollPosition({ container: getContainerElement(container), direction });\n    }\n    private _continueDrag(options: CheckScrollOptions) {\n        const {\n            container,\n            direction,\n            throttleTime,\n            useScroll,\n            isDrag,\n            inputEvent,\n        } = options;\n\n        if (!this._flag || (isDrag && this._isWait)) {\n            return;\n        }\n        const nowTime = now();\n        const distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);\n\n        if (distTime > 0) {\n            clearTimeout(this._timer);\n            this._timer = window.setTimeout(() => {\n                this._continueDrag(options);\n            }, distTime);\n\n            return false;\n        }\n        this._prevTime = nowTime;\n        const prevScrollPos = this._getScrollPosition(direction, options);\n\n        this._prevScrollPos = prevScrollPos;\n\n        if (isDrag) {\n            this._isWait = true;\n        }\n\n        // unregister native scroll event\n        if (!useScroll) {\n            this._lock = true;\n        }\n        const param = {\n            container: getContainerElement(container),\n            direction,\n            inputEvent,\n        };\n        options.requestScroll?.(param);\n        /**\n         * @event DragScroll#scroll\n         */\n        this.emit(\"scroll\", param);\n\n        this._isWait = false;\n        return useScroll || this.checkScroll({\n            ...options,\n            prevScrollPos,\n            direction,\n            inputEvent,\n        });\n    }\n\n    private _registerScrollEvent(options: DragScrollOptions) {\n        this._unregisterScrollEvent();\n        const checkScrollEvent = options.checkScrollEvent;\n\n        if (!checkScrollEvent) {\n            return;\n        }\n        const callback = checkScrollEvent === true ? checkDefaultScrollEvent : checkScrollEvent;\n        const container = getContainerElement(options.container);\n\n        if (checkScrollEvent === true && (container === document.body || container === document.documentElement)) {\n            this._unregister = checkDefaultScrollEvent(window, this._onScroll);\n        } else {\n            this._unregister = callback(container, this._onScroll);\n        }\n    }\n    private _unregisterScrollEvent() {\n        this._unregister?.();\n        this._unregister = null;\n    }\n\n    private _onScroll = () => {\n        const options = this._currentOptions;\n        if (this._lock || !options) {\n            return;\n        }\n\n        this.emit(\"scrollDrag\", {\n            next: (inputEvent: any) => {\n                this.checkScroll({\n                    container: options.container,\n                    inputEvent,\n                });\n            },\n        });\n    };\n}\n\nexport default DragScroll;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Client, Position } from \"./types\";\nimport { IArrayFormat, isNumber } from \"@daybrush/utils\";\n\nexport function getRad(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const rad = Math.atan2(distY, distX);\n\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport function isMultiTouch(e: any): e is TouchEvent {\n    return e.touches && e.touches.length >= 2;\n}\nexport function getEventClients(e: any): Client[] {\n    if (!e) {\n        return [];\n    } if (e.touches) {\n        return getClients(e.touches);\n    } else {\n        return [getClient(e)];\n    }\n}\nexport function isMouseEvent(e: any): e is MouseEvent {\n    return e && (e.type.indexOf(\"mouse\") > -1 || \"button\" in e);\n}\nexport function getPosition(clients: Client[], prevClients: Client[], startClients: Client[]): Position {\n    const length = startClients.length;\n    const {\n        clientX,\n        clientY,\n        originalClientX,\n        originalClientY,\n    } = getAverageClient(clients, length);\n    const {\n        clientX: prevX,\n        clientY: prevY,\n    } = getAverageClient(prevClients, length);\n\n    const {\n        clientX: startX,\n        clientY: startY,\n    } = getAverageClient(startClients, length);\n    const deltaX = clientX - prevX;\n    const deltaY = clientY - prevY;\n    const distX = clientX - startX;\n    const distY = clientY - startY;\n\n    return {\n        clientX: originalClientX!,\n        clientY: originalClientY!,\n        deltaX,\n        deltaY,\n        distX,\n        distY,\n    };\n}\nexport function getDist(clients: Client[]) {\n    return Math.sqrt(\n        Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2),\n    );\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n    const length = Math.min(touches.length, 2);\n    const clients = [];\n\n    for (let i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nexport function getAverageClient(clients: Client[], length = clients.length): Required<Client> {\n    const sumClient: Required<Client> = {\n        clientX: 0,\n        clientY: 0,\n        originalClientX: 0,\n        originalClientY: 0,\n    };\n    for (let i = 0; i < length; ++i) {\n        const client = clients[i];\n\n        sumClient.originalClientX += \"originalClientX\" in client ? client.originalClientX! : client.clientX;\n        sumClient.originalClientY += \"originalClientY\" in client ? client.originalClientY! : client.clientY;\n        sumClient.clientX += client.clientX;\n        sumClient.clientY += client.clientY;\n    }\n    if (!length) {\n        return sumClient;\n    }\n    return {\n        clientX: sumClient.clientX / length,\n        clientY: sumClient.clientY / length,\n        originalClientX: sumClient.originalClientX / length,\n        originalClientY: sumClient.originalClientY / length,\n    };\n}\nexport function plueClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX + client2.clientX),\n        clientY: (client1.clientY + client2.clientY),\n    };\n}\n\nexport function minusClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX - client2.clientX),\n        clientY: (client1.clientY - client2.clientY),\n    };\n}\n","import { Client } from \"./types\";\nimport { getPosition, getDist, getRotatiion, getAverageClient } from \"./utils\";\n\nexport class ClientStore {\n    public prevClients: Client[] = [];\n    public startClients: Client[] = [];\n    public movement = 0;\n    public length  = 0;\n    constructor(clients: Client[]) {\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.length = clients.length;\n    }\n    public getAngle(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients);\n    }\n    public getRotation(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients) - getRotatiion(this.startClients);\n    }\n    public getPosition(clients: Client[] = this.prevClients, isAdd?: boolean) {\n        const position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);\n\n        const { deltaX, deltaY } = position;\n\n        this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        this.prevClients = clients;\n\n        return position;\n    }\n    public getPositions(clients: Client[] = this.prevClients) {\n        const prevClients = this.prevClients;\n\n        return this.startClients.map((startClient, i) => getPosition([clients[i]], [prevClients[i]], [startClient]));\n    }\n    public getMovement(clients?: Client[]) {\n        const movement = this.movement;\n\n        if (!clients) {\n            return movement;\n        }\n        const currentClient = getAverageClient(clients, this.length);\n        const prevClient = getAverageClient(this.prevClients, this.length);\n        const deltaX = currentClient.clientX - prevClient.clientX;\n        const deltaY = currentClient.clientY - prevClient.clientY;\n\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;\n    }\n    public getDistance(clients = this.prevClients) {\n        return getDist(clients);\n    }\n    public getScale(clients = this.prevClients) {\n        return getDist(clients) / getDist(this.startClients);\n    }\n    public move(deltaX: number, deltaY: number) {\n        this.startClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        this.prevClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n    }\n}\n","import { Client, OnDrag, GestoOptions, GestoEvents } from \"./types\";\nimport {\n    getEventClients, isMouseEvent, isMultiTouch,\n} from \"./utils\";\nimport EventEmitter, { TargetParam } from \"@scena/event-emitter\";\nimport { addEvent, removeEvent, now, IObject } from \"@daybrush/utils\";\nimport { ClientStore } from \"./ClientStore\";\n\nconst INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag, pinch events in any browser.\n */\nclass Gesto extends EventEmitter<GestoEvents> {\n    public options: GestoOptions = {};\n    private flag = false;\n    private pinchFlag = false;\n    private data: IObject<any> = {};\n    private isDrag = false;\n    private isPinch = false;\n    private isMouse = false;\n    private isTouch = false;\n    private clientStores: ClientStore[] = [];\n    private targets: Array<Element | Window> = [];\n    private prevTime: number = 0;\n    private doubleFlag: boolean = false;\n    private _dragFlag = false;\n    private _isTrusted = false;\n    private _isMouseEvent = false;\n    private _isSecondaryButton = false;\n    private _preventMouseEvent = false;\n    private _prevInputEvent: any = null;\n\n    /**\n     *\n     */\n    constructor(targets: Array<Element | Window> | Element | Window, options: GestoOptions = {}) {\n        super();\n        const elements = [].concat(targets as any) as Array<Element | Window>;\n        this.options = {\n            checkInput: false,\n            container: elements.length > 1 ? window : elements[0],\n            preventRightClick: true,\n            preventWheelClick: true,\n            preventClickEventOnDragStart: false,\n            preventClickEventOnDrag: false,\n            preventClickEventByCondition: null,\n            preventDefault: true,\n            checkWindowBlur: false,\n            keepDragging: false,\n            pinchThreshold: 0,\n            events: [\"touch\", \"mouse\"],\n            ...options,\n        };\n\n        const { container, events, checkWindowBlur } = this.options;\n\n        this.isTouch = events!.indexOf(\"touch\") > -1;\n        this.isMouse = events!.indexOf(\"mouse\") > -1;\n        this.targets = elements;\n\n        if (this.isMouse) {\n            elements.forEach(el => {\n                addEvent(el, \"mousedown\", this.onDragStart);\n                addEvent(el, \"mousemove\", this._passCallback);\n            });\n            addEvent(container!, \"contextmenu\", this._onContextMenu);\n        }\n        if (checkWindowBlur) {\n            addEvent(window, \"blur\", this.onBlur);\n        }\n        if (this.isTouch) {\n            const passive = {\n                passive: false,\n            };\n            elements.forEach(el => {\n                addEvent(el, \"touchstart\", this.onDragStart, passive);\n                addEvent(el, \"touchmove\", this._passCallback, passive);\n            });\n        }\n    }\n    /**\n     * Stop Gesto's drag events.\n     */\n    public stop() {\n        this.isDrag = false;\n        this.data = {};\n        this.clientStores = [];\n        this.pinchFlag = false;\n        this.doubleFlag = false;\n        this.prevTime = 0;\n        this.flag = false;\n\n        this._allowClickEvent();\n        this._dettachDragEvent();\n    }\n    /**\n     * The total moved distance\n     */\n    public getMovement(clients?: Client[]) {\n        return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce((prev, cur) => {\n            return prev + cur.movement;\n        }, 0);\n    }\n    /**\n     * Whether to drag\n     */\n    public isDragging(): boolean {\n        return this.isDrag;\n    }\n    /**\n     * Whether to start drag\n     */\n    public isFlag(): boolean {\n        return this.flag;\n    }\n    /**\n     * Whether to start pinch\n     */\n    public isPinchFlag() {\n        return this.pinchFlag;\n    }\n    /**\n     * Whether to start double click\n     */\n    public isDoubleFlag() {\n        return this.doubleFlag;\n    }\n    /**\n     * Whether to pinch\n     */\n    public isPinching() {\n        return this.isPinch;\n    }\n\n    /**\n     * If a scroll event occurs, it is corrected by the scroll distance.\n     */\n    public scrollBy(deltaX: number, deltaY: number, e: any, isCallDrag: boolean = true) {\n        if (!this.flag) {\n            return;\n        }\n        this.clientStores[0].move(deltaX, deltaY);\n        isCallDrag && this.onDrag(e, true);\n    }\n    /**\n     * Create a virtual drag event.\n     */\n    public move([deltaX, deltaY]: number[], inputEvent: any): TargetParam<OnDrag> {\n        const store = this.getCurrentStore();\n        const nextClients = store.prevClients;\n\n        return this.moveClients(nextClients.map(({ clientX, clientY }) => {\n            return {\n                clientX: clientX + deltaX,\n                clientY: clientY + deltaY,\n                originalClientX: clientX,\n                originalClientY: clientY,\n            };\n        }), inputEvent, true);\n    }\n    /**\n     * The dragStart event is triggered by an external event.\n     */\n    public triggerDragStart(e: any) {\n        this.onDragStart(e, false);\n    }\n    /**\n     * Set the event data while dragging.\n     */\n    public setEventData(data: IObject<any>) {\n        const currentData = this.data;\n\n        for (const name in data) {\n            currentData[name] = data[name];\n        }\n        return this;\n    }\n    /**\n     * Set the event data while dragging.\n     * Use `setEventData`\n     * @deprecated\n     */\n    public setEventDatas(data: IObject<any>) {\n        return this.setEventData(data);\n    }\n    /**\n     * Get the current event state while dragging.\n     */\n    public getCurrentEvent(inputEvent: any = this._prevInputEvent) {\n        return {\n            data: this.data,\n            datas: this.data,\n            ...this._getPosition(),\n            movement: this.getMovement(),\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            inputEvent,\n        };\n    }\n    /**\n     * Get & Set the event data while dragging.\n     */\n    public getEventData() {\n        return this.data;\n    }\n    /**\n     * Get & Set the event data while dragging.\n     * Use getEventData method\n     * @depreacated\n     */\n    public getEventDatas() {\n        return this.data;\n    }\n    /**\n     * Unset Gesto\n     */\n    public unset() {\n        const targets = this.targets;\n        const container = this.options.container!;\n\n        this.off();\n        removeEvent(window, \"blur\", this.onBlur);\n        if (this.isMouse) {\n            targets.forEach(target => {\n                removeEvent(target, \"mousedown\", this.onDragStart);\n            });\n            removeEvent(container, \"contextmenu\", this._onContextMenu);\n        }\n        if (this.isTouch) {\n            targets.forEach(target => {\n                removeEvent(target, \"touchstart\", this.onDragStart);\n            });\n            removeEvent(container, \"touchstart\", this.onDragStart);\n        }\n        this._prevInputEvent = null;\n        this._allowClickEvent();\n        this._dettachDragEvent();\n    }\n    public onDragStart = (e: any, isTrusted = true) => {\n        if (!this.flag && e.cancelable === false) {\n            return;\n        }\n        const {\n            container,\n            pinchOutside,\n            preventWheelClick,\n            preventRightClick,\n            preventDefault,\n            checkInput,\n            preventClickEventOnDragStart,\n            preventClickEventOnDrag,\n            preventClickEventByCondition,\n        } = this.options;\n        const isTouch = this.isTouch;\n        const isDragStart = !this.flag;\n\n        this._isSecondaryButton = e.which === 3 || e.button === 2;\n\n        if (\n            (preventWheelClick && (e.which === 2 || e.button === 1))\n            || (preventRightClick && (e.which === 3 || e.button === 2))\n        ) {\n            this.stop();\n            return false;\n        }\n\n        if (isDragStart) {\n            const activeElement = document.activeElement as HTMLElement;\n            const target = e.target as HTMLElement;\n\n           if (target) {\n                const tagName = target.tagName.toLowerCase();\n                const hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n                const hasContentEditable = target.isContentEditable;\n\n                if (hasInput || hasContentEditable) {\n                    if (checkInput || activeElement === target) {\n                        // force false or already focused.\n                        return false;\n                    }\n                    // no focus\n                    if (\n                        activeElement\n                        && hasContentEditable\n                        && activeElement.isContentEditable\n                        && activeElement.contains(target)\n                    ) {\n                        return false;\n                    }\n                } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n                    const activeTagName = activeElement.tagName.toLowerCase();\n\n                    if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n                        activeElement.blur();\n                    }\n                }\n\n                if (preventClickEventOnDragStart || preventClickEventOnDrag || preventClickEventByCondition) {\n                    addEvent(window, \"click\", this._onClick, true);\n                }\n            }\n            this.clientStores = [new ClientStore(getEventClients(e))];\n            this.flag = true;\n            this.isDrag = false;\n            this._isTrusted = isTrusted;\n            this._dragFlag = true;\n            this._prevInputEvent = e;\n            this.data = {};\n\n            this.doubleFlag = now() - this.prevTime < 200;\n            this._isMouseEvent = isMouseEvent(e);\n            if (!this._isMouseEvent && this._preventMouseEvent) {\n                this._preventMouseEvent = false;\n            }\n\n            const result = this._preventMouseEvent || this.emit(\"dragStart\", {\n                data: this.data,\n                datas: this.data,\n                inputEvent: e,\n                isMouseEvent: this._isMouseEvent,\n                isSecondaryButton: this._isSecondaryButton,\n                isTrusted,\n                isDouble: this.doubleFlag,\n                ...this.getCurrentStore().getPosition(),\n                preventDefault() {\n                    e.preventDefault();\n                },\n                preventDrag: () => {\n                    this._dragFlag = false;\n                },\n            });\n            if (result === false) {\n                this.stop();\n            }\n            if (this._isMouseEvent && this.flag && preventDefault) {\n                e.preventDefault();\n            }\n        }\n        if (!this.flag) {\n            return false;\n        }\n        let timer = 0;\n\n        if (isDragStart) {\n            this._attchDragEvent();\n\n            // wait pinch\n            if (isTouch && pinchOutside) {\n                timer = setTimeout(() => {\n                    addEvent(container!, \"touchstart\", this.onDragStart, {\n                        passive: false\n                    });\n                });\n            }\n        } else if (isTouch && pinchOutside) {\n            // pinch is occured\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.flag && isMultiTouch(e)) {\n            clearTimeout(timer);\n            if (isDragStart && (e.touches.length !== e.changedTouches.length)) {\n                return;\n            }\n            if (!this.pinchFlag) {\n                this.onPinchStart(e);\n            }\n        }\n\n    }\n    public onDrag = (e: any, isScroll?: boolean) => {\n        if (!this.flag) {\n            return;\n        }\n        const {\n            preventDefault,\n        } = this.options;\n        if (!this._isMouseEvent && preventDefault) {\n            e.preventDefault();\n        }\n        this._prevInputEvent = e;\n        const clients = getEventClients(e);\n        const result = this.moveClients(clients, e, false);\n\n        if (this._dragFlag) {\n            if (this.pinchFlag || result.deltaX || result.deltaY) {\n                const dragResult = this._preventMouseEvent || this.emit(\"drag\", {\n                    ...result,\n                    isScroll: !!isScroll,\n                    inputEvent: e,\n                });\n\n                if (dragResult === false) {\n                    this.stop();\n                    return;\n                }\n            }\n            if (this.pinchFlag) {\n                this.onPinch(e, clients);\n            }\n        }\n\n        this.getCurrentStore().getPosition(clients, true);\n    }\n    public onDragEnd = (e?: any) => {\n        if (!this.flag) {\n            return;\n        }\n        const {\n            pinchOutside,\n            container,\n            preventClickEventOnDrag,\n            preventClickEventOnDragStart,\n            preventClickEventByCondition,\n        } = this.options;\n        const isDrag = this.isDrag;\n\n        if (preventClickEventOnDrag || preventClickEventOnDragStart || preventClickEventByCondition) {\n            requestAnimationFrame(() => {\n                this._allowClickEvent();\n            });\n        }\n        if (!preventClickEventByCondition && !preventClickEventOnDragStart && preventClickEventOnDrag && !isDrag) {\n            this._allowClickEvent();\n        }\n\n        if (this.isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.pinchFlag) {\n            this.onPinchEnd(e);\n        }\n        const clients = e?.touches ? getEventClients(e) : [];\n        const clientsLength = clients.length;\n\n        if (clientsLength === 0 || !this.options.keepDragging) {\n            this.flag = false;\n        } else {\n            this._addStore(new ClientStore(clients));\n        }\n\n\n        const position = this._getPosition();\n        const currentTime = now();\n        const isDouble = !isDrag && this.doubleFlag;\n\n        this._prevInputEvent = null;\n        this.prevTime = isDrag || isDouble ? 0 : currentTime;\n\n        if (!this.flag) {\n            this._dettachDragEvent();\n\n            this._preventMouseEvent || this.emit(\"dragEnd\", {\n                data: this.data,\n                datas: this.data,\n                isDouble,\n                isDrag: isDrag,\n                isClick: !isDrag,\n                isMouseEvent: this._isMouseEvent,\n                isSecondaryButton: this._isSecondaryButton,\n                inputEvent: e,\n                isTrusted: this._isTrusted,\n                ...position,\n            });\n\n            this.clientStores = [];\n\n            if (!this._isMouseEvent) {\n                this._preventMouseEvent = true;\n                requestAnimationFrame(() => {\n                    requestAnimationFrame(() => {\n                        this._preventMouseEvent = false;\n                    });\n                });\n            }\n        }\n    }\n    public onPinchStart(e: TouchEvent) {\n        const { pinchThreshold } = this.options;\n\n        if (this.isDrag && this.getMovement() > pinchThreshold!) {\n            return;\n        }\n        const store = new ClientStore(getEventClients(e));\n\n        this.pinchFlag = true;\n        this._addStore(store);\n\n        const result = this.emit(\"pinchStart\", {\n            data: this.data,\n            datas: this.data,\n            angle: store.getAngle(),\n            touches: this.getCurrentStore().getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n            isTrusted: this._isTrusted,\n        });\n\n        if (result === false) {\n            this.pinchFlag = false;\n        }\n    }\n    public onPinch(e: TouchEvent, clients: Client[]) {\n        if (!this.flag || !this.pinchFlag || clients.length < 2) {\n            return;\n        }\n\n        const store = this.getCurrentStore();\n        this.isPinch = true;\n\n        this.emit(\"pinch\", {\n            data: this.data,\n            datas: this.data,\n            movement: this.getMovement(clients),\n            angle: store.getAngle(clients),\n            rotation: store.getRotation(clients),\n            touches: store.getPositions(clients),\n            scale: store.getScale(clients),\n            distance: store.getDistance(clients),\n            ...store.getPosition(clients),\n            inputEvent: e,\n            isTrusted: this._isTrusted,\n        });\n    }\n    public onPinchEnd(e: TouchEvent) {\n        if (!this.pinchFlag) {\n            return;\n        }\n        const isPinch = this.isPinch;\n\n        this.isPinch = false;\n        this.pinchFlag = false;\n        const store = this.getCurrentStore();\n        this.emit(\"pinchEnd\", {\n            data: this.data,\n            datas: this.data,\n            isPinch,\n            touches: store.getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n        });\n    }\n    private getCurrentStore() {\n        return this.clientStores[0];\n    }\n    private moveClients(clients: Client[], inputEvent: any, isAdd: boolean): TargetParam<OnDrag> {\n        const position = this._getPosition(clients, isAdd);\n\n        const isPrevDrag = this.isDrag;\n\n        if (position.deltaX || position.deltaY) {\n            this.isDrag = true;\n        }\n        let isFirstDrag = false;\n\n        if (!isPrevDrag && this.isDrag) {\n            isFirstDrag = true;\n        }\n\n        return {\n            data: this.data,\n            datas: this.data,\n            ...position,\n            movement: this.getMovement(clients),\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            isMouseEvent: this._isMouseEvent,\n            isSecondaryButton: this._isSecondaryButton,\n            inputEvent,\n            isTrusted: this._isTrusted,\n            isFirstDrag,\n        };\n    }\n    private onBlur = () => {\n        this.onDragEnd();\n    }\n    private _addStore(store: ClientStore) {\n        this.clientStores.splice(0, 0, store);\n    }\n    private _getPosition(clients?: Client[], isAdd?: boolean) {\n        const store = this.getCurrentStore();\n        const position = store.getPosition(clients, isAdd);\n\n        const { distX, distY } = this.clientStores.slice(1).reduce((prev, cur) => {\n            const storePosition = cur.getPosition();\n\n            prev.distX += storePosition.distX;\n            prev.distY += storePosition.distY;\n            return prev;\n        }, position);\n\n        return {\n            ...position,\n            distX,\n            distY,\n        };\n    }\n    private _allowClickEvent = () => {\n        removeEvent(window, \"click\", this._onClick, true);\n    };\n    private _attchDragEvent() {\n        const container = this.options.container!;\n        const passive = {\n            passive: false\n        };\n\n        if (this.isMouse) {\n            addEvent(container, \"mousemove\", this.onDrag);\n            addEvent(container, \"mouseup\", this.onDragEnd);\n        }\n\n        if (this.isTouch) {\n            addEvent(container, \"touchmove\", this.onDrag, passive);\n            addEvent(container, \"touchend\", this.onDragEnd, passive);\n            addEvent(container, \"touchcancel\", this.onDragEnd, passive);\n        }\n    };\n    private _dettachDragEvent() {\n        const container = this.options.container!;\n\n        if (this.isMouse) {\n            removeEvent(container, \"mousemove\", this.onDrag);\n            removeEvent(container, \"mouseup\", this.onDragEnd);\n        }\n\n        if (this.isTouch) {\n            removeEvent(container, \"touchstart\", this.onDragStart);\n            removeEvent(container, \"touchmove\", this.onDrag);\n            removeEvent(container, \"touchend\", this.onDragEnd);\n            removeEvent(container, \"touchcancel\", this.onDragEnd);\n        }\n    };\n    private _onClick = (e: MouseEvent) => {\n        this._allowClickEvent();\n        this._preventMouseEvent = false;\n        const preventClickEventByCondition = this.options.preventClickEventByCondition;\n        if (preventClickEventByCondition?.(e)) {\n            return;\n        }\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    private _onContextMenu = (e: MouseEvent) => {\n        const options = this.options;\n        if (!options.preventRightClick) {\n            e.preventDefault();\n        } else {\n            this.onDragEnd(e);\n        }\n    }\n    private _passCallback = () => {};\n}\n\nexport default Gesto;\n","import stringHash from \"string-hash\";\nimport { splitComma } from \"@daybrush/utils\";\nimport { InjectOptions } from \"./types\";\n\nexport function getHash(str: string) {\n    return stringHash(str).toString(36);\n}\nexport function getShadowRoot(parentElement: HTMLElement | SVGElement) {\n    if (parentElement && parentElement.getRootNode) {\n        const rootNode = parentElement.getRootNode();\n\n        if (rootNode.nodeType === 11) {\n            return rootNode;\n        }\n    }\n    return;\n}\nexport function replaceStyle(className: string, css: string, options: Partial<InjectOptions>) {\n    if (options.original) {\n        return css;\n    }\n    return css.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, (_, selector) => {\n        const trimmedSelector = selector.trim();\n        return (trimmedSelector ? splitComma(trimmedSelector) : [\"\"]).map(subSelector => {\n            const trimmedSubSelector = subSelector.trim();\n            if (trimmedSubSelector.indexOf(\"@\") === 0) {\n                return trimmedSubSelector;\n            } else if (trimmedSubSelector.indexOf(\":global\") > -1) {\n                return trimmedSubSelector.replace(/\\:global/g, \"\");\n            } else if (trimmedSubSelector.indexOf(\":host\") > -1) {\n                return `${trimmedSubSelector.replace(/\\:host/g, `.${className}`)}`;\n            } else if (trimmedSubSelector) {\n                return `.${className} ${trimmedSubSelector}`;\n            } else {\n                return `.${className}`;\n            }\n        }).join(\", \") + \" {\";\n    });\n}\nexport function injectStyle(className: string, css: string, options: Partial<InjectOptions>, shadowRoot?: Node) {\n    const style = document.createElement(\"style\");\n\n    style.setAttribute(\"type\", \"text/css\");\n    style.setAttribute(\"data-styled-id\", className);\n\n    if (options.nonce) {\n        style.setAttribute(\"nonce\", options.nonce);\n    }\n    style.innerHTML = replaceStyle(className, css, options);\n\n    (shadowRoot || document.head || document.body).appendChild(style);\n    return style;\n}\n","import { getHash, injectStyle, getShadowRoot } from \"./utils\";\nimport { StyledInjector, InjectOptions } from \"./types\";\n\n/**\n * Create an styled object that can be defined and inserted into the css.\n * @param - css styles\n */\nfunction styled(css: string): StyledInjector {\n    const injectClassName = \"rCS\" + getHash(css);\n    let injectCount = 0;\n    let injectElement!: HTMLStyleElement;\n\n    return {\n        className: injectClassName,\n        inject(el: HTMLElement | SVGElement, options: Partial<InjectOptions> = {}) {\n            const shadowRoot = getShadowRoot(el);\n            const firstMount = injectCount === 0;\n            let styleElement: HTMLStyleElement;\n\n            if (shadowRoot || firstMount) {\n                styleElement = injectStyle(injectClassName, css, options, shadowRoot);\n            }\n            if (firstMount) {\n                injectElement = styleElement;\n            }\n            if (!shadowRoot) {\n                ++injectCount;\n            }\n            return {\n                destroy() {\n                    if (shadowRoot) {\n                        shadowRoot.removeChild(styleElement);\n                        styleElement = null;\n                    } else {\n                        if (injectCount > 0) {\n                            --injectCount;\n                        }\n                        if (injectCount === 0 && injectElement) {\n                            injectElement.parentNode!.removeChild(injectElement);\n                            injectElement = null;\n                        }\n                    }\n                },\n            };\n        },\n    };\n}\n\nexport * from \"./types\";\nexport default styled;\n","import { Component, createElement, version } from \"react\";\nimport { IObject } from \"@daybrush/utils\";\nimport { StyledInjector, InjectResult } from \"css-styled\";\nimport { ref } from \"framework-utils\";\n\nexport class StyledElement<T extends HTMLElement | SVGElement = HTMLElement> extends Component<IObject<any>> {\n    public injector!: StyledInjector;\n    public element!: T;\n    public injectResult: InjectResult | null = null;\n    public tag: string = \"div\";\n    public render(): any {\n        const {\n            className = \"\",\n            cspNonce,\n            portalContainer,\n            ...attributes\n        } = this.props;\n        const cssId = this.injector!.className;\n        const Tag = this.tag;\n        let portalAttributes: Record<string, any> = {};\n\n        if ((version || \"\").indexOf(\"simple\") > -1 && portalContainer) {\n            portalAttributes = { portalContainer };\n        }\n\n        return createElement(Tag, {\n            \"ref\": ref(this, \"element\"),\n            \"data-styled-id\": cssId,\n            \"className\": `${className} ${cssId}`,\n            ...portalAttributes,\n            ...attributes,\n        });\n    }\n    public componentDidMount() {\n        this.injectResult = this.injector!.inject(this.element!, {\n            nonce: this.props.cspNonce,\n        });\n    }\n    public componentWillUnmount() {\n        this.injectResult!.destroy();\n        this.injectResult = null;\n    }\n    public getElement() {\n        return this.element;\n    }\n}\n","import cssStyled from \"css-styled\";\nimport { StyledElement } from \"./StyledElement\";\n\nexport default function styled<T extends HTMLElement | SVGElement = HTMLElement>(\n    tag: string, css: string): typeof StyledElement & (new (...args: any[]) => StyledElement<T>) {\n    const injector = cssStyled(css);\n\n    return class Styled extends StyledElement<T> {\n        public injector = injector;\n        public tag = tag;\n    };\n}\n","import { Able, DefaultProps } from \"../types\";\n\nexport function makeAble<\n    Name extends string,\n    AbleObject extends Partial<Able<any, any>>,\n    Props extends DefaultProps<Name, AbleObject>,\n>(name: Name, able: AbleObject) {\n    return {\n        events: {} as const,\n        props: {\n            [name]: Boolean,\n        } as Props,\n        name,\n        ...able,\n    } as const;\n}\n","import getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\nimport { MoveableInterface } from \"./types\";\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    // const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    let defaultCursor = \"ns-resize\";\n\n    if (degree45 === 135) {\n        defaultCursor = \"nwse-resize\";\n    } else if (degree45 === 45) {\n        defaultCursor = \"nesw-resize\";\n    } else if (degree45 === 90) {\n        defaultCursor = \"ew-resize\";\n    }\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent();\nexport const IS_WEBKIT = agent.browser.webkit;\nexport const IS_WEBKIT605 = IS_WEBKIT && (() => {\n    const navi = typeof window === \"undefined\" ? { userAgent: \"\" } : window.navigator;\n    const res = /applewebkit\\/([^\\s]+)/g.exec(navi.userAgent.toLowerCase());\n\n    return res ? parseFloat(res[1]) < 605 : false;\n})();\n\nexport const IS_FIREFOX = agent.browser.name === \"firefox\";\nexport const IS_SAFARI_ABOVE15\n    = parseInt(agent.browser.webkitVersion, 10) >= 612\n    || parseInt(agent.browser.version, 10) >= 15;\n\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = `\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n    outline: 1px solid transparent;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.edge {\n    z-index: 1;\n    background: transparent;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"], :global .view-control-rotation${degree} {\n\t${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n\n.line.direction:before {\n    content: \"\";\n    position: absolute;\n    width: 100%;\n    height: calc(var(--moveable-line-padding, 0) * 1px);\n    bottom: 0;\n    left: 0;\n}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n${IS_WEBKIT605 ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`;\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const FLOAT_POINT_NUM = 0.0001;\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\n\nexport const DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"];\nexport const DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\n\nexport const DIRECTION_REGION_TO_DIRECTION: Record<string, number[]> = {\n    n: [0, -1],\n    e: [1, 0],\n    s: [0, 1],\n    w: [-1, 0],\n    nw: [-1, -1],\n    ne: [1, -1],\n    sw: [-1, 1],\n    se: [1, 1],\n};\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    e: [1, 3],\n    s: [3, 2],\n    w: [2, 0],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n\nexport const MOVEABLE_METHODS: Array<keyof MoveableInterface> = [\n    \"isMoveableElement\",\n    \"updateRect\",\n    \"updateTarget\",\n    \"destroy\",\n    \"dragStart\",\n    \"isInside\",\n    \"hitTest\",\n    \"setState\",\n    \"getRect\",\n    \"request\",\n    \"isDragging\",\n    \"getManager\",\n    \"forceUpdate\",\n    \"waitToChangeTarget\",\n    \"updateSelectors\",\n    \"getTargets\",\n    \"stopDrag\",\n];\n","import { MoveableManagerState, OnCustomDrag } from \"../types\";\nimport { convertDragDist } from \"../utils\";\n\nexport function setCustomDrag(\n    e: any,\n    state: MoveableManagerState<any>,\n    delta: number[],\n    isPinch: boolean,\n    isConvert: boolean,\n    ableName = \"draggable\",\n) {\n    const result = state.gestos[ableName]?.move(delta, e.inputEvent) ?? {};\n    const datas = result.originalDatas || result.datas;\n    const ableDatas = datas[ableName] || (datas[ableName] = {});\n\n    return {\n        ...(isConvert ? convertDragDist(state, result) : result),\n        isPinch: !!isPinch,\n        parentEvent: true,\n        datas: ableDatas,\n        originalDatas: e.originalDatas,\n    };\n}\n\nexport default class CustomGesto {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas: any = {\n        draggable: {},\n    };\n    constructor(private ableName = \"draggable\") {\n        this.datas = {\n            [ableName]: {},\n        };\n    }\n\n    public dragStart(client: number[], e: any) {\n        this.isDrag = false;\n        this.isFlag = false;\n        const originalDatas = e.originalDatas;\n\n        this.datas = originalDatas;\n        if (!originalDatas[this.ableName]) {\n            originalDatas[this.ableName] = {};\n        }\n        return {\n            ...this.move(client, e.inputEvent),\n            type: \"dragstart\",\n        };\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        let isFirstDrag = false;\n\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n            const isPrevDrag = this.isDrag;\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n\n            if (delta[0] || delta[1]) {\n                this.isDrag = true;\n            }\n\n            if (!isPrevDrag && this.isDrag) {\n                isFirstDrag = true;\n            }\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            type: \"drag\",\n            clientX,\n            clientY,\n            inputEvent,\n            isFirstDrag,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas[this.ableName],\n            originalDatas: this.datas,\n            parentEvent: true,\n            parentGesto: this,\n        };\n    }\n}\n","\nimport {\n    invert, calculate, minus, plus,\n    convertPositionMatrix,\n    createScaleMatrix, multiply, fromTranslation, convertDimension,\n} from \"@scena/matrix\";\nimport {\n    calculatePoses, getAbsoluteMatrix, getAbsolutePosesByState,\n    calculatePosition, calculateInversePosition, calculateMoveablePosition, convertTransformInfo, fillCSSObject,\n} from \"../utils\";\nimport { splitUnit, isArray, splitSpace, findIndex, dot, find } from \"@daybrush/utils\";\nimport {\n    MoveableManagerState, ResizableProps, MoveableManagerInterface,\n    OnTransformEvent, OnTransformStartEvent, DraggableProps, OnDrag,\n} from \"../types\";\nimport { setCustomDrag } from \"./CustomGesto\";\nimport { parse, parseMat } from \"css-to-mat\";\nimport { Draggable } from \"../index.esm\";\n\nexport function calculatePointerDist(moveable: MoveableManagerInterface, e: any) {\n    const { clientX, clientY, datas } = e;\n    const {\n        moveableClientRect,\n        rootMatrix,\n        is3d,\n        pos1,\n    } = moveable.state;\n    const { left, top } = moveableClientRect;\n    const n = is3d ? 4 : 3;\n    const [posX, posY] = minus(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1);\n    const [distX, distY] = getDragDist({ datas, distX: posX, distY: posY });\n\n    return [distX, distY];\n}\n\nexport function setDragStart(moveable: MoveableManagerInterface<any>, { datas }: any) {\n    const {\n        allMatrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = allMatrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(allMatrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getTransformDirection(e: any) {\n    return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nexport function resolveTransformEvent(event: any, functionName: string) {\n    const {\n        datas,\n        originalDatas: {\n            beforeRenderable: originalDatas,\n        },\n    } = event;\n\n    const index = datas.transformIndex;\n\n\n    const nextTransforms = originalDatas.nextTransforms as string[];\n    const length = nextTransforms.length;\n    const nextTransformAppendedIndexes: any[] = originalDatas.nextTransformAppendedIndexes;\n    let nextIndex = 0;\n\n    if (index === -1) {\n        // translate => rotate => scale\n        if (functionName === \"translate\") {\n            nextIndex = 0;\n        } else if (functionName === \"rotate\") {\n            nextIndex = findIndex(nextTransforms, text => text.match(/scale\\(/g,));\n        }\n        if (nextIndex === -1) {\n            nextIndex = nextTransforms.length;\n        }\n        datas.transformIndex = nextIndex;\n    } else if (find(nextTransformAppendedIndexes, info => info.index === index && info.functionName === functionName)) {\n        nextIndex = index;\n    } else {\n        nextIndex = index + nextTransformAppendedIndexes.filter(info => info.index < index).length;\n    }\n\n    const result = convertTransformInfo(nextTransforms, nextIndex);\n    const targetFunction = result.targetFunction;\n    const matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\n\n    datas.beforeFunctionTexts = result.beforeFunctionTexts;\n    datas.afterFunctionTexts = result.afterFunctionTexts;\n    datas.beforeTransform = result.beforeFunctionMatrix;\n    datas.beforeTransform2 = result.beforeFunctionMatrix2;\n    datas.targetTansform = result.targetFunctionMatrix;\n    datas.afterTransform = result.afterFunctionMatrix;\n    datas.afterTransform2 = result.afterFunctionMatrix2;\n    datas.targetAllTransform = result.allFunctionMatrix;\n\n    if (targetFunction.functionName === matFunctionName) {\n        datas.afterFunctionTexts.splice(0, 1);\n        datas.isAppendTransform = false;\n    } else if (length > nextIndex) {\n        datas.isAppendTransform = true;\n\n        originalDatas.nextTransformAppendedIndexes = [...nextTransformAppendedIndexes, {\n            functionName,\n            index: nextIndex,\n            isAppend: true,\n        }];\n    }\n}\n\nexport function convertTransformFormat(datas: any, value: any, dist: any) {\n    return `${datas.beforeFunctionTexts.join(\" \")} ${datas.isAppendTransform ? dist : value} ${datas.afterFunctionTexts.join(\" \")}`;\n}\nexport function getTransformDist({ datas, distX, distY }: any) {\n    const [bx, by] = getBeforeDragDist({ datas, distX, distY });\n    // B * [tx, ty] * A = [bx, by] * targetMatrix;\n    // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];\n\n    const res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));\n\n    return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nexport function getTransfromMatrix(datas: any, targetMatrix: number[], isAfter?: boolean) {\n    const {\n        beforeTransform,\n        afterTransform,\n        beforeTransform2,\n        afterTransform2,\n        targetAllTransform,\n    } = datas;\n\n    // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)\n    // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1\n    // nextTargetMatrix = (targetMatrix * targetAllTransform)\n    const nextTargetMatrix\n        = isAfter\n            ? multiply(targetAllTransform, targetMatrix, 4)\n            : multiply(targetMatrix, targetAllTransform, 4);\n\n    // res1 = B-1 * nextTargetMatrix\n    const res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);\n\n    // res3 = res2 * A-1\n    const afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);\n\n    return afterTargetMatrix;\n}\nexport function getBeforeDragDist({ datas, distX, distY }: any) {\n    // TT = BT\n    const {\n        inverseBeforeMatrix,\n        is3d,\n        startDragBeforeDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])\n    // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]\n    return minus(\n        calculate(\n            inverseBeforeMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        startDragBeforeDist,\n    );\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function getInverseDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        beforeMatrix,\n        matrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? beforeMatrix : matrix,\n            plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n            n,\n        ),\n        absoluteOrigin,\n    );\n}\n\nexport function calculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    const xRatio = (direction[0] + 1) / 2;\n    const yRatio = (direction[1] + 1) / 2;\n\n    const top = [\n        dot(poses[0][0], poses[1][0], xRatio, 1 - xRatio),\n        dot(poses[0][1], poses[1][1], xRatio, 1 - xRatio),\n    ];\n    const bottom = [\n        dot(poses[2][0], poses[3][0], xRatio, 1 - xRatio),\n        dot(poses[2][1], poses[3][1], xRatio, 1 - xRatio),\n    ];\n    return [\n        dot(top[0], bottom[0], yRatio, 1 - yRatio),\n        dot(top[1], bottom[1], yRatio, 1 - yRatio),\n    ];\n}\n\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    fixedDirection: number[],\n) {\n    const poses = calculatePoses(matrix, width, height, n);\n    const fixedPos = getPosByDirection(poses, fixedDirection);\n    const distX = startPos[0] - fixedPos[0];\n    const distY = startPos[1] - fixedPos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function getNextTransformMatrix(\n    state: MoveableManagerState<any>,\n    datas: any,\n    transform: string,\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n    } = state;\n    const {\n        beforeTransform,\n        afterTransform,\n    } = datas;\n    const n = is3d ? 4 : 3;\n    const targetTransform = parseMat([transform]);\n\n    return getNextMatrix(\n        offsetMatrix,\n        convertDimension(multiply(multiply(beforeTransform, targetTransform as any, 4), afterTransform, 4), 4, n),\n        transformOrigin,\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\n\nexport function fillTransformStartEvent(e: any): OnTransformStartEvent {\n    const originalDatas = getBeforeRenderableDatas(e);\n    return {\n        setTransform: (transform: string | string[], index = -1) => {\n            originalDatas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            setTransformIndex(e, index);\n        },\n        setTransformIndex: (index: number) => {\n            setTransformIndex(e, index);\n        },\n    };\n}\nexport function setDefaultTransformIndex(e: any, property: string) {\n    const originalDatas = getBeforeRenderableDatas(e);\n    const startTransforms = originalDatas.startTransforms;\n\n    setTransformIndex(e, findIndex<string>(startTransforms, func => func.indexOf(`${property}(`) === 0));\n}\nexport function setTransformIndex(e: any, index: number) {\n    const originalDatas = getBeforeRenderableDatas(e);\n    const datas = e.datas;\n\n    datas.transformIndex = index;\n    if (index === -1) {\n        return;\n    }\n    const transform = originalDatas.startTransforms[index];\n\n    if (!transform) {\n        return;\n    }\n    const info = parse([transform]);\n\n    datas.startValue = info[0].functionValue;\n}\nexport function fillOriginalTransform(\n    e: any,\n    transform: string,\n) {\n    const originalDatas = getBeforeRenderableDatas(e);\n\n    originalDatas.nextTransforms = splitSpace(transform);\n    // originalDatas.nextTargetMatrix = parseMat(transform);\n}\nexport function getBeforeRenderableDatas(e: any) {\n    return e.originalDatas.beforeRenderable;\n}\nexport function getNextTransforms(e: any) {\n    const {\n        originalDatas: {\n            beforeRenderable: originalDatas,\n        },\n    } = e;\n\n    return originalDatas.nextTransforms;\n}\nexport function getNextTransformText(e: any) {\n    return getNextTransforms(e).join(\" \");\n}\n\nexport function getNextStyle(e: any) {\n    return getBeforeRenderableDatas(e).nextStyle;\n}\n\nexport function fillTransformEvent(\n    moveable: MoveableManagerInterface<DraggableProps>,\n    nextTransform: string,\n    delta: number[],\n    isPinch: boolean,\n    e: any,\n): OnTransformEvent {\n    fillOriginalTransform(e, nextTransform);\n\n    const drag = Draggable.drag!(\n        moveable,\n        setCustomDrag(e, moveable.state, delta, isPinch, false),\n    ) as OnDrag;\n    const afterTransform = drag ? drag.transform : nextTransform;\n    return {\n        transform: nextTransform,\n        drag: drag as OnDrag,\n        ...fillCSSObject({\n            transform: afterTransform,\n        }, e),\n        afterTransform,\n    };\n}\nexport function getTranslateDist(\n    moveable: MoveableManagerInterface<any>,\n    transform: string,\n    fixedDirection: number[],\n    fixedPosition: number[],\n    datas: any,\n) {\n    const state = moveable.state;\n    const {\n        left,\n        top,\n    } = state;\n\n    const groupable = moveable.props.groupable;\n    const nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);\n    const dist = minus(fixedPosition, nextFixedPosition);\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getScaleDist(\n    moveable: MoveableManagerInterface<any>,\n    scaleDist: number[],\n    fixedDirection: number[],\n    fixedPosition: number[],\n    datas: any,\n) {\n    const dist = getTranslateDist(\n        moveable,\n        `scale(${scaleDist.join(\", \")})`,\n        fixedDirection,\n        fixedPosition,\n        datas,\n    );\n\n    return dist;\n}\nexport function getOriginDirection(moveable: MoveableManagerInterface<any>) {\n    const {\n        width,\n        height,\n        transformOrigin,\n    } = moveable.state;\n    return [\n        -1 + transformOrigin[0] / (width / 2),\n        -1 + transformOrigin[1] / (height / 2),\n    ];\n}\nexport function getDirectionByPos(\n    pos: number[],\n    width: number,\n    height: number,\n) {\n    return [\n        -1 + pos[0] / (width / 2),\n        -1 + pos[1] / (height / 2),\n    ];\n}\nexport function getDirectionOffset(\n    moveable: MoveableManagerInterface, direction: number[],\n    nextMatrix: number[] = moveable.state.allMatrix,\n) {\n    const {\n        width,\n        height,\n        is3d,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n    const nextFixedOffset = [\n        width / 2 * (1 + direction[0]),\n        height / 2 * (1 + direction[1]),\n    ];\n    return calculatePosition(nextMatrix, nextFixedOffset, n);\n}\nexport function getRotateDist(\n    moveable: MoveableManagerInterface<any>,\n    rotateDist: number,\n    datas: any,\n) {\n    const fixedDirection = datas.fixedDirection;\n    const fixedPosition = datas.fixedPosition;\n\n    return getTranslateDist(\n        moveable,\n        `rotate(${rotateDist}deg)`,\n        fixedDirection,\n        fixedPosition,\n        datas,\n    );\n}\nexport function getResizeDist(\n    moveable: MoveableManagerInterface<any>,\n    width: number,\n    height: number,\n    fixedPosition: number[],\n    transformOrigin: string[],\n    datas: any,\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const state = moveable.state;\n    const {\n        transformOrigin: prevOrigin,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = state;\n    const fixedDirection = datas.fixedDirection;\n    const targetMatrix = datas.nextTargetMatrix || state.targetMatrix;\n    const n = is3d ? 4 : 3;\n    const nextOrigin = calculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getAbsolutePosition(\n    moveable: MoveableManagerInterface<ResizableProps>,\n    direction: number[],\n) {\n    return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n","import { PREFIX, IS_WEBKIT605, TINY_NUM } from \"./consts\";\nimport { prefixNames, InvertObject } from \"framework-utils\";\nimport {\n    isUndefined, isObject, splitUnit,\n    IObject, hasClass, isArray, isString, getRad,\n    getShapeDirection, isFunction, convertUnitSize, between, getKeys, decamelize,\n} from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, calculate,\n    multiplies,\n    minus,\n    createScaleMatrix,\n    plus,\n    convertMatrixtoCSS,\n    rotate,\n} from \"@scena/matrix\";\nimport {\n    MoveableManagerState, Able, MoveableClientRect,\n    MoveableProps, ArrayFormat, MoveableRefType,\n    MatrixInfo, ExcludeEndParams, ExcludeParams,\n    ElementSizes, MoveablePosition, TransformObject,\n    MoveableRefTargetsResultType, MoveableRefTargetType, MoveableManagerInterface, CSSObject,\n} from \"./types\";\nimport { parse, toMat, calculateMatrixDist, parseMat } from \"css-to-mat\";\nimport { getBeforeRenderableDatas, getDragDist } from \"./gesto/GestoUtils\";\nimport { getGestoData } from \"./gesto/GestoData\";\n\nexport function round(num: number) {\n    return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function defaultSync(fn: () => void) {\n    fn();\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    return parseMat(transform);\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = getSVGViewBox(el.ownerSVGElement!);\n\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getElementTransform(\n    target: HTMLElement | SVGElement,\n    computedStyle = getComputedStyle(target),\n) {\n    const computedTransform = computedStyle.transform;\n\n    if (computedTransform && computedTransform !== \"none\") {\n        return computedStyle.transform;\n    }\n    if (\"transform\" in target) {\n        const list = (target as any).transform as SVGAnimatedTransformList;\n        const baseVal = list.baseVal;\n\n        if (!baseVal) {\n            return \"\";\n        }\n        const length = baseVal.length;\n\n        if (!length) {\n            return \"\";\n        }\n\n        const matrixes: string[] = [];\n\n        for (let i = 0; i < length; ++i) {\n            const matrix = baseVal[i].matrix;\n\n            matrixes.push(`matrix(${([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] as const).map(chr => matrix[chr]).join(\", \")})`);\n        }\n        return matrixes.join(\" \");\n\n    }\n    return \"\";\n}\n\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n    checkZoom?: boolean,\n    targetStyle?: CSSStyleDeclaration,\n) {\n    const doc = el && el.ownerDocument ? el.ownerDocument : document;\n    const documentElement = doc.documentElement || doc.body;\n    let hasSlot = false;\n    let target: HTMLElement | SVGElement | null | undefined;\n    let parentSlotElement: HTMLElement | null | undefined;\n\n    if (!el || isParent) {\n        target = el;\n    } else {\n        const assignedSlotParentElement = el?.assignedSlot?.parentElement;\n        const parentElement = el.parentElement;\n\n        if (assignedSlotParentElement) {\n            hasSlot = true;\n            parentSlotElement = parentElement;\n            target = assignedSlotParentElement;\n        } else {\n            target = parentElement;\n        }\n    }\n\n    let isCustomElement = false;\n    let isEnd = el === lastParent || target === lastParent;\n    let position = \"relative\";\n    let offsetZoom = 1;\n\n\n    const targetZoom = parseFloat((targetStyle as any)?.zoom) || 1;\n    const targetPosition = targetStyle?.position;\n\n\n\n    while (target && target !== documentElement) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const tagName = target.tagName.toLowerCase();\n        const transform = getElementTransform(target as SVGElement, style);\n        const willChange = style.willChange;\n        const zoom = parseFloat((style as any).zoom) || 1;\n        position = style.position!;\n\n        if (checkZoom && zoom !== 1) {\n            offsetZoom = zoom;\n            break;\n        }\n        if (\n            // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.\n            !isParent && checkZoom && targetZoom !== 1 && targetPosition && targetPosition !== \"absolute\"\n            || tagName === \"svg\"\n            || position !== \"static\"\n            || (transform && transform !== \"none\")\n            || willChange === \"transform\"\n        ) {\n            break;\n        }\n        const slotParentNode = el?.assignedSlot?.parentNode;\n        const targetParentNode = target.parentNode;\n\n        if (slotParentNode) {\n            hasSlot = true;\n            parentSlotElement = targetParentNode as HTMLElement;\n        }\n        const parentNode = slotParentNode || targetParentNode;\n\n\n        if (parentNode && parentNode.nodeType === 11) {\n            // Shadow Root\n            target = (parentNode as ShadowRoot).host as HTMLElement;\n            isCustomElement = true;\n\n            break;\n        }\n        target = parentNode as HTMLElement | SVGElement;\n        position = \"relative\";\n    }\n    return {\n        offsetZoom,\n        hasSlot,\n        parentSlotElement,\n        isCustomElement,\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === documentElement,\n        offsetParent: target as HTMLElement || documentElement,\n    };\n\n}\nexport function getOffsetPosInfo(\n    el: HTMLElement | SVGElement,\n    target: HTMLElement | SVGElement,\n    style: CSSStyleDeclaration,\n) {\n    const tagName = el.tagName.toLowerCase();\n    let offsetLeft = (el as HTMLElement).offsetLeft;\n    let offsetTop = (el as HTMLElement).offsetTop;\n\n    // svg\n    const isSVG = isUndefined(offsetLeft);\n    let hasOffset = !isSVG;\n    let origin: number[];\n    let targetOrigin: number[];\n    // inner svg element\n    if (!hasOffset && tagName !== \"svg\") {\n        origin = IS_WEBKIT605\n            ? getBeforeTransformOrigin(el as SVGElement)\n            : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n        targetOrigin = origin.slice();\n        hasOffset = true;\n\n        [\n            offsetLeft, offsetTop, origin[0], origin[1],\n        ] = getSVGGraphicsOffset(\n            el as SVGGraphicsElement,\n            origin,\n            el === target && target.tagName.toLowerCase() === \"g\",\n        );\n    } else {\n        origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n        targetOrigin = origin.slice();\n    }\n    return {\n        tagName,\n        isSVG,\n        hasOffset,\n        offset: [offsetLeft || 0, offsetTop || 0],\n        origin,\n        targetOrigin,\n    };\n}\nexport function getBodyOffset(\n    el: HTMLElement | SVGElement,\n    isSVG: boolean,\n    style: CSSStyleDeclaration = getComputedStyle(el),\n) {\n    const bodyStyle = getComputedStyle(document.body);\n    const bodyPosition = bodyStyle.position;\n    if (!isSVG && (!bodyPosition || bodyPosition === \"static\")) {\n        return [0, 0];\n    }\n\n    let marginLeft = parseInt(bodyStyle.marginLeft, 10);\n    let marginTop = parseInt(bodyStyle.marginTop, 10);\n\n    if (style.position === \"absolute\") {\n        if (style.top !== \"auto\" || style.bottom !== \"auto\") {\n            marginTop = 0;\n        }\n        if (style.left !== \"auto\" || style.right !== \"auto\") {\n            marginLeft = 0;\n        }\n    }\n\n    return [marginLeft, marginTop];\n}\nexport function convert3DMatrixes(matrixes: MatrixInfo[]) {\n    matrixes.forEach(info => {\n        const matrix = info.matrix;\n\n        if (matrix) {\n            info.matrix = convertDimension(matrix, 3, 4);\n        }\n    });\n}\n\nexport function getBodyScrollPos() {\n    return [\n        document.documentElement.scrollLeft || document.body.scrollLeft,\n        document.documentElement.scrollTop || document.body.scrollTop,\n    ];\n}\n\nexport function getPositionFixedInfo(el: HTMLElement | SVGElement) {\n    let fixedContainer = el.parentElement;\n    let hasTransform = false;\n\n    while (fixedContainer) {\n        const transform = getComputedStyle(fixedContainer).transform;\n\n\n        if (transform && transform !== \"none\") {\n            hasTransform = true;\n            break;\n        }\n        if (fixedContainer === document.body) {\n            break;\n        }\n        fixedContainer = fixedContainer.parentElement;\n    }\n\n    return {\n        fixedContainer: fixedContainer || document.body,\n        hasTransform,\n    };\n}\n\nexport function makeMatrixCSS(matrix: number[], is3d: boolean = matrix.length > 9) {\n    return `${is3d ? \"matrix3d\" : \"matrix\"}(${convertMatrixtoCSS(matrix, !is3d).join(\",\")})`;\n}\nexport function getSVGViewBox(el: SVGSVGElement) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n\n    if (!el) {\n        return { x: 0, y: 0, width: 0, height: 0, clientWidth, clientHeight };\n    }\n    const viewBox = el.viewBox;\n    const baseVal = (viewBox && viewBox.baseVal) || { x: 0, y: 0, width: 0, height: 0 };\n\n    return {\n        x: baseVal.x,\n        y: baseVal.y,\n        width: baseVal.width || clientWidth,\n        height: baseVal.height || clientHeight,\n        clientWidth,\n        clientHeight,\n    };\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const {\n        width: viewBoxWidth,\n        height: viewBoxHeight,\n        clientWidth,\n        clientHeight,\n    } = getSVGViewBox(el);\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = el.preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n * (n - 1)],\n        scaleMatrix[n * (n - 1) + 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n    isGTarget?: boolean,\n) {\n    if (!el.getBBox || !isGTarget && el.tagName.toLowerCase() === \"g\") {\n        return [0, 0, 0, 0];\n    }\n    const bbox = el.getBBox();\n    const viewBox = getSVGViewBox(el.ownerSVGElement!);\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function calculatePosition(matrix: number[], pos: number[], n: number) {\n    return calculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function calculatePoses(matrix: number[], width: number, height: number, n: number) {\n    return [[0, 0], [width, 0], [0, height], [width, height]].map(pos => calculatePosition(matrix, pos, n));\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function calculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = calculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    offsetInfo: MatrixInfo,\n    targetInfo: MatrixInfo,\n    container: HTMLElement | SVGElement,\n    n: number,\n    beforeMatrix: number[],\n) {\n    const target = offsetInfo.target;\n    const origin = offsetInfo.origin!;\n    const targetMatrix = targetInfo.matrix!;\n    const {\n        offsetWidth: width,\n        offsetHeight: height,\n    } = getSize(target);\n    const containerClientRect = container.getBoundingClientRect();\n    let margin = [0, 0];\n\n    if (container === document.body) {\n        margin = getBodyOffset(target, true);\n    }\n\n    const rect = target.getBoundingClientRect();\n    const rectLeft\n        = rect.left - containerClientRect.left + container.scrollLeft\n        - (container.clientLeft || 0) + margin[0];\n    const rectTop\n        = rect.top - containerClientRect.top + container.scrollTop\n        - (container.clientTop || 0) + margin[1];\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        targetMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = calculateRect(mat, width, height, n);\n    const posOrigin = calculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            calculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            calculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            targetMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = calculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\n\nexport function calculateMoveableClientPositions(\n    rootMatrix: number[],\n    poses: number[][],\n    rootClientRect: MoveableClientRect,\n) {\n    const is3d = rootMatrix.length === 16;\n    const n = is3d ? 4 : 3;\n    const rootPoses = poses.map(pos => calculatePosition(rootMatrix, pos, n));\n    const { left, top } = rootClientRect;\n\n    return rootPoses.map(pos => {\n        return [pos[0] + left, pos[1] + top];\n    });\n\n}\nexport function calculateMoveablePosition(\n    matrix: number[],\n    origin: number[],\n    width: number,\n    height: number,\n): MoveablePosition {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    const poses = calculatePoses(matrix, width, height, n);\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = poses;\n    let [originX, originY] = calculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const direction = getShapeDirection(calculatePoses(matrix, 100, 100, n));\n    return {\n        left,\n        top,\n        right,\n        bottom,\n        origin: [originX, originY],\n        pos1: [x1, y1],\n        pos2: [x2, y2],\n        pos3: [x3, y3],\n        pos4: [x4, y4],\n        direction,\n    };\n}\nexport function getDistSize(vec: number[]) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1],\n    ]);\n}\nexport function getLineStyle(pos1: number[], pos2: number[], zoom = 1, rad: number = getRad(pos1, pos2)) {\n    const width = getDiagonalSize(pos1, pos2);\n\n    return {\n        transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, zoom: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translateZ(0px) translate(${x}px, ${y}px) rotate(${rotation}rad) scale(${zoom})`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\n\nexport function getProps<Props>(props: Props, ableName: keyof Props): Props {\n    const self = props[ableName];\n\n    if (isObject(self)) {\n        return {\n            ...props,\n            ...self,\n        };\n    }\n    return props;\n}\n\nexport function getSize(\n    target?: SVGElement | HTMLElement | null,\n    style: CSSStyleDeclaration | null = target ? getComputedStyle(target) : null,\n): ElementSizes {\n    const hasOffset = target && !isUndefined((target as any).offsetWidth);\n\n    let offsetWidth = 0;\n    let offsetHeight = 0;\n    let clientWidth = 0;\n    let clientHeight = 0;\n    let cssWidth = 0;\n    let cssHeight = 0;\n    let contentWidth = 0;\n    let contentHeight = 0;\n\n    let minWidth = 0;\n    let minHeight = 0;\n    let minOffsetWidth = 0;\n    let minOffsetHeight = 0;\n\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n    let maxOffsetWidth = Infinity;\n    let maxOffsetHeight = Infinity;\n    let inlineCSSWidth = 0;\n    let inlineCSSHeight = 0;\n    let svg = false;\n\n    if (target) {\n        if (!hasOffset && target!.tagName.toLowerCase() !== \"svg\") {\n            const bbox = (target as SVGGraphicsElement).getBBox();\n\n            svg = true;\n            offsetWidth = bbox.width;\n            offsetHeight = bbox.height;\n            cssWidth = offsetWidth;\n            cssHeight = offsetHeight;\n            contentWidth = offsetWidth;\n            contentHeight = offsetHeight;\n            clientWidth = offsetWidth;\n            clientHeight = offsetHeight;\n        } else {\n            const targetStyle = target.style;\n            const boxSizing = style!.boxSizing === \"border-box\";\n            const borderLeft = parseFloat(style!.borderLeftWidth!) || 0;\n            const borderRight = parseFloat(style!.borderRightWidth!) || 0;\n            const borderTop = parseFloat(style!.borderTopWidth!) || 0;\n            const borderBottom = parseFloat(style!.borderBottomWidth!) || 0;\n            const paddingLeft = parseFloat(style!.paddingLeft!) || 0;\n            const paddingRight = parseFloat(style!.paddingRight!) || 0;\n            const paddingTop = parseFloat(style!.paddingTop!) || 0;\n            const paddingBottom = parseFloat(style!.paddingBottom!) || 0;\n\n            const horizontalPadding = paddingLeft + paddingRight;\n            const verticalPadding = paddingTop + paddingBottom;\n            const horizontalBorder = borderLeft + borderRight;\n            const verticalBorder = borderTop + borderBottom;\n            const horizontalOffset = horizontalPadding + horizontalBorder;\n            const verticalOffset = verticalPadding + verticalBorder;\n            const position = style!.position;\n\n            let containerWidth = 0;\n            let containerHeight = 0;\n\n            // SVGSVGElement, HTMLElement\n            if (\"clientLeft\" in target) {\n                let parentElement: HTMLElement | null = null;\n\n                if (position === \"absolute\") {\n                    const offsetInfo = getOffsetInfo(target, document.body);\n                    parentElement = offsetInfo.offsetParent;\n\n                } else {\n                    parentElement = target.parentElement;\n                }\n                if (parentElement) {\n                    const parentStyle = getComputedStyle(parentElement);\n\n                    containerWidth = parseFloat(parentStyle.width);\n                    containerHeight = parseFloat(parentStyle.height);\n                }\n            }\n            minWidth = Math.max(\n                horizontalPadding,\n                convertUnitSize(style!.minWidth, containerWidth) || 0,\n            );\n            minHeight = Math.max(\n                verticalPadding,\n                convertUnitSize(style!.minHeight, containerHeight) || 0,\n            );\n            maxWidth = convertUnitSize(style!.maxWidth, containerWidth);\n            maxHeight = convertUnitSize(style!.maxHeight, containerHeight);\n\n            if (isNaN(maxWidth)) {\n                maxWidth = Infinity;\n            }\n            if (isNaN(maxHeight)) {\n                maxHeight = Infinity;\n            }\n            inlineCSSWidth = convertUnitSize(targetStyle.width, 0) || 0;\n            inlineCSSHeight = convertUnitSize(targetStyle.height, 0) || 0;\n            cssWidth = parseFloat(style!.width) || 0;\n            cssHeight = parseFloat(style!.height) || 0;\n\n\n            contentWidth = Math.abs(cssWidth - inlineCSSWidth) < 1\n                ? between(minWidth, inlineCSSWidth || cssWidth, maxWidth)\n                : cssWidth;\n            contentHeight = Math.abs(cssHeight - inlineCSSHeight) < 1\n                ? between(minHeight, inlineCSSHeight || cssHeight, maxHeight)\n                : cssHeight;\n\n            offsetWidth = contentWidth;\n            offsetHeight = contentHeight;\n            clientWidth = contentWidth;\n            clientHeight = contentHeight;\n\n            if (boxSizing) {\n                maxOffsetWidth = maxWidth;\n                maxOffsetHeight = maxHeight;\n                minOffsetWidth = minWidth;\n                minOffsetHeight = minHeight;\n                contentWidth = offsetWidth - horizontalOffset;\n                contentHeight = offsetHeight - verticalOffset;\n            } else {\n                maxOffsetWidth = maxWidth + horizontalOffset;\n                maxOffsetHeight = maxHeight + verticalOffset;\n                minOffsetWidth = minWidth + horizontalOffset;\n                minOffsetHeight = minHeight + verticalOffset;\n                offsetWidth = contentWidth + horizontalOffset;\n                offsetHeight = contentHeight + verticalOffset;\n            }\n            clientWidth = contentWidth + horizontalPadding;\n            clientHeight = contentHeight + verticalPadding;\n        }\n    }\n\n    return {\n        svg,\n        offsetWidth,\n        offsetHeight,\n        clientWidth,\n        clientHeight,\n        contentWidth,\n        contentHeight,\n        inlineCSSWidth,\n        inlineCSSHeight,\n        cssWidth,\n        cssHeight,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        minOffsetWidth,\n        minOffsetHeight,\n        maxOffsetWidth,\n        maxOffsetHeight,\n    };\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\n\nexport function resetClientRect(): MoveableClientRect {\n    return {\n        left: 0, top: 0,\n        width: 0, height: 0,\n        right: 0,\n        bottom: 0,\n        clientLeft: 0, clientTop: 0,\n        clientWidth: 0, clientHeight: 0,\n        scrollWidth: 0, scrollHeight: 0,\n    };\n}\n\nexport function getExtendsRect(el: HTMLElement | SVGElement, rect: MoveableClientRect): MoveableClientRect {\n    const isRoot = el === document.body || el === document.documentElement;\n\n\n    const extendsRect =  {\n        clientLeft: el.clientLeft,\n        clientTop: el.clientTop,\n        clientWidth: el.clientWidth,\n        clientHeight: el.clientHeight,\n        scrollWidth: el.scrollWidth,\n        scrollHeight: el.scrollHeight,\n        overflow: false,\n    };\n\n    if (isRoot) {\n        extendsRect.clientHeight = Math.max(rect.height, extendsRect.clientHeight);\n        extendsRect.scrollHeight = Math.max(rect.height, extendsRect.scrollHeight);\n    }\n    extendsRect.overflow = getComputedStyle(el).overflow !== \"visible\";\n\n    return {\n        ...rect,\n        ...extendsRect,\n    };\n}\n\nexport function getClientRectByPosition(\n    position: { left: number, right: number, top: number, bottom: number },\n    base: MoveableClientRect,\n    el?: HTMLElement | SVGElement, isExtends?: boolean,\n) {\n    const {\n        left,\n        right,\n        top,\n        bottom,\n    } = position;\n    const baseTop = base.top;\n    const baseLeft = base.left;\n\n    const rect: MoveableClientRect = {\n        left: baseLeft + left,\n        top: baseTop + top,\n        right: baseLeft + right,\n        bottom: baseTop + bottom,\n        width: right - left,\n        height: bottom - top,\n    };\n\n\n    if (el && isExtends) {\n        return getExtendsRect(el, rect);\n    }\n    return rect;\n}\nexport function getClientRect(el: HTMLElement | SVGElement, isExtends?: boolean) {\n    let left = 0;\n    let top = 0;\n    let width = 0;\n    let height = 0;\n    // let isRoot = false;\n\n    if (el) {\n        // isRoot = el === document.body || el === document.documentElement;\n        // if (isRoot) {\n        //     width = window.innerWidth;\n        //     height = window.innerHeight;\n        //     const scrollPos = getBodyScrollPos();\n\n        //     [left, top] = [-scrollPos[0], -scrollPos[1]];\n        // } else {\n        const clientRect = el.getBoundingClientRect();\n\n        left = clientRect.left;\n        top = clientRect.top;\n        width = clientRect.width;\n        height = clientRect.height;\n        // }\n    }\n\n    const rect: MoveableClientRect = {\n        left,\n        top,\n        width,\n        height,\n        right: left + width,\n        bottom: top + height,\n    };\n\n    if (el && isExtends) {\n        return getExtendsRect(el, rect);\n    }\n    return rect;\n}\nexport function getTotalDirection(\n    parentDirection: number[],\n    isPinch: boolean,\n    inputEvent: any,\n    datas: any,\n) {\n    let direction: number[] | undefined;\n\n    if (parentDirection) {\n        direction = parentDirection;\n    } else if (isPinch) {\n        direction = [0, 0];\n    } else {\n        const target = inputEvent.target;\n\n        direction = getDirection(target, datas);\n    }\n    return direction;\n}\nexport function getDirection(target: SVGElement | HTMLElement, datas: any) {\n    if (!target) {\n        return;\n    }\n    const deg = target.getAttribute(\"data-rotation\") || \"\";\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    datas.deg = deg;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\n\nexport function roundSign(num: number) {\n    return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\n\nexport function unset(self: any, name: string) {\n    self[name]?.unset();\n    self[name] = null;\n}\n\nexport function fillCSSObject(style: Record<string, any>, resolvedEvent?: any): CSSObject {\n    if (resolvedEvent) {\n        const originalDatas = getBeforeRenderableDatas(resolvedEvent);\n\n        originalDatas.nextStyle = {\n            ...originalDatas.nextStyle,\n            ...style,\n        };\n    }\n    return {\n        style,\n        cssText: getKeys(style).map(name => `${decamelize(name, \"-\")}: ${style[name]};`).join(\"\"),\n    };\n}\n\nexport function fillAfterTransform(\n    prevEvent: { style: Record<string, string>, transform: string },\n    nextEvent: { style: Record<string, string>, transform: string, afterTransform?: string },\n    resolvedEvent?: any\n): TransformObject {\n    const afterTransform = nextEvent.afterTransform || nextEvent.transform;\n\n    return {\n        ...fillCSSObject({\n            ...prevEvent.style,\n            ...nextEvent.style,\n            transform: afterTransform,\n        }, resolvedEvent),\n        afterTransform,\n        transform: prevEvent.transform,\n    };\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: ExcludeParams<T>,\n    isBeforeEvent?: boolean,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    const nextParams = {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        moveable,\n        datas: datas.datas,\n        isFirstDrag: !!e.isFirstDrag,\n        isTrusted: e.isTrusted !== false,\n        stopAble() {\n            datas.isEventStart = false;\n        },\n        stopDrag() {\n            e.stop?.();\n        },\n    } as any;\n\n    if (!datas.isStartEvent) {\n        datas.isStartEvent = true;\n    } else if (!isBeforeEvent) {\n        datas.lastEvent = nextParams;\n    }\n    return nextParams;\n}\nexport function fillEndParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: ExcludeEndParams<T> & { isDrag?: boolean },\n): T {\n    const datas = e.datas;\n    const isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n\n    return {\n        isDrag,\n        ...params,\n        moveable,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        lastEvent: datas.lastEvent,\n        isDouble: e.isDouble,\n        datas: datas.datas,\n        isFirstDrag: !!e.isFirstDrag,\n    } as any;\n}\nexport function catchEvent<EventName extends keyof Props, Props extends IObject<any> = MoveableProps>(\n    moveable: any,\n    name: EventName,\n    callback: (e: Props[EventName] extends ((e: infer P) => any) | undefined ? P : IObject<any>) => void,\n): any {\n    moveable._emitter.on(name, callback);\n}\n\nexport function triggerEvent<EventName extends keyof Props, Props extends IObject<any> = MoveableProps>(\n    moveable: any,\n    name: EventName,\n    params: Props[EventName] extends ((e: infer P) => any) | undefined ? P : IObject<any>,\n    isManager?: boolean,\n): any {\n    return moveable.triggerEvent(name, params, isManager);\n}\n\nexport function getComputedStyle(el: Element, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(\n    ables: Able[], methods: Array<keyof Able>,\n    triggerAblesSimultaneously?: boolean,\n) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (!triggerAblesSimultaneously && able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function equals(a1: any, a2: any) {\n    return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n    const length = values.length - 1;\n    for (let i = 0; i < length; ++i) {\n        const value = values[i];\n\n        if (!isUndefined(value)) {\n            return value;\n        }\n    }\n\n    return values[length];\n}\n\nexport function groupBy<T>(arr: T[], func: (el: T, index: number, arr: T[]) => any) {\n    const groups: T[][] = [];\n    const groupKeys: any[] = [];\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        const keyIndex = groupKeys.indexOf(groupKey);\n        const group = groups[keyIndex] || [];\n\n        if (keyIndex === -1) {\n            groupKeys.push(groupKey);\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function groupByMap<T>(arr: T[], func: (el: T, index: number, arr: T[]) => string | number) {\n    const groups: T[][] = [];\n    const groupKeys: IObject<T[]> = {};\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        let group = groupKeys[groupKey];\n\n        if (!group) {\n            group = [];\n            groupKeys[groupKey] = group;\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function flat<T>(arr: T[][]): T[] {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(cur);\n    }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n    return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(b) - Math.abs(a));\n\n    return args[0];\n}\nexport function minOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(a) - Math.abs(b));\n\n    return args[0];\n}\n\nexport function calculateInversePosition(matrix: number[], pos: number[], n: number) {\n    return calculate(\n        invert(matrix, n),\n        convertPositionMatrix(pos, n),\n        n,\n    );\n}\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n    const {\n        is3d,\n        rootMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n    [\n        e.distX, e.distY,\n    ] = calculateInversePosition(rootMatrix, [e.distX, e.distY], n);\n\n    return e;\n}\n\nexport function calculatePadding(\n    matrix: number[],\n    pos: number[],\n    transformOrigin: number[],\n    origin: number[],\n    n: number,\n) {\n    return minus(calculatePosition(matrix, plus(transformOrigin, pos), n), origin);\n}\n\nexport function convertCSSSize(value: number, size: number, isRelative?: boolean) {\n    return isRelative ? `${value / size * 100}%` : `${value}px`;\n}\n\nexport function getTinyDist(v: number) {\n    return Math.abs(v) <= TINY_NUM ? 0 : v;\n}\n\nexport function viewDraggingPrefix(ableName: string) {\n    return prefix(`${ableName}-view-dragging`);\n}\nexport function getDirectionViewClassName(ableName: string) {\n    return (moveable: MoveableManagerInterface) => {\n        if (!moveable.isDragging(ableName)) {\n            return \"\";\n        }\n        const data = getGestoData(moveable, ableName);\n        const deg = data.deg;\n        if (!deg) {\n            return \"\";\n        }\n        return prefix(`view-control-rotation${deg}`);\n    };\n}\nexport function getDirectionCondition(ableName: string, checkAbles: string[] = [ableName]) {\n    return (moveable: any, e: any) => {\n        if (e.isRequest) {\n            if (checkAbles.some(name => e.requestAble === name)) {\n                return e.parentDirection!;\n            } else {\n                return false;\n            }\n        }\n        const target = e.inputEvent.target;\n\n        return hasClass(target, prefix(\"direction\")) && (!ableName || hasClass(target, prefix(ableName)));\n    };\n}\n\nexport function invertObject<T extends IObject<any>>(obj: T): InvertObject<T> {\n    const nextObj: IObject<any> = {};\n\n    for (const name in obj) {\n        nextObj[obj[name]] = name;\n    }\n    return nextObj as any;\n}\n\nexport function convertTransformInfo(transforms: string[], index: number) {\n    const beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);\n    const beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);\n    const targetFunctionText = transforms[index] || \"\";\n    const afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\n    const afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\n\n    const beforeFunctions = parse(beforeFunctionTexts);\n    const beforeFunctions2 = parse(beforeFunctionTexts2);\n    const targetFunctions = parse([targetFunctionText]);\n    const afterFunctions = parse(afterFunctionTexts);\n    const afterFunctions2 = parse(afterFunctionTexts2);\n\n\n    const beforeFunctionMatrix = toMat(beforeFunctions);\n    const beforeFunctionMatrix2 = toMat(beforeFunctions2);\n    const afterFunctionMatrix = toMat(afterFunctions);\n    const afterFunctionMatrix2 = toMat(afterFunctions2);\n    const allFunctionMatrix = multiply(\n        beforeFunctionMatrix,\n        afterFunctionMatrix,\n        4,\n    );\n    return {\n        transforms,\n        beforeFunctionMatrix,\n        beforeFunctionMatrix2,\n        targetFunctionMatrix: toMat(targetFunctions),\n        afterFunctionMatrix,\n        afterFunctionMatrix2,\n        allFunctionMatrix,\n        beforeFunctions,\n        beforeFunctions2,\n        targetFunction: targetFunctions[0],\n        afterFunctions,\n        afterFunctions2,\n        beforeFunctionTexts,\n        beforeFunctionTexts2,\n        targetFunctionText,\n        afterFunctionTexts,\n        afterFunctionTexts2,\n    };\n}\n\nexport function isArrayFormat<T = any>(arr: any): arr is ArrayFormat<T> {\n    if (!arr || !isObject(arr)) {\n        return false;\n    }\n    if (arr instanceof Element) {\n        return false;\n    }\n    return isArray(arr) || \"length\" in arr;\n}\n\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>, isSelector: true): T | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>, isSelector?: boolean): T | string | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>,\n    isSelector?: boolean,\n): any {\n    if (!target) {\n        return null;\n    }\n    if (target instanceof Element) {\n        return target;\n    }\n    if (isString(target)) {\n        if (isSelector) {\n            return document.querySelector(target);\n        }\n        return target;\n    }\n    if (isFunction(target)) {\n        return target();\n    }\n    if (\"current\" in target) {\n        return target.current;\n    }\n    return target;\n}\n\nexport function getRefTargets(\n    targets: MoveableRefTargetType,\n    isSelector: true): Array<HTMLElement | SVGElement | null>;\nexport function getRefTargets(\n    targets: MoveableRefTargetType,\n    isSelector?: boolean): MoveableRefTargetsResultType;\nexport function getRefTargets(targets: MoveableRefTargetType, isSelector?: boolean): any[] {\n    if (!targets) {\n        return [];\n    }\n    const userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];\n\n    return userTargets.reduce((prev, target) => {\n        if (isString(target) && isSelector) {\n            return [...prev, ...[].slice.call(document.querySelectorAll<HTMLElement>(target))];\n        }\n        if (isArray(target)) {\n            prev.push(getRefTargets(target, isSelector));\n        } else {\n            prev.push(getRefTarget(target, isSelector));\n        }\n        return prev;\n    }, [] as MoveableRefTargetsResultType);\n}\n\nexport function minmax(...values: number[]) {\n    return [Math.min(...values), Math.max(...values)];\n}\n\n\nexport function getAbsoluteRotation(pos1: number[], pos2: number[], direction: number) {\n    let deg = getRad(pos1, pos2) / Math.PI * 180;\n\n    deg = direction >= 0 ? deg : 180 - deg;\n    deg = deg >= 0 ? deg : 360 + deg;\n\n    return deg;\n}\n\n\nexport function getDragDistByState(state: MoveableManagerState, dist: number[]) {\n    const {\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    let inverseMatrix = invert(rootMatrix, n);\n\n    if (!is3d) {\n        inverseMatrix = convertDimension(inverseMatrix, 3, 4);\n    }\n    inverseMatrix[12] = 0;\n    inverseMatrix[13] = 0;\n    inverseMatrix[14] = 0;\n\n    return calculateMatrixDist(inverseMatrix, dist);\n}\n\nexport function getSizeDistByDist(\n    startSize: number[],\n    dist: number[],\n    ratio: number,\n    direction: number[],\n    keepRatio?: boolean,\n) {\n    const [startOffsetWidth, startOffsetHeight] = startSize;\n    let distWidth = 0;\n    let distHeight = 0;\n\n    if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        const rad = getRad([0, 0], dist);\n        const standardRad = getRad([0, 0], direction);\n        const size = getDistSize(dist);\n        const signSize = Math.cos(rad - standardRad) * size;\n\n        if (!direction[0]) {\n            // top, bottom\n            distHeight = signSize;\n            distWidth = distHeight * ratio;\n        } else if (!direction[1]) {\n            // left, right\n            distWidth = signSize;\n            distHeight = distWidth / ratio;\n        } else {\n            // two-way\n            const startWidthSize = direction[0] * 2 * startOffsetWidth;\n            const startHeightSize = direction[1] * 2 * startOffsetHeight;\n            const distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]])\n                - getDistSize([startWidthSize, startHeightSize]);\n            const ratioRad = getRad([0, 0], [ratio, 1]);\n\n            distWidth = Math.cos(ratioRad) * distSize;\n            distHeight = Math.sin(ratioRad) * distSize;\n        }\n    } else {\n        distWidth = direction[0] * dist[0];\n        distHeight = direction[1] * dist[1];\n    }\n\n    return [distWidth, distHeight];\n}\nexport function getOffsetSizeDist(\n    sizeDirection: number[],\n    keepRatio: boolean,\n    datas: any,\n    e: any,\n) {\n    const {\n        ratio,\n        startOffsetWidth,\n        startOffsetHeight,\n    } = datas;\n    let distWidth = 0;\n    let distHeight = 0;\n    const {\n        distX,\n        distY,\n        parentDistance,\n        parentDist,\n        parentScale,\n    } = e;\n    const startFixedDirection = datas.fixedDirection;\n    const directionsDists = [0, 1].map(index => {\n        return Math.abs(sizeDirection[index] - startFixedDirection[index]);\n    });\n    const directionRatios = [0, 1].map(index => {\n        let dist = directionsDists[index];\n\n        if (dist !== 0) {\n            dist = 2 / dist;\n        }\n        return dist;\n    });\n    if (parentDist) {\n        distWidth = parentDist[0];\n        distHeight = parentDist[1];\n\n        if (keepRatio) {\n            if (!distWidth) {\n                distWidth = distHeight * ratio;\n            } else if (!distHeight) {\n                distHeight = distWidth / ratio;\n            }\n        }\n    } else if (parentScale) {\n        distWidth = (parentScale[0] - 1) * startOffsetWidth;\n        distHeight = (parentScale[1] - 1) * startOffsetHeight;\n    } else if (parentDistance) {\n        const scaleX = startOffsetWidth * directionsDists[0];\n        const scaleY = startOffsetHeight * directionsDists[1];\n        const ratioDistance = getDistSize([scaleX, scaleY]);\n\n        distWidth = parentDistance / ratioDistance * scaleX * directionRatios[0];\n        distHeight = parentDistance / ratioDistance * scaleY * directionRatios[1];\n    } else {\n        let dist = getDragDist({ datas, distX, distY });\n\n        dist = directionRatios.map((ratio, i) => {\n            return dist[i] * ratio;\n        });\n\n        [distWidth, distHeight] = getSizeDistByDist(\n            [startOffsetWidth, startOffsetHeight],\n            dist,\n            ratio,\n            sizeDirection,\n            keepRatio,\n        );\n    }\n    return {\n        // direction,\n        // sizeDirection,\n        distWidth,\n        distHeight,\n    };\n}\n\nexport function convertTransformUnit(\n    origin: string,\n    xy?: boolean,\n): { x?: string; y?: string; value?: string; } {\n    if (xy) {\n        if (origin === \"left\") {\n            return { x: \"0%\", y: \"50%\" };\n        } else if (origin === \"top\") {\n            return { x: \"50%\", y: \"50%\" };\n        } else if (origin === \"center\") {\n            return { x: \"50%\", y: \"50%\" };\n        } else if (origin === \"right\") {\n            return { x: \"100%\", y: \"50%\" };\n        } else if (origin === \"bottom\") {\n            return { x: \"50%\", y: \"100%\" };\n        }\n        const [left, right] = origin.split(\" \");\n        const leftOrigin = convertTransformUnit(left || \"\");\n        const rightOrigin = convertTransformUnit(right || \"\");\n        const originObject = {\n            ...leftOrigin,\n            ...rightOrigin,\n        };\n\n        const nextOriginObject = {\n            x: \"50%\",\n            y: \"50%\",\n        };\n        if (originObject.x) {\n            nextOriginObject.x = originObject.x;\n        }\n        if (originObject.y) {\n            nextOriginObject.y = originObject.y;\n        }\n        if (originObject.value) {\n            if (originObject.x && !originObject.y) {\n                nextOriginObject.y = originObject.value;\n            }\n            if (!originObject.x && originObject.y) {\n                nextOriginObject.x = originObject.value;\n            }\n        }\n        return nextOriginObject;\n    }\n    if (origin === \"left\") {\n        return { x: \"0%\" };\n    }\n    if (origin === \"right\") {\n        return { x: \"100%\" };\n    }\n    if (origin === \"top\") {\n        return { y: \"0%\" };\n    }\n    if (origin === \"bottom\") {\n        return { y: \"100%\" };\n    }\n    if (!origin) {\n        return {};\n    }\n    if (origin === \"center\") {\n        return { value: \"50%\" };\n    }\n    return { value: origin };\n}\nexport function convertTransformOriginArray(transformOrigin: string, width: number, height: number) {\n    const { x, y } = convertTransformUnit(transformOrigin, true);\n\n    return [\n        convertUnitSize(x!, width) || 0,\n        convertUnitSize(y!, height) || 0,\n    ];\n}\n\nexport function rotatePosesInfo(poses: number[][], origin: number[], rad: number) {\n    const prevPoses = poses.map((pos) => minus(pos, origin));\n    const nextPoses = prevPoses.map((pos) => rotate(pos, rad));\n\n    return {\n        prev: prevPoses,\n        next: nextPoses,\n        result: nextPoses.map(pos => plus(pos, origin)),\n    };\n}\n\n\n\nexport function isDeepArrayEquals(arr1: any[], arr2: any[]): boolean {\n    return arr1.length === arr2.length && arr1.every((value1, i) => {\n        const value2 = arr2[i];\n        const isArray1 = isArray(value1);\n        const isArray2 = isArray(value2);\n        if (isArray1 && isArray2) {\n            return isDeepArrayEquals(value1, value2);\n        } else if (!isArray1 && !isArray2) {\n            return value1 === value2;\n        }\n        return false;\n    });\n}\n","import { MoveableManagerInterface } from \"../types\";\n\nexport function getGestoData(moveable: MoveableManagerInterface, ableName: string) {\n    const targetGesto = moveable.targetGesto;\n    const controlGesto = moveable.controlGesto;\n    let data!: Record<string, any>;\n\n    if (targetGesto?.isFlag()) {\n        data = targetGesto.getEventData()[ableName];\n    }\n\n    if (!data && controlGesto?.isFlag()) {\n        data = controlGesto.getEventData()[ableName];\n    }\n\n    return data || {};\n}\n","import { makeAble } from \"./AbleManager\";\nimport { triggerEvent, fillParams, fillEndParams } from \"../utils\";\nimport {\n    PinchableProps, Able, SnappableState,\n    OnPinchStart, OnPinch, OnPinchEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\n\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\nexport default makeAble(\"pinchable\", {\n    events: {\n        onPinchStart: \"pinchStart\",\n        onPinch: \"pinch\",\n        onPinchEnd: \"pinchEnd\",\n        onPinchGroupStart: \"pinchGroupStart\",\n        onPinchGroup: \"pinchGroup\",\n        onPinchGroupEnd: \"pinchGroupEnd\",\n    } as const,\n    dragStart() {\n        return true;\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, targets, angle, originalDatas } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        pinchAbles.forEach(able => {\n            originalDatas[able.name] = originalDatas[able.name] || {};\n\n            if (!able[controlEventName]) {\n                return;\n            }\n            const ableEvent: any = {\n                ...e,\n                datas: originalDatas[able.name],\n                parentRotate: angle,\n                isPinch: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const {\n            datas, scale: pinchScale, distance,\n            originalDatas,\n            inputEvent, targets,\n            angle,\n        } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                datas: originalDatas[able.name],\n                inputEvent,\n                parentDistance,\n                parentRotate: angle,\n                isPinch: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, isPinch, inputEvent, targets, originalDatas } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillEndParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                isDrag: isPinch,\n                datas: originalDatas[able.name],\n                inputEvent,\n                isPinch: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        return this.pinchStart!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.pinch!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.pinchEnd!(moveable, { ...e, targets: moveable.props.targets });\n    },\n});\n\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n","import { Able, MoveableGroupInterface, MoveableManagerInterface, MoveableManagerState } from \"./types\";\nimport CustomGesto, { setCustomDrag } from \"./gesto/CustomGesto\";\n\nexport function fillChildEvents(\n    moveable: MoveableGroupInterface<any, any>,\n    name: string,\n    e: any,\n): any[] {\n    const datas = e.originalDatas;\n\n    datas.groupable = datas.groupable || {};\n\n    const groupableDatas = datas.groupable;\n\n    groupableDatas.childDatas = groupableDatas.childDatas || [];\n\n    const childDatas = groupableDatas.childDatas;\n\n    return moveable.moveables.map((_, i) => {\n        childDatas[i] = childDatas[i] || {};\n        childDatas[i][name] = childDatas[i][name] || {};\n\n        return {\n            ...e,\n            datas: childDatas[i][name],\n            originalDatas: childDatas[i],\n        };\n    });\n}\nexport function triggerChildGesto(\n    moveable: MoveableGroupInterface<any, any>,\n    able: Able,\n    type: string,\n    delta: number[],\n    e: any,\n    isConvert: boolean,\n    ableName: string,\n) {\n    const isStart = !!type.match(/Start$/g);\n    const isEnd = !!type.match(/End$/g);\n    const isPinch = e.isPinch;\n    const datas = e.datas;\n    const events = fillChildEvents(moveable, able.name, e);\n    const moveables = moveable.moveables;\n    const childs = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        const state = childMoveable.state as MoveableManagerState<any>;\n        const gestos = state.gestos;\n        let childEvent: any = ev;\n\n        if (isStart) {\n            childEvent = new CustomGesto(ableName).dragStart(delta, ev);\n        } else {\n\n\n            if (!gestos[ableName]) {\n                gestos[ableName] = datas.childGestos[i];\n            }\n            if (!gestos[ableName]) {\n                return;\n            }\n            childEvent = setCustomDrag(ev, state, delta, isPinch, isConvert, ableName);\n        }\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        if (isEnd) {\n            gestos[ableName] = null;\n        }\n        return result;\n    });\n    if (isStart) {\n        datas.childGestos = moveables.map(child => child.state.gestos[ableName]);\n    }\n    return childs;\n}\nexport function triggerChildAbles<T extends Able>(\n    moveable: MoveableGroupInterface<any, any>,\n    able: T,\n    type: keyof T & string,\n    e: any,\n    eachEvent: (movebale: MoveableManagerInterface<any, any>, ev: any) => any = (_, ev) => ev,\n    callback?: (moveable: MoveableManagerInterface<any, any>, ev: any, result: any, index: number) => any,\n) {\n    const isEnd = !!type.match(/End$/g);\n    const events = fillChildEvents(moveable, able.name, e);\n    const moveables = moveable.moveables;\n    const childs = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        let childEvent = ev;\n\n        childEvent = eachEvent(childMoveable, ev);\n\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        result && callback && callback(childMoveable, ev, result, i);\n\n        if (isEnd) {\n            childMoveable.state.gestos = {};\n        }\n        return result;\n    });\n\n    return childs;\n}\n","import { TINY_NUM } from \"@daybrush/utils\";\nimport { throttle } from \"@daybrush/utils\";\nimport {\n    MoveableClientRect, MoveableManagerInterface,\n    SnapDirectionPoses,\n    SnapDirections, SnappableProps,\n    SnappableState,\n} from \"../../types\";\nimport {\n    calculatePosition,\n} from \"../../utils\";\nexport const VERTICAL_NAMES = [\"left\", \"right\", \"center\"] as const;\nexport const HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"] as const;\nexport const VERTICAL_NAMES_MAP = {\n    start: \"left\",\n    end: \"right\",\n    center: \"center\",\n} as const;\nexport const HORIZONTAL_NAMES_MAP = {\n    start: \"top\",\n    end: \"bottom\",\n    center: \"middle\",\n} as const;\n\n\nexport function hasGuidelines(\n    moveable: MoveableManagerInterface<any, any>,\n    ableName: string\n): moveable is MoveableManagerInterface<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            innerBounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n            snapGridWidth,\n            snapGridHeight,\n        },\n        state: { guidelines, enableSnap },\n    } = moveable;\n\n    if (\n        !snappable ||\n        !enableSnap ||\n        (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        snapGridWidth ||\n        snapGridHeight ||\n        bounds ||\n        innerBounds ||\n        (guidelines && guidelines.length) ||\n        (verticalGuidelines && verticalGuidelines.length) ||\n        (horizontalGuidelines && horizontalGuidelines.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function getSnapDirections(snapDirections: SnapDirections | boolean | undefined): SnapDirections {\n    if (snapDirections === false) {\n        return {};\n    } else if (snapDirections === true || !snapDirections) {\n        return { left: true, right: true, top: true, bottom: true };\n    }\n    return snapDirections;\n}\n\nexport function mapSnapDirectionPoses(\n    snapDirections: SnapDirections | boolean | undefined,\n    snapPoses: SnapDirectionPoses,\n) {\n    const nextSnapDirections = getSnapDirections(snapDirections);\n    const nextSnapPoses: SnapDirectionPoses = {};\n\n    for (const name in nextSnapDirections) {\n        if (name in snapPoses && (nextSnapDirections as any)[name]) {\n            (nextSnapPoses as any)[name] = (snapPoses as any)[name];\n        }\n    }\n    return nextSnapPoses;\n}\n\nexport function splitSnapDirectionPoses(\n    snapDirections: SnapDirections | boolean | undefined,\n    snapPoses: SnapDirectionPoses,\n) {\n    const nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);\n    const horizontalNames = HORIZONTAL_NAMES.filter(name => name in nextSnapPoses);\n    const verticalNames = VERTICAL_NAMES.filter(name => name in nextSnapPoses);\n\n    return {\n        horizontal: horizontalNames.map(name => nextSnapPoses[name]!),\n        vertical: verticalNames.map(name => nextSnapPoses[name]!),\n    };\n}\n\nexport function calculateContainerPos(\n    rootMatrix: number[],\n    containerRect: MoveableClientRect,\n    n: number,\n) {\n    const clientPos = calculatePosition(\n        rootMatrix, [containerRect.clientLeft!, containerRect.clientTop!], n);\n\n    return [\n        containerRect.left + clientPos[0],\n        containerRect.top + clientPos[1],\n    ];\n}\n\nexport function solveLineConstants([point1, point2]: number[][]): [number, number, number] {\n    let dx = point2[0] - point1[0];\n    let dy = point2[1] - point1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n\n    // b > 0\n    // ax + by + c = 0\n    let a = 0;\n    let b = 0;\n    let c = 0;\n\n    if (!dx) {\n        // -x + 1 = 0\n        a = -1;\n        c = point1[0];\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -point1[1];\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = a * point1[0] - point1[1];\n    }\n\n    return [a, b, c].map(v => throttle(v, TINY_NUM)) as [number, number, number];\n}\n","import {\n    SnapInfo, SnappableProps, SnappableState,\n    SnapGuideline, ResizableProps, ScalableProps,\n    SnapOffsetInfo, MoveableManagerInterface, SnapDirectionPoses,\n} from \"../../types\";\nimport {\n    selectValue, getTinyDist,\n} from \"../../utils\";\nimport { getPosByDirection, getPosesByDirection } from \"../../gesto/GestoUtils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"@scena/matrix\";\nimport { splitSnapDirectionPoses } from \"./utils\";\n\n\n\nexport function checkMoveableSnapPoses(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    customSnapThreshold?: number,\n) {\n    const props = moveable.props;\n    const snapThreshold = selectValue<number>(customSnapThreshold, props.snapThreshold, 5);\n\n    return checkSnapPoses(\n        moveable.state.guidelines,\n        posesX,\n        posesY,\n        snapThreshold,\n    );\n}\n\nexport function checkSnapPoses(\n    guidelines: SnapGuideline[],\n    posesX: number[],\n    posesY: number[],\n    snapThreshold: number,\n) {\n    return {\n        vertical: checkSnap(guidelines, \"vertical\", posesX, snapThreshold),\n        horizontal: checkSnap(guidelines, \"horizontal\", posesY, snapThreshold),\n    };\n}\nexport function checkSnapKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n): { vertical: SnapOffsetInfo, horizontal: SnapOffsetInfo } {\n    const [endX, endY] = endPos;\n    const [startX, startY] = startPos;\n    let [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    dx = getTinyDist(dx);\n    dy = getTinyDist(dy);\n\n    const verticalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    }\n    const {\n        vertical: verticalSnapInfo,\n        horizontal: horizontalSnapInfo,\n    } = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []);\n\n    verticalSnapInfo.posInfos.filter(({ pos }) => {\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(({ pos }) => {\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n    const {\n        isSnap: isVerticalSnap,\n        guideline: verticalGuideline,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n    const {\n        isSnap: isHorizontalSnap,\n        guideline: horizontalGuideline,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n    const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline!.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isSnap = false;\n\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\n\nexport function checkSnaps(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    rect: SnapDirectionPoses,\n    customSnapThreshold?: number,\n) {\n    const poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);\n\n    return checkMoveableSnapPoses(\n        moveable,\n        poses.vertical,\n        poses.horizontal,\n        customSnapThreshold,\n    );\n}\n\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\n\nfunction checkSnap(\n    guidelines: SnapGuideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    snapThreshold: number,\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            index: -1,\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map((targetPos, index) => {\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: Math.abs(offset),\n                guideline,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type } = guideline;\n            if (\n                type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n\n        return {\n            pos: targetPos,\n            index,\n            guidelineInfos,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    const isSnap = snapPosInfos.length > 0;\n    return {\n        isSnap,\n        index: isSnap ? snapPosInfos[0].index : -1,\n        posInfos: snapPosInfos,\n    };\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManagerInterface<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    poses: number[][],\n    snapDirection: number[],\n    snapThreshold = 1,\n) {\n    let nextPoses: number[][] = [];\n    if (snapDirection[0] && snapDirection[1]) {\n        nextPoses = [\n            snapDirection,\n            [-snapDirection[0], snapDirection[1]],\n            [snapDirection[0], -snapDirection[1]],\n        ].map(direction => getPosByDirection(poses, direction));\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            nextPoses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n    } else {\n        if (moveable.props.keepRatio) {\n            nextPoses = [\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1],\n                snapDirection,\n            ].map(dir => getPosByDirection(poses, dir));\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n    }\n    return checkMoveableSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), snapThreshold);\n}\n\nexport function checkSnapBoundPriority(\n    a: { isBound: boolean, isSnap: boolean, offset: number },\n    b: { isBound: boolean, isSnap: boolean, offset: number },\n) {\n    const aDist = Math.abs(a.offset);\n    const bDist = Math.abs(b.offset);\n\n    if (a.isBound && b.isBound) {\n        return bDist - aDist;\n    } else if (a.isBound) {\n        return -1;\n    } else if (b.isBound) {\n        return 1;\n    } else if (a.isSnap && b.isSnap) {\n        return bDist - aDist;\n    } else if (a.isSnap) {\n        return -1;\n    } else if (b.isSnap) {\n        return 1;\n    } else if (aDist < TINY_NUM) {\n        return 1;\n    } else if (bDist < TINY_NUM) {\n        return -1;\n    }\n    return aDist - bDist;\n}\nexport function getNearOffsetInfo<T extends { offset: number[], isBound: boolean, isSnap: boolean, sign: number[] }>(\n    offsets: T[],\n    index: number,\n) {\n    return offsets.slice().sort((a, b) => {\n        const aSign = a.sign[index];\n        const bSign = b.sign[index];\n        const aOffset = a.offset[index];\n        const bOffset = b.offset[index];\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        }\n        return checkSnapBoundPriority(\n            { isBound: a.isBound, isSnap: a.isSnap, offset: aOffset },\n            { isBound: b.isBound, isSnap: b.isSnap, offset: bOffset },\n        );\n    })[0];\n}\n\n\nexport function getCheckSnapDirections(\n    direction: number[],\n    fixedDirection: number[],\n    keepRatio: boolean\n) {\n    const directions: number[][][] = [];\n    // const fixedDirection = [-direction[0], -direction[1]];\n\n    if (keepRatio) {\n        if (Math.abs(fixedDirection[0]) !== 1 || Math.abs(fixedDirection[1]) !== 1) {\n            directions.push(\n                [fixedDirection, [-1, -1]],\n                [fixedDirection, [-1, 1]],\n                [fixedDirection, [1, -1]],\n                [fixedDirection, [1, 1]],\n            );\n        } else {\n            directions.push(\n                [fixedDirection, [direction[0], -direction[1]]],\n                [fixedDirection, [-direction[0], direction[1]]],\n            );\n        }\n        directions.push([fixedDirection, direction]);\n    } else {\n        if ((direction[0] && direction[1]) || (!direction[0] && !direction[1])) {\n            const endDirection = direction[0] ? direction : [1, 1];\n\n            [1, -1].forEach(signX => {\n                [1, -1].forEach(signY => {\n                    const nextDirection = [signX * endDirection[0], signY * endDirection[1]];\n\n                    if (\n                        fixedDirection[0] === nextDirection[0]\n                        && fixedDirection[1] === nextDirection[1]\n                    ) {\n                        return;\n                    }\n                    directions.push([fixedDirection, nextDirection]);\n                });\n            });\n        } else if (direction[0]) {\n            const signs = Math.abs(fixedDirection[0]) === 1 ? [1] : [1, -1];\n\n            signs.forEach(sign => {\n                directions.push(\n                    [\n                        [fixedDirection[0], -1],\n                        [sign * direction[0], -1],\n                    ],\n                    [\n                        [fixedDirection[0], 0],\n                        [sign * direction[0], 0],\n                    ],\n                    [\n                        [fixedDirection[0], 1],\n                        [sign * direction[0], 1],\n                    ]\n                );\n            });\n        } else if (direction[1]) {\n            const signs = Math.abs(fixedDirection[1]) === 1 ? [1] : [1, -1];\n\n            signs.forEach(sign => {\n                directions.push(\n                    [\n                        [-1, fixedDirection[1]],\n                        [-1, sign * direction[1]],\n                    ],\n                    [\n                        [0, fixedDirection[1]],\n                        [0, sign * direction[1]],\n                    ],\n                    [\n                        [1, fixedDirection[1]],\n                        [1, sign * direction[1]],\n                    ]\n                );\n            });\n        }\n    }\n    return directions;\n}\n","import { average, getRad, throttle } from \"@daybrush/utils\";\nimport { rotate } from \"@scena/matrix\";\nimport { maxOffset, getDistSize, getTinyDist, calculatePoses } from \"../../utils\";\n\nimport { SnappableProps, DraggableProps, RotatableProps, MoveableManagerInterface } from \"../../types\";\nimport { getDragDist, getPosByDirection, getInverseDragDist } from \"../../gesto/GestoUtils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\nimport { solveLineConstants } from \"./utils\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n    // l    o     => true\n    // o    l    => false\n    const cx = average([line[0][0], line[1][0]]);\n    const cy = average([line[0][1], line[1][1]]);\n\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1],\n    };\n}\nfunction hitTestLine(\n    dot: number[],\n    [pos1, pos2]: number[][],\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    let test1: number;\n    let test2: number;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        const a = dy / dx;\n\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots: number[][], line: number[][], centerSign: boolean, error: number = TINY_NUM) {\n    return dots.every(dot => {\n        const value = hitTestLine(dot, line);\n        const sign = value <= 0;\n        return sign === centerSign || Math.abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(\n    pos: number,\n    start: number,\n    end: number,\n    isStart: boolean,\n    threshold = 0,\n) {\n    if (\n        (isStart && start - threshold <= pos)\n        || (!isStart && pos <= end + threshold)\n    ) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos,\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\n\nfunction checkInnerBound(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    { line, centerSign, verticalSign, horizontalSign, lineConstants }: InnerBoundLineInfo,\n) {\n    const bounds = moveable.props.innerBounds;\n\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    const { left, top, width, height } = bounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n\n    if (isSameStartLine([\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n    ], line, centerSign)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    // test vertical\n\n    const topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, verticalSign);\n    const bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, verticalSign);\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, horizontalSign);\n    const rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, horizontalSign);\n\n    const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    const horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n    let offset = [0, 0];\n    let isBound = false;\n    let isAllBound = false;\n\n    if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n        offset = [verticalOffset, 0];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [0, horizontalOffset];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound,\n        isVerticalBound,\n        isHorizontalBound,\n        isBound,\n        offset,\n    };\n}\n\nfunction checkLineBoundCollision(\n    line: number[][],\n    [a, b]: [number, number, number],\n    boundLine: number[][],\n    isStart: boolean,\n    threshold?: number,\n    isRender?: boolean,\n) {\n    const dot1 = line[0];\n    // const dot2 = line[1];\n    const boundDot1 = boundLine[0];\n    const boundDot2 = boundLine[1];\n\n    // const dy1 = getTinyDist(dot2[1] - dot1[1]);\n    // const dx1 = getTinyDist(dot2[0] - dot1[0]);\n    const dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n    const dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n\n    const hasDx = b;\n    const hasDy = a;\n    const slope = - a / b;\n    // lineConstants\n    // ax + by + c = 0\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        // by + c = 0\n        if (isRender && !hasDy) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (hasDx) {\n            // ax + by + c = 0\n            // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n            const y = slope * (boundDot1[0] - dot1[0]) + dot1[1];\n\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        } else {\n            // ax + c = 0\n            const offset = boundDot1[0] - dot1[0];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    } else if (!dy2) {\n        // horizontal\n        if (isRender && !hasDx) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (hasDy) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            // const a = dy1 / dx1;\n            // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n            const x = (boundDot1[1] - dot1[1]) / slope + dot1[0];\n\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        } else {\n            const offset = boundDot1[1] - dot1[1];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\nexport function getInnerBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    lineInfos: InnerBoundLineInfo[],\n    datas: any,\n) {\n    return lineInfos.map(info => {\n        const {\n            isBound,\n            offset,\n            isVerticalBound,\n            isHorizontalBound,\n        } = checkInnerBound(moveable, info);\n\n        const multiple = info.multiple;\n\n        const sizeOffset = getDragDist({\n            datas,\n            distX: offset[0],\n            distY: offset[1],\n        }).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound,\n            isVerticalBound,\n            isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset,\n        };\n    });\n}\n\nexport function getInnerBoundDragInfo(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    poses: number[][],\n    datas: any,\n) {\n    const lines = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false).map(info => {\n        return {\n            ...info,\n            multiple: info.multiple.map(dir => Math.abs(dir) * 2),\n        };\n    });\n    const innerBoundInfo = getInnerBoundInfo(moveable, lines, datas);\n    const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    let verticalOffset = 0;\n    let horizontalOffset = 0;\n    const isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    const isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n    if (isVerticalBound || isHorizontalBound) {\n        [verticalOffset, horizontalOffset] = getInverseDragDist({\n            datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1],\n        });\n    }\n\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset,\n        },\n    };\n}\nexport function getCheckSnapLineDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const lineDirections: number[][][] = [];\n    const x = direction[0];\n    const y = direction[1];\n    if (x && y) {\n        lineDirections.push(\n            [[0, y * 2], direction, [-x, y]],\n            [[x * 2, 0], direction, [x, -y]],\n        );\n    } else if (x) {\n        // vertcal\n        lineDirections.push(\n            [[x * 2, 0], [x, 1], [x, -1]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[0, -1], [x, -1], [-x, -1]],\n                [[0, 1], [x, 1], [-x, 1]],\n            );\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push(\n            [[0, y * 2], [1, y], [-1, y]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[-1, 0], [-1, y], [-1, -y]],\n                [[1, 0], [1, y], [1, -y]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push(\n            [[-1, 0], [-1, -1], [-1, 1]],\n            [[1, 0], [1, -1], [1, 1]],\n            [[0, -1], [-1, -1], [1, -1]],\n            [[0, 1], [-1, 1], [1, 1]],\n        );\n    }\n\n    return lineDirections;\n}\nexport interface InnerBoundLineInfo {\n    line: number[][];\n    multiple: number[];\n    horizontalSign: boolean;\n    verticalSign: boolean;\n    centerSign: boolean;\n    lineConstants: [number, number, number];\n}\nexport function getCheckInnerBoundLineInfos(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n): InnerBoundLineInfo[] {\n    const {\n        allMatrix,\n        is3d,\n    } = moveable.state;\n    const virtualPoses = calculatePoses(allMatrix, 100, 100, is3d ? 4 : 3);\n    const center = getPosByDirection(virtualPoses, [0, 0]);\n\n    return getCheckSnapLineDirections(direction, keepRatio).map(([multiple, dir1, dir2]) => {\n        const virtualLine = [\n            getPosByDirection(virtualPoses, dir1),\n            getPosByDirection(virtualPoses, dir2),\n        ];\n        const lineConstants = solveLineConstants(virtualLine);\n        const {\n            vertical: verticalSign,\n            horizontal: horizontalSign,\n        } = isStartLine(center, virtualLine);\n        const centerSign = hitTestLine(center, virtualLine) <= 0;\n\n        return {\n            multiple,\n            centerSign,\n            verticalSign,\n            horizontalSign,\n            lineConstants,\n            line: [\n                getPosByDirection(poses, dir1),\n                getPosByDirection(poses, dir2),\n            ],\n        };\n    });\n}\n\nfunction isBoundRotate(\n    relativePoses: number[][],\n    boundDots: number[][],\n    center: number[],\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n    return [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].some(line => {\n        const centerSign = hitTestLine(center, line) <= 0;\n\n        return !isSameStartLine(boundDots, line, centerSign);\n    });\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return Math.abs(pos1[0]);\n    }\n    if (!dy) {\n        return Math.abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n\n    const a = dy / dx;\n\n    return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return [pos1[0], 0];\n    }\n    if (!dy) {\n        return [0, pos1[1]];\n    }\n    const a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    const b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n\n    return [\n        -b / (a + 1 / a),\n        b / ((a * a) + 1),\n    ];\n}\nexport function checkRotateInnerBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.innerBounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left,\n        top,\n        width,\n        height,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = left + width - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = top + height - origin[1];\n    const dots = [\n        [relativeLeft, relativeTop],\n        [relativeRight, relativeTop],\n        [relativeLeft, relativeBottom],\n        [relativeRight, relativeBottom],\n    ];\n    const center = getPosByDirection(nextPoses, [0, 0]);\n\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    const dotInfos = dots.map(dot => [\n        getDistSize(dot),\n        getRad([0, 0], dot),\n    ]);\n    [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].forEach(line => {\n        const lineRad = getRad([0, 0], solveReverseLine(line));\n        const lineDist = getDistPointLine(line);\n\n        result.push(...dotInfos\n            .filter(([dotDist]) => {\n                return dotDist && lineDist <= dotDist;\n            })\n            .map(([dotDist, dotRad]) => {\n                const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n                const nextRad1 = dotRad + distRad;\n                const nextRad2 = dotRad - distRad;\n\n                return [\n                    rad + nextRad1 - lineRad,\n                    rad + nextRad2 - lineRad,\n                ];\n            })\n            .reduce((prev, cur) => {\n                prev.push(...cur);\n                return prev;\n            }, [])\n            .filter(nextRad => !isBoundRotate(prevPoses, dots, center, nextRad))\n            .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n    });\n    return result;\n}\n\nexport function checkInnerBoundPoses(\n    moveable: MoveableManagerInterface<SnappableProps>,\n) {\n    const innerBounds = moveable.props.innerBounds;\n\n    if (!innerBounds) {\n        return {\n            vertical: [],\n            horizontal: [],\n        };\n    }\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = moveable.getRect();\n    const poses = [pos1, pos2, pos3, pos4];\n    const center = getPosByDirection(poses, [0, 0]);\n    const { left, top, width, height } = innerBounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n    const lineInfos = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false);\n\n    const horizontalPoses: number[] = [];\n    const verticalPoses: number[] = [];\n\n    const boundMap = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false,\n    };\n\n    lineInfos.forEach(lineInfo => {\n        const { line, lineConstants } = lineInfo;\n        const {\n            horizontal: isHorizontalStart,\n            vertical: isVerticalStart,\n        } = isStartLine(center, line);\n\n        // test vertical\n        const topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, isVerticalStart, 1, true);\n        const bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, isVerticalStart, 1, true);\n\n        // test horizontal\n        const leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, isHorizontalStart, 1, true);\n        const rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, isHorizontalStart, 1, true);\n\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n\n    return {\n        horizontal: horizontalPoses,\n        vertical: verticalPoses,\n    };\n}\n","import { getRad, throttle } from \"@daybrush/utils\";\nimport {\n    BoundInfo, SnappableProps, BoundType,\n    RotatableProps, MoveableManagerInterface, SnappableState,\n} from \"../../types\";\nimport { rotate, minus } from \"@scena/matrix\";\nimport { getDistSize } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n    bounds: BoundType | false | undefined,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n) {\n    const {\n        position = \"client\",\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds || {};\n    const nextBounds = {\n        position,\n        left,\n        top,\n        right,\n        bottom,\n    };\n\n    return {\n        vertical: checkBounds(nextBounds, verticalPoses, true),\n        horizontal: checkBounds(nextBounds, horizontalPoses, false),\n    };\n}\nexport function getBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    externalBounds?: BoundType | false | null,\n) {\n    const {\n        containerClientRect: {\n            clientHeight: containerHeight,\n            clientWidth: containerWidth,\n            clientLeft,\n            clientTop,\n        },\n        snapOffset: {\n            left: snapOffsetLeft,\n            top: snapOffsetTop,\n            right: snapOffsetRight,\n            bottom: snapOffsetBottom,\n        },\n    } = moveable.state;\n    const bounds = externalBounds || moveable.props.bounds || {} as BoundType;\n    const position = bounds.position || \"client\";\n    const isCSS = position === \"css\";\n    const {\n        left = -Infinity,\n        top = -Infinity,\n    } = bounds;\n    let {\n        right = isCSS ? -Infinity : Infinity,\n        bottom = isCSS ? -Infinity : Infinity,\n    } = bounds;\n\n    if (isCSS) {\n        right = containerWidth! + snapOffsetRight - snapOffsetLeft - right;\n        bottom = containerHeight! + snapOffsetBottom - snapOffsetTop - bottom;\n    }\n\n    return {\n        left: left + snapOffsetLeft - clientLeft!,\n        right: right + snapOffsetLeft - clientLeft!,\n        top: top + snapOffsetTop - clientTop!,\n        bottom: bottom + snapOffsetTop - clientTop!,\n    };\n}\nexport function checkBoundKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const [endX, endY] = endPos;\n    let [dx, dy] = minus(endPos, startPos);\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isBound = false;\n\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        }\n        if (isBound) {\n            if (y < top || y > bottom) {\n                isBound = false;\n            }\n        }\n        if (!isBound) {\n            if (isBottom && bottom <= endY) {\n                y = bottom;\n                x = (y - b) / a;\n                isBound = true;\n            } else if (!isBottom &&  endY <= top) {\n                y = top;\n                x = (y - b) / a;\n                isBound = true;\n            }\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\nfunction checkBounds(\n    bounds: Required<BoundType>,\n    poses: number[],\n    isVertical: boolean,\n): BoundInfo[] {\n    // 0   [100 - 200]  300\n    const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n    // 450\n    const minPos = Math.min(...poses);\n    const maxPos = Math.max(...poses);\n    const boundInfos: BoundInfo[] = [];\n\n    if (startBoundPos + 1 > minPos) {\n        boundInfos.push({\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos,\n        });\n    }\n    if (endBoundPos - 1 < maxPos) {\n        boundInfos.push({\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos,\n        });\n    }\n\n    if (!boundInfos.length) {\n        boundInfos.push({\n            isBound: false,\n            offset: 0,\n            pos: 0,\n        });\n    }\n\n    return boundInfos.sort((a, b) => Math.abs(b.offset) - Math.abs(a.offset));\n}\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n\n    return nextPoses.some(pos => {\n        return (pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1)\n            || (pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1)\n            || (pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1)\n            || (pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, SnappableState>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    if (!moveable.props.bounds) {\n        return [];\n    }\n    const rad = rotation * Math.PI / 180;\n\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    [\n        [relativeLeft, 0],\n        [relativeRight, 0],\n        [relativeTop, 1],\n        [relativeBottom, 1],\n    ].forEach(([boundPos, index]) => {\n        nextPoses.forEach(nextPos => {\n            const relativeRad1 = getRad([0, 0], nextPos);\n\n            result.push(...boundRotate(nextPos, boundPos, index)\n                .map(relativeRad2 => rad + relativeRad2 - relativeRad1)\n                .filter(nextRad => !isBoundRotate(prevPoses, boundRect, nextRad))\n                .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n        });\n    });\n\n    return result;\n}\n","import { throttle } from \"@daybrush/utils\";\nimport {\n    RenderGuidelineInfo, Renderer, RenderGuidelineInnerInfo,\n    MoveableManagerInterface, SnappableProps, SnapGuideline,\n    SnappableRenderType, SnappableState,\n    SnapDirectionPoses,\n} from \"../../types\";\nimport { prefix, groupBy } from \"../../utils\";\nimport { HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP } from \"./utils\";\n\nexport function renderGuideline(info: RenderGuidelineInfo, React: Renderer): any {\n    const { direction, classNames, size, pos, zoom, key } = info;\n    const isHorizontal = direction === \"horizontal\";\n    const scaleType = isHorizontal ? \"Y\" : \"X\";\n    // const scaleType2 = isHorizontal ? \"Y\" : \"X\";\n\n    return React.createElement(\"div\", {\n        key,\n        className: classNames.join(\" \"),\n        style: {\n            [isHorizontal ? \"width\" : \"height\"]: `${size}`,\n            transform: `translate(${pos[0]}, ${pos[1]}) translate${scaleType}(-50%) scale${scaleType}(${zoom})`,\n        },\n    });\n}\n\nexport function renderInnerGuideline(info: RenderGuidelineInnerInfo, React: Renderer): any {\n    return renderGuideline({\n        ...info,\n        classNames: [\n            prefix(\"line\", \"guideline\", info.direction),\n            ...info.classNames,\n        ].filter(className => className) as string[],\n        size: info.size || `${info.sizeValue}px`,\n        pos: info.pos || info.posValue.map(v => `${throttle(v, 0.1)}px`),\n    }, React);\n}\n\nexport function renderSnapPoses(\n    moveable: MoveableManagerInterface,\n    direction: string,\n    snapPoses: SnappableRenderType[],\n    minPos: number,\n    targetPos: number,\n    size: number,\n    index: number,\n    React: Renderer\n) {\n    const { zoom } = moveable.props;\n    return snapPoses.map(({ type, pos }, i) => {\n        const renderPos = [0, 0];\n\n        renderPos[index] = minPos;\n        renderPos[index ? 0 : 1] = -targetPos + pos;\n\n        return renderInnerGuideline(\n            {\n                key: `${direction}TargetGuideline${i}`,\n                classNames: [prefix(\"target\", \"bold\", type)],\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n                direction: direction,\n            },\n            React\n        );\n    });\n}\nexport function renderGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    type: \"vertical\" | \"horizontal\",\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: Renderer\n): any[] {\n    const { zoom, isDisplayInnerSnapDigit } = moveable.props;\n\n    const mainNames = type === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[mainNames.start]!;\n    const targetEnd = targetRect[mainNames.end]!;\n    return guidelines.filter(({ hide, elementRect }) => {\n        if (hide) {\n            return false;\n        }\n        if (isDisplayInnerSnapDigit && elementRect) {\n            // inner\n            const rect = elementRect.rect;\n\n            if (rect[mainNames.start]! <= targetStart && targetEnd <= rect[mainNames.end]!) {\n                return false;\n            }\n        }\n        return true;\n    }).map((guideline, i) => {\n        const { pos, size, element, className } = guideline;\n\n        const renderPos = [\n            -targetPos[0] + pos[0],\n            -targetPos[1] + pos[1],\n        ];\n\n        return renderInnerGuideline(\n            {\n                key: `${type}-default-guideline-${i}`,\n                classNames: element ? [prefix(\"bold\"), className] : [prefix(\"normal\"), className],\n                direction: type,\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n            },\n            React\n        );\n    });\n}\n\nexport function renderDigitLine(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    type: \"vertical\" | \"horizontal\",\n    lineType: \"dashed\" | \"gap\",\n    index: number,\n    gap: number,\n    renderPos: number[],\n    className: string | undefined,\n    React: Renderer,\n): any {\n    const {\n        snapDigit = 0,\n        isDisplaySnapDigit = true,\n        snapDistFormat = (v: number, type: \"vertical\" | \"horizontal\") => {\n            // Type can be used render different values.\n            if (type === 'vertical') {\n                return v;\n            }\n            return v;\n        },\n        zoom,\n    } = moveable.props;\n    const scaleType = type === \"horizontal\" ? \"X\" : \"Y\";\n    const sizeName = type === \"vertical\" ? \"height\" : \"width\";\n    const absGap = Math.abs(gap!);\n    const snapSize = isDisplaySnapDigit\n        ? parseFloat(absGap.toFixed(snapDigit))\n        : 0;\n    return <div\n        key={`${type}-${lineType}-guideline-${index}`}\n        className={prefix(\"guideline-group\", type)}\n        style={{\n            left: `${renderPos[0]}px`,\n            top: `${renderPos[1]}px`,\n            [sizeName]: `${absGap}px`,\n        }}\n    >\n        {renderInnerGuideline(\n            {\n                direction: type,\n                classNames: [prefix(lineType), className],\n                size: \"100%\",\n                posValue: [0, 0],\n                sizeValue: absGap,\n                zoom: zoom!,\n            },\n            React\n        )}\n        <div\n            className={prefix(\"size-value\", \"gap\")}\n            style={{\n                transform: `translate${scaleType}(-50%) scale(${zoom})`,\n            }}\n        >\n            {snapSize > 0 ? snapDistFormat(snapSize, type) : \"\"}\n        </div>\n    </div>;\n}\n\nexport function groupByElementGuidelines(\n    type: \"vertical\" | \"horizontal\",\n    guidelines: SnapGuideline[],\n    targetRect: SnapDirectionPoses,\n    isDisplayInnerSnapDigit: boolean,\n) {\n    const index = type === \"vertical\" ? 0 : 1;\n    const otherIndex = type === \"vertical\" ? 1 : 0;\n    const names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[names.start]!;\n    const targetEnd = targetRect[names.end]!;\n    return groupBy(guidelines, (guideline) => {\n        return guideline.pos[index];\n    }).map(nextGuidelines => {\n        const start: SnapGuideline[] = [];\n        const end: SnapGuideline[] = [];\n        const inner: SnapGuideline[] = [];\n\n        nextGuidelines.forEach(guideline => {\n            const element = guideline.element!;\n            const rect = guideline.elementRect!.rect;\n            if (rect[names.end]! < targetStart) {\n                start.push(guideline);\n            } else if (targetEnd < rect[names.start]!) {\n                end.push(guideline);\n            } else if (rect[names.start]! <= targetStart && targetEnd <= rect[names.end]! && isDisplayInnerSnapDigit) {\n                const pos = guideline.pos;\n                const elementRect1 = { element, rect: { ...rect, [names.end]: rect[names.start]! } };\n                const elementRect2 = { element, rect: { ...rect, [names.start]: rect[names.end]! } };\n                const nextPos1 = [0, 0];\n                const nextPos2 = [0, 0];\n                nextPos1[index] = pos[index];\n                nextPos1[otherIndex] = pos[otherIndex];\n\n                nextPos2[index] = pos[index];\n                nextPos2[otherIndex] = pos[otherIndex] + guideline.size;\n\n\n                start.push({\n                    type,\n                    pos: nextPos1,\n                    size: 0,\n                    elementRect: elementRect1,\n                });\n                end.push({\n                    type,\n                    pos: nextPos2,\n                    size: 0,\n                    elementRect: elementRect2,\n                });\n                // inner.push(guideline);\n            }\n        });\n\n        start.sort((a, b) => {\n            return b.pos[otherIndex] - a.pos[otherIndex];\n        });\n        end.sort((a, b) => {\n            return a.pos[otherIndex] - b.pos[otherIndex];\n        });\n        return {\n            total: nextGuidelines,\n            start,\n            end,\n            inner,\n        };\n    });\n}\nexport function renderDashedGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: Renderer,\n): any[] {\n    const {\n        isDisplayInnerSnapDigit,\n    } = moveable.props;\n    const rendered: any[] = [];\n\n    ([\"vertical\", \"horizontal\"] as const).forEach(type => {\n        const nextGuidelines = guidelines.filter(guideline => guideline.type === type);\n        const index = type === \"vertical\" ? 1 : 0;\n        const otherIndex = index ? 0 : 1;\n\n        const groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit!);\n        const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n\n        groups.forEach(({ total, start, end, inner }) => {\n            const sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start]!;\n\n            let prevRect = targetRect;\n\n            start.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n                const size = prevRect[mainNames.start]! - nextRect[mainNames.end]!;\n\n                if (size > 0) {\n                    const renderPos = [0, 0];\n\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.start]! - targetStart - size;\n                    renderPos[otherIndex] = sidePos;\n\n                    rendered.push(renderDigitLine(\n                        moveable,\n                        type,\n                        \"dashed\",\n                        rendered.length,\n                        size,\n                        renderPos,\n                        guideline.className,\n                        React\n                    ));\n                }\n                prevRect = nextRect;\n            });\n\n            prevRect = targetRect;\n            end.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n                const size = nextRect[mainNames.start]! - prevRect[mainNames.end]!;\n\n                if (size > 0) {\n                    const renderPos = [0, 0];\n\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.end]! - targetStart;\n                    renderPos[otherIndex] = sidePos;\n\n                    rendered.push(renderDigitLine(\n                        moveable,\n                        type,\n                        \"dashed\",\n                        rendered.length,\n                        size,\n                        renderPos,\n                        guideline.className,\n                        React\n                    ));\n                }\n                prevRect = nextRect;\n            });\n\n            inner.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n\n                const size1 = targetStart - nextRect[mainNames.start]!;\n                const size2 = nextRect[mainNames.end]! - targetEnd;\n                const renderPos1 = [0, 0];\n                const renderPos2 = [0, 0];\n\n                renderPos1[index] = targetPos[index] - size1;\n                renderPos1[otherIndex] = sidePos;\n\n                renderPos2[index] = targetPos[index] + targetEnd - targetStart;\n                renderPos2[otherIndex] = sidePos;\n\n                rendered.push(renderDigitLine(\n                    moveable,\n                    type,\n                    \"dashed\",\n                    rendered.length,\n                    size1,\n                    renderPos1,\n                    guideline.className,\n                    React\n                ));\n                rendered.push(renderDigitLine(\n                    moveable,\n                    type,\n                    \"dashed\",\n                    rendered.length,\n                    size2,\n                    renderPos2,\n                    guideline.className,\n                    React\n                ));\n            });\n        });\n    });\n    return rendered;\n}\nexport function renderGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: any\n): any[] {\n    const rendered: any[] = [];\n    ([\"horizontal\", \"vertical\"] as const).forEach(type => {\n        const nextGuidelines = guidelines.filter(guideline => guideline.type === type).slice(0, 1);\n        const index = type === \"vertical\" ? 0 : 1;\n        const otherIndex = index ? 0 : 1;\n        const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n        const targetSideStart = targetRect[sideNames.start]!;\n        const targetSideEnd = targetRect[sideNames.end]!;\n\n\n        nextGuidelines.forEach(({ gap, gapRects }) => {\n            const sideStartPos = Math.max(\n                targetSideStart,\n                ...gapRects!.map(({ rect }) => rect[sideNames.start]!),\n            );\n            const sideEndPos = Math.min(\n                targetSideEnd,\n                ...gapRects!.map(({ rect }) => rect[sideNames.end]!),\n            );\n            const sideCenterPos = (sideStartPos + sideEndPos) / 2;\n\n            if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd)/ 2) {\n                return;\n            }\n            gapRects!.forEach(({ rect, className }) => {\n                const renderPos = [targetPos[0], targetPos[1]];\n\n                if (rect[mainNames.end]! < targetStart) {\n                    renderPos[index] += rect[mainNames.end]! - targetStart;\n                } else if (targetEnd < rect[mainNames.start]!) {\n                    renderPos[index] += rect[mainNames.start]! - targetStart - gap!;\n                } else {\n                    return;\n                }\n\n                renderPos[otherIndex] += sideCenterPos - targetSideStart;\n                rendered.push(renderDigitLine(\n                    moveable,\n                    index ? \"vertical\" : \"horizontal\",\n                    \"gap\",\n                    rendered.length,\n                    gap!,\n                    renderPos,\n                    className,\n                    React\n                ));\n            });\n        });\n    });\n    return rendered;\n}\n","import { getDist, getRad, IObject, TINY_NUM } from \"@daybrush/utils\";\nimport { minus } from \"@scena/matrix\";\nimport { getAbsolutePoses, getDistSize, getRect, maxOffset } from \"../../utils\";\nimport { getDragDist, getPosByDirection } from \"../../gesto/GestoUtils\";\nimport {\n    BoundInfo, SnapInfo, MoveableManagerInterface, SnappableProps,\n    SnappableState, SnapBoundInfo, SnapGuideline, BoundType, SnapOffsetInfo, DraggableProps,\n} from \"../../types\";\nimport { checkBoundKeepRatio, checkBoundPoses, getBounds } from \"./bounds\";\nimport { getInnerBoundDragInfo } from \"./innerBounds\";\nimport {\n    getNearestSnapGuidelineInfo, checkMoveableSnapPoses,\n    checkSnapPoses, checkSnapKeepRatio,\n} from \"./snap\";\nimport { hasGuidelines, getSnapDirections, splitSnapDirectionPoses } from \"./utils\";\n\ninterface DirectionSnapType<T> {\n    vertical: T;\n    horizontal: T;\n}\n\n\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return [0, 0];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return [0, 0];\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\n\nfunction solveNextOffset(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    datas: IObject<any>\n) {\n    const sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\n\n    if (!sizeOffset) {\n        return {\n            isOutside: false,\n            offset: [0, 0],\n        };\n    }\n    const size = getDist(pos1, pos2);\n    const dist1 = getDist(sizeOffset, pos1);\n    const dist2 = getDist(sizeOffset, pos2);\n\n    const isOutside = dist1 > size || dist2 > size;\n    const [widthOffset, heightOffset] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return {\n        offset: [widthOffset, heightOffset],\n        isOutside,\n    };\n}\n\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\n\n\nexport function checkThrottleDragRotate(\n    throttleDragRotate: number,\n    [distX, distY]: number[],\n    [isVerticalBound, isHorizontalBound]: boolean[],\n    [isVerticalSnap, isHorizontalSnap]: boolean[],\n    [verticalOffset, horizontalOffset]: number[]\n) {\n    let offsetX = -verticalOffset;\n    let offsetY = -horizontalOffset;\n\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        const adjustPoses: number[][] = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalBound) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset]);\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalSnap) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset]);\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort((a, b) => {\n                return (\n                    getDistSize(minus([distX, distY], a)) -\n                    getDistSize(minus([distX, distY], b))\n                );\n            });\n            const adjustPos = adjustPoses[0];\n\n            if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY =\n                    (distY * Math.abs(distX + offsetX)) / Math.abs(distX) -\n                    distY;\n            } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n                const prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX =\n                    (distX * Math.abs(distY + offsetY)) / Math.abs(prevDistY) -\n                    distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (\n                    Math.abs(offsetX) > TINY_NUM &&\n                    Math.abs(offsetX) < Math.abs(verticalOffset)\n                ) {\n                    const scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (\n                    Math.abs(offsetY) > TINY_NUM &&\n                    Math.abs(offsetY) < Math.abs(horizontalOffset)\n                ) {\n                    const scale =\n                        Math.abs(horizontalOffset) / Math.abs(offsetY);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n        offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n    }\n    return [offsetX, offsetY];\n}\n\nexport function checkSnapBoundsDrag(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    distX: number,\n    distY: number,\n    throttleDragRotate: number,\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n        ];\n    }\n    const poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n    const { left, right, top, bottom } = getRect(poses);\n    const boundPoses = {\n        horizontal: poses.map((pos) => pos[1]),\n        vertical: poses.map((pos) => pos[0]),\n    };\n    const snapDirections = getSnapDirections(moveable.props.snapDirections);\n    const snapPoses = splitSnapDirectionPoses(snapDirections, {\n        left,\n        right,\n        top,\n        bottom,\n        center: (left + right) / 2,\n        middle: (top + bottom) / 2,\n    });\n    const {\n        vertical: verticalSnapBoundInfo,\n        horizontal: horizontalSnapBoundInfo,\n    } = checkMoveableSnapBounds(moveable, isRequest, snapPoses, boundPoses);\n    const {\n        vertical: verticalInnerBoundInfo,\n        horizontal: horizontalInnerBoundInfo,\n    } = getInnerBoundDragInfo(moveable, poses, datas);\n\n    const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    const isVerticalBound =\n        verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n    const isHorizontalBound =\n        horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n    const verticalOffset = maxOffset(\n        verticalSnapBoundInfo.offset,\n        verticalInnerBoundInfo.offset\n    );\n    const horizontalOffset = maxOffset(\n        horizontalSnapBoundInfo.offset,\n        horizontalInnerBoundInfo.offset\n    );\n\n    const [offsetX, offsetY] = checkThrottleDragRotate(\n        throttleDragRotate,\n        [distX, distY],\n        [isVerticalBound, isHorizontalBound],\n        [isVerticalSnap, isHorizontalSnap],\n        [verticalOffset, horizontalOffset]\n    );\n\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX,\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY,\n        },\n    ];\n}\n\nexport function checkMoveableSnapBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    isRequest: boolean,\n    poses: { vertical: number[]; horizontal: number[]; },\n    boundPoses: { vertical: number[]; horizontal: number[]; } = poses,\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable),\n        boundPoses.vertical,\n        boundPoses.horizontal,\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false, index: -1 } as SnapInfo,\n        vertical: { isSnap: false, index: -1 } as SnapInfo,\n    } : checkMoveableSnapPoses(\n        moveable,\n        poses.vertical,\n        poses.horizontal,\n    );\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\nexport function checkSnapBounds(\n    guideines: SnapGuideline[],\n    bounds: BoundType | undefined | false,\n    posesX: number[],\n    posesY: number[],\n    snapThreshold: number,\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(bounds, posesX, posesY);\n\n    // options.isRequest ? {\n    //     horizontal: { isSnap: false, index: -1 } as SnapInfo,\n    //     vertical: { isSnap: false, index: -1 } as SnapInfo,\n    // } :\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = checkSnapPoses(guideines, posesX, posesY, snapThreshold);\n\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\n\n\nfunction checkSnapRightLine(\n    startPos: number[],\n    endPos: number[],\n    snapBoundInfo: { vertical: SnapBoundInfo; horizontal: SnapBoundInfo },\n    keepRatio: boolean\n) {\n    const rad = (getRad(startPos, endPos) / Math.PI) * 180;\n    const {\n        vertical: {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            dist: verticalDist,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            dist: horizontalDist,\n        },\n    } = snapBoundInfo;\n\n    const rad180 = rad % 180;\n    const isHorizontalLine = rad180 < 3 || rad180 > 177;\n    const isVerticalLine = rad180 > 87 && rad180 < 93;\n\n    if (horizontalDist < verticalDist) {\n        if (\n            isVerticalBound ||\n            (isVerticalSnap &&\n                !isVerticalLine &&\n                (!keepRatio || !isHorizontalLine))\n        ) {\n            return \"vertical\";\n        }\n    }\n    if (\n        isHorizontalBound ||\n        (isHorizontalSnap &&\n            !isHorizontalLine &&\n            (!keepRatio || !isVerticalLine))\n    ) {\n        return \"horizontal\";\n    }\n    return \"\";\n}\n\n\nexport function getSnapBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    directions: number[][][],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    return directions.map(([startDirection, endDirection]) => {\n        const otherStartPos = getPosByDirection(poses, startDirection);\n        const otherEndPos = getPosByDirection(poses, endDirection);\n        const snapBoundInfo = keepRatio\n            ? checkSnapBoundsKeepRatio(\n                moveable,\n                otherStartPos,\n                otherEndPos,\n                isRequest\n            )\n            : checkMoveableSnapBounds(moveable, isRequest, {\n                vertical: [otherEndPos[0]],\n                horizontal: [otherEndPos[1]],\n            });\n\n        const {\n            horizontal: {\n                // dist: otherHorizontalDist,\n                offset: otherHorizontalOffset,\n                isBound: isOtherHorizontalBound,\n                isSnap: isOtherHorizontalSnap,\n            },\n            vertical: {\n                // dist: otherVerticalDist,\n                offset: otherVerticalOffset,\n                isBound: isOtherVerticalBound,\n                isSnap: isOtherVerticalSnap,\n            },\n        } = snapBoundInfo;\n\n        const multiple = minus(endDirection, startDirection);\n\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [0, 0],\n            };\n        }\n        const snapLine = checkSnapRightLine(\n            otherStartPos,\n            otherEndPos,\n            snapBoundInfo,\n            keepRatio\n        );\n\n        if (!snapLine) {\n            return {\n                sign: multiple,\n                isBound: false,\n                isSnap: false,\n                offset: [0, 0],\n            };\n        }\n\n        const isVertical = snapLine === \"vertical\";\n        let sizeOffset = [0, 0];\n\n        if (\n            !keepRatio\n            && Math.abs(endDirection[0]) === 1\n            && Math.abs(endDirection[1]) === 1\n            && startDirection[0] !== endDirection[0]\n            && startDirection[1] !== endDirection[1]\n        ) {\n            sizeOffset = getDragDist({\n                datas,\n                distX: -otherVerticalOffset,\n                distY: -otherHorizontalOffset,\n            });\n        } else {\n            sizeOffset = solveNextOffset(\n                otherStartPos,\n                otherEndPos,\n                -(isVertical ? otherVerticalOffset : otherHorizontalOffset),\n                isVertical,\n                datas,\n            ).offset;\n        }\n        sizeOffset = sizeOffset.map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset,\n        };\n    });\n}\n\n\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\n\nexport function checkSnapBoundsKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n    isRequest: boolean\n): DirectionSnapType<SnapBoundInfo> {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundKeepRatio(moveable, startPos, endPos);\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? ({\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any) : checkSnapKeepRatio(moveable, startPos, endPos);\n\n    const horizontalOffset = getSnapBoundOffset(\n        horizontalBoundInfo,\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBoundOffset(\n        verticalBoundInfo,\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\n\nexport function checkMaxBounds(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    fixedPosition: number[],\n    datas: any\n) {\n    const fixedDirection = [-direction[0], -direction[1]];\n    const { width, height } = moveable.state;\n    const bounds = moveable.props.bounds;\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n\n    if (bounds) {\n        const directions = [\n            [direction[0], -direction[1]],\n            [-direction[0], direction[1]],\n        ];\n        const {\n            left = -Infinity,\n            top = -Infinity,\n            right = Infinity,\n            bottom = Infinity,\n        } = bounds;\n\n        directions.forEach((otherDirection) => {\n            const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            const otherPos = getPosByDirection(poses, otherDirection);\n            const deg = (getRad(fixedPosition, otherPos) * 360) / Math.PI;\n\n            if (isCheckHorizontal) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n                    nextOtherPos[1] = fixedPosition[1];\n                }\n                const {\n                    offset: [, heightOffset],\n                    isOutside: isHeightOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[1] < otherPos[1] ? bottom : top) -\n                    otherPos[1],\n                    false,\n                    datas\n                );\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);\n                }\n            }\n            if (isCheckVertical) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n                    nextOtherPos[0] = fixedPosition[0];\n                }\n                const {\n                    offset: [widthOffset],\n                    isOutside: isWidthOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[0] < otherPos[0] ? right : left) - otherPos[0],\n                    true,\n                    datas\n                );\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);\n                }\n            }\n        });\n    }\n    return {\n        maxWidth,\n        maxHeight,\n    };\n}\n","import { isObject, throttle } from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport { minus } from \"@scena/matrix\";\nimport { getMinMaxs } from \"overlap-area\";\nimport {\n    MoveableManagerInterface, SnappableProps,\n    SnappableState, SnapGuideline, SnapDirectionPoses,\n    PosGuideline, ElementGuidelineValue,\n    SnapElementRect,\n} from \"../../types\";\nimport { getRect, getAbsolutePosesByState, getRefTarget, calculateInversePosition, roundSign } from \"../../utils\";\nimport {\n    splitSnapDirectionPoses, getSnapDirections,\n    HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP, calculateContainerPos,\n} from \"./utils\";\n\nexport function getTotalGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const state = moveable.state;\n    const {\n        containerClientRect,\n        hasFixed,\n    } = state;\n    const {\n        overflow,\n        scrollHeight: containerHeight,\n        scrollWidth: containerWidth,\n        clientHeight: containerClientHeight,\n        clientWidth: containerClientWidth,\n        clientLeft,\n        clientTop,\n    } = containerClientRect;\n    const {\n        snapGap = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n        snapThreshold = 5,\n        snapGridWidth = 0,\n        snapGridHeight = 0,\n        maxSnapElementGuidelineDistance = Infinity,\n    } = moveable.props;\n    const { top, left, bottom, right } = getRect(getAbsolutePosesByState(moveable.state));\n    const targetRect = { top, left, bottom, right, center: (left + right) / 2, middle: (top + bottom) / 2 };\n    const elementGuidelines = getElementGuidelines(moveable);\n    let totalGuidelines: SnapGuideline[] = [...elementGuidelines];\n\n    if (snapGap) {\n        totalGuidelines.push(...getGapGuidelines(\n            moveable, targetRect, snapThreshold,\n        ));\n    }\n    totalGuidelines.push(...getGridGuidelines(\n        snapGridWidth,\n        snapGridHeight,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n    ));\n    const snapOffset = {\n        ...(state.snapOffset || {\n            left: 0,\n            top: 0,\n            bottom: 0,\n            right: 0,\n        }),\n    };\n\n\n    if (hasFixed) {\n        const { left, top } = containerClientRect;\n\n        snapOffset.left += left;\n        snapOffset.top += top;\n        snapOffset.right += left;\n        snapOffset.bottom += top;\n    }\n\n    totalGuidelines.push(...getDefaultGuidelines(\n        horizontalGuidelines || false,\n        verticalGuidelines || false,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n        snapOffset,\n    ));\n\n    totalGuidelines = totalGuidelines.filter(({ element, elementRect, type }) => {\n        if (!element || !elementRect) {\n            return true;\n        }\n        const rect = elementRect.rect;\n\n        return checkBetweenRects(targetRect, rect, type, maxSnapElementGuidelineDistance);\n    });\n\n    return totalGuidelines;\n}\n\nexport function getGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    targetRect: SnapDirectionPoses,\n    snapThreshold: number,\n) {\n    const {\n        maxSnapElementGuidelineDistance = Infinity,\n        maxSnapElementGapDistance = Infinity,\n    } = moveable.props;\n    const elementRects = moveable.state.elementRects;\n    const gapGuidelines: SnapGuideline[] = [];\n    [\n        [\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP] as const,\n        [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP] as const,\n    ].forEach(([type, mainNames, sideNames]) => {\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n        const targetCenter = targetRect[mainNames.center]!;\n        const targetStart2 = targetRect[sideNames.start]!;\n        const targetEnd2 = targetRect[sideNames.end]!;\n\n        // element : moveable\n        function getDist(elementRect: SnapElementRect) {\n            const rect = elementRect.rect;\n\n            if (rect[mainNames.end]! < targetStart + snapThreshold) {\n                return targetStart - rect[mainNames.end]!;\n            } else if (targetEnd - snapThreshold < rect[mainNames.start]!) {\n                return rect[mainNames.start]! - targetEnd;\n            } else {\n                return -1;\n            }\n        }\n        const nextElementRects = elementRects.filter(elementRect => {\n            const rect = elementRect.rect;\n\n            if (rect[sideNames.start]! > targetEnd2 || rect[sideNames.end]! < targetStart2) {\n                return false;\n            }\n\n            return getDist(elementRect) > 0;\n        }).sort((a, b) => {\n            return getDist(a) - getDist(b);\n        });\n\n        const groups: SnapElementRect[][] = [];\n\n        nextElementRects.forEach(snapRect1 => {\n            nextElementRects.forEach(snapRect2 => {\n                if (snapRect1 === snapRect2) {\n                    return;\n                }\n                const { rect: rect1 } = snapRect1;\n                const { rect: rect2 } = snapRect2;\n\n                const rect1Start = rect1[sideNames.start]!;\n                const rect1End = rect1[sideNames.end]!;\n                const rect2Start = rect2[sideNames.start]!;\n                const rect2End = rect2[sideNames.end]!;\n\n                if (rect1Start > rect2End || rect2Start > rect1End) {\n                    return;\n                }\n\n                groups.push([snapRect1, snapRect2]);\n            });\n        });\n\n        groups.forEach(([snapRect1, snapRect2]) => {\n            const { rect: rect1 } = snapRect1;\n            const { rect: rect2 } = snapRect2;\n\n            const rect1Start = rect1[mainNames.start]!;\n            const rect1End = rect1[mainNames.end]!;\n            const rect2Start = rect2[mainNames.start]!;\n            const rect2End = rect2[mainNames.end]!;\n            let gap = 0;\n            let pos = 0;\n            let isStart = false;\n            let isCenter = false;\n            let isEnd = false;\n\n            if (rect1End <= targetStart && targetEnd <= rect2Start) {\n                // (l)element1(r) : (l)target(r) : (l)element2(r)\n                isCenter = true;\n                gap = ((rect2Start - rect1End) - (targetEnd - targetStart)) / 2;\n                pos = rect1End + gap + (targetEnd - targetStart) / 2;\n\n                if (Math.abs(pos - targetCenter) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {\n                // (l)element1(r) : (l)element2(r) : (l)target\n                isStart = true;\n\n                gap = rect2Start - rect1End;\n                pos = rect2End + gap;\n\n                if (Math.abs(pos - targetStart) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {\n                // target(r) : (l)element1(r) : (l)element2(r)\n\n                isEnd = true;\n                gap = rect2Start - rect1End;\n                pos = rect1Start - gap;\n\n                if (Math.abs(pos - targetEnd) > snapThreshold) {\n                    return;\n                }\n            } else {\n                return;\n            }\n            if (!gap) {\n                return;\n            }\n            if (!checkBetweenRects(targetRect, rect2, type, maxSnapElementGuidelineDistance)) {\n                return;\n            }\n            if (gap > maxSnapElementGapDistance) {\n                return;\n            }\n            gapGuidelines.push({\n                type,\n                pos: type === \"vertical\" ? [pos, 0] : [0, pos],\n                element: snapRect2.element,\n                size: 0,\n                className: snapRect2.className,\n                isStart,\n                isCenter,\n                isEnd,\n                gap,\n                hide: true,\n                gapRects: [snapRect1, snapRect2],\n            });\n        });\n    });\n    return gapGuidelines;\n}\nexport function getGridGuidelines(\n    snapGridWidth: number,\n    snapGridHeight: number,\n    containerWidth: number,\n    containerHeight: number,\n    clientLeft = 0,\n    clientTop = 0,\n): SnapGuideline[] {\n    const guidelines: SnapGuideline[] = [];\n\n    if (snapGridHeight) {\n        for (let pos = 0; pos <= containerHeight; pos += snapGridHeight) {\n            guidelines.push({\n                type: \"horizontal\",\n                pos: [0, throttle(pos - clientTop, 0.1)],\n                size: containerWidth!,\n                hide: true,\n            });\n        }\n    }\n    if (snapGridWidth) {\n        for (let pos = 0; pos <= containerWidth; pos += snapGridWidth) {\n            guidelines.push({\n                type: \"vertical\",\n                pos: [throttle(pos - clientLeft, 0.1), 0],\n                size: containerHeight!,\n                hide: true,\n            });\n        }\n    }\n    return guidelines;\n}\n\nexport function checkBetweenRects(\n    rect1: SnapDirectionPoses,\n    rect2: SnapDirectionPoses,\n    type: \"horizontal\" | \"vertical\",\n    distance: number,\n) {\n    if (type === \"horizontal\") {\n        return Math.abs(rect1.right! - rect2.left!) <= distance\n            || Math.abs(rect1.left! - rect2.right!) <= distance\n            || rect1.left! <= rect2.right! && rect2.left! <= rect1.right!;\n    } else if (type === \"vertical\") {\n        return Math.abs(rect1.bottom! - rect2.top!) <= distance\n            || Math.abs(rect1.top! - rect2.bottom!) <= distance\n            || rect1.top! <= rect2.bottom! && rect2.top! <= rect1.bottom!;\n    }\n    return true;\n}\n\n\nexport function getElementGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const state = moveable.state;\n\n    const {\n        elementGuidelines = [],\n    } = moveable.props;\n\n    if (!elementGuidelines.length) {\n        state.elementRects = [];\n        return [];\n    }\n\n    const prevValues = (state.elementRects || []).filter(snapRect => !snapRect.refresh);\n    const nextElementGuidelines = elementGuidelines.map(el => {\n        if (isObject(el) && \"element\" in el) {\n            return {\n                ...el,\n                element: getRefTarget(el.element, true)!,\n            };\n        }\n        return {\n            element: getRefTarget(el, true)!,\n        };\n    }).filter(value => {\n        return value.element;\n    }) as ElementGuidelineValue[];\n\n    const {\n        maintained,\n        added,\n    } = diff(prevValues.map(v => v.element), nextElementGuidelines.map(v => v.element));\n\n\n    const nextValues: SnapElementRect[] = [];\n    maintained.forEach(([prevIndex, nextIndex]) => {\n        nextValues[nextIndex] = prevValues[prevIndex];\n    });\n\n    getSnapElementRects(moveable, added.map(index => nextElementGuidelines[index])).map((rect, i) => {\n        nextValues[added[i]] = rect;\n    });\n\n\n    state.elementRects = nextValues;\n    const elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);\n    const nextGuidelines: SnapGuideline[] = [];\n\n    nextValues.forEach(snapRect => {\n        const {\n            element,\n            top: topValue = elementSnapDirections.top,\n            left: leftValue = elementSnapDirections.left,\n            right: rightValue = elementSnapDirections.right,\n            bottom: bottomValue = elementSnapDirections.bottom,\n            center: centerValue = elementSnapDirections.center,\n            middle: middleValue = elementSnapDirections.middle,\n            className,\n            rect,\n        } = snapRect;\n        const {\n            horizontal,\n            vertical,\n        } = splitSnapDirectionPoses({\n            top: topValue,\n            right: rightValue,\n            left: leftValue,\n            bottom: bottomValue,\n            center: centerValue,\n            middle: middleValue,\n        }, rect);\n        const rectTop = rect.top!;\n        const rectLeft = rect.left!;\n        const width = rect.right! - rectLeft;\n        const height = rect.bottom! - rectTop;\n        const sizes = [width, height];\n\n        vertical.forEach(pos => {\n            nextGuidelines.push({\n                type: \"vertical\", element, pos: [\n                    throttle(pos, 0.1),\n                    rectTop,\n                ], size: height,\n                sizes,\n                className,\n                elementRect: snapRect,\n            });\n        });\n        horizontal.forEach(pos => {\n            nextGuidelines.push({\n                type: \"horizontal\", element, pos: [\n                    rectLeft,\n                    throttle(pos, 0.1),\n                ], size: width,\n                sizes,\n                className,\n                elementRect: snapRect,\n            });\n        });\n    });\n\n    return nextGuidelines;\n}\n\n\nexport function getDefaultGuidelines(\n    horizontalGuidelines: Array<PosGuideline | number> | false,\n    verticalGuidelines: Array<PosGuideline | number> | false,\n    width: number,\n    height: number,\n    clientLeft = 0,\n    clientTop = 0,\n    snapOffset = { left: 0, top: 0, right: 0, bottom: 0 },\n): SnapGuideline[] {\n    const guidelines: SnapGuideline[] = [];\n    const {\n        left: snapOffsetLeft,\n        top: snapOffsetTop,\n        bottom: snapOffsetBottom,\n        right: snapOffsetRight,\n    } = snapOffset;\n    const snapWidth = width! + snapOffsetRight - snapOffsetLeft;\n    const snapHeight = height! + snapOffsetBottom - snapOffsetTop;\n\n    horizontalGuidelines && horizontalGuidelines!.forEach(posInfo => {\n        const nextPosInfo = isObject(posInfo) ? posInfo : { pos: posInfo };\n\n        guidelines.push({\n            type: \"horizontal\",\n            pos: [\n                snapOffsetLeft,\n                throttle(nextPosInfo.pos - clientTop + snapOffsetTop, 0.1),\n            ],\n            size: snapWidth,\n            className: nextPosInfo.className,\n        });\n    });\n    verticalGuidelines && verticalGuidelines!.forEach(posInfo => {\n        const nextPosInfo = isObject(posInfo) ? posInfo : { pos: posInfo };\n\n        guidelines.push({\n            type: \"vertical\",\n            pos: [\n                throttle(nextPosInfo.pos - clientLeft + snapOffsetLeft, 0.1),\n                snapOffsetTop,\n            ],\n            size: snapHeight,\n            className: nextPosInfo.className,\n        });\n    });\n    return guidelines;\n}\n\n\n\nexport function getSnapElementRects(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    values: ElementGuidelineValue[],\n): SnapElementRect[] {\n    if (!values.length) {\n        return [];\n    }\n    const state = moveable.state;\n    const {\n        containerClientRect,\n        targetClientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const [containerLeft, containerTop] = calculateContainerPos(rootMatrix, containerClientRect, n);\n    const poses = getAbsolutePosesByState(state);\n    const {\n        minX: targetLeft,\n        minY: targetTop,\n    } = getMinMaxs(poses);\n    const [distLeft, distTop] = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [\n        clientLeft - containerLeft,\n        clientTop - containerTop,\n    ], n)).map(pos => roundSign(pos));\n\n    return values.map(value => {\n        const rect = value.element.getBoundingClientRect();\n        const left = rect.left - containerLeft;\n        const top = rect.top - containerTop;\n        const bottom = top + rect.height;\n        const right = left + rect.width;\n        const [elementLeft, elementTop] = calculateInversePosition(rootMatrix, [left, top], n);\n        const [elementRight, elementBottom] = calculateInversePosition(rootMatrix, [right, bottom], n);\n\n        return {\n            ...value,\n            rect: {\n                left: elementLeft + distLeft,\n                right: elementRight + distLeft,\n                top: elementTop + distTop,\n                bottom: elementBottom + distTop,\n                center: (elementLeft + elementRight) / 2 + distLeft,\n                middle: (elementTop + elementBottom) / 2 + distTop,\n            },\n        };\n    });\n}\n\n","/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport {diff as listdiff} from \"@egjs/list-differ\";\nimport { findKeyCallback } from \"./consts\";\nimport { ChildrenDiffResult } from \"./types\";\n\n\n/**\n *\n * @memberof eg.ChildrenDiffer\n * @static\n * @function\n * @param - Previous List <ko>   </ko>\n * @param - List to Update <ko>    </ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>\n * @example\n * import { diff } from \"@egjs/children-differ\";\n * // script => eg.ChildrenDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1]);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\nexport function diff<T extends Element = Element>(\n  prevList: T[],\n  list: T[],\n): ChildrenDiffResult<T> {\n  return listdiff<T>(prevList, list, findKeyCallback);\n}\n","import {\n    Renderer,\n    SnappableProps,\n    SnappableState,\n    SnapGuideline,\n    SnapInfo,\n    ScalableProps,\n    SnapPosInfo,\n    RotatableProps,\n    RectInfo,\n    MoveableManagerInterface,\n    SnappableRenderType,\n    BoundType,\n    MoveableGroupInterface,\n} from \"../types\";\nimport {\n    prefix,\n    calculatePoses,\n    getRect,\n    getAbsolutePosesByState,\n    getAbsolutePoses,\n    getClientRect,\n    getRefTarget,\n    getDragDistByState,\n    triggerEvent,\n    getDirectionCondition,\n} from \"../utils\";\nimport {\n    findIndex, hasClass, throttle,\n} from \"@daybrush/utils\";\nimport {\n    getDragDist,\n    scaleMatrix,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { minus, rotate, plus } from \"@scena/matrix\";\nimport { dragControlCondition as rotatableDragControlCondtion } from \"./Rotatable\";\nimport { FLOAT_POINT_NUM } from \"../consts\";\nimport {\n    getInnerBoundInfo,\n    getCheckInnerBoundLineInfos,\n    checkRotateInnerBounds,\n    checkInnerBoundPoses,\n} from \"./snappable/innerBounds\";\nimport {\n    checkBoundPoses,\n    checkRotateBounds,\n    getBounds,\n} from \"./snappable/bounds\";\nimport {\n    checkSnaps,\n    getSnapInfosByDirection,\n    getNearOffsetInfo,\n    getCheckSnapDirections,\n} from \"./snappable/snap\";\nimport {\n    renderSnapPoses,\n    renderGuidelines,\n    renderDashedGuidelines,\n    renderGapGuidelines,\n} from \"./snappable/render\";\nimport {\n    hasGuidelines,\n} from \"./snappable/utils\";\nimport {\n    checkMaxBounds,\n    checkMoveableSnapBounds,\n    getSnapBoundInfo,\n} from \"./snappable/snapBounds\";\nimport { getTotalGuidelines } from \"./snappable/getTotalGuidelines\";\n\n\nexport interface SnapPoses {\n    vertical: number[];\n    horizontal: number[];\n}\n\nexport function checkSnapInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n) {\n    const state = moveable.state;\n    const container = state.container;\n    const snapContainer = moveable.props.snapContainer || container!;\n\n    if (state.snapContainer === snapContainer && state.guidelines && state.guidelines.length) {\n        return false;\n    }\n\n    const containerClientRect = state.containerClientRect;\n    const snapOffset = {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0,\n    };\n\n    if (container !== snapContainer) {\n        const snapContainerTarget = getRefTarget(snapContainer, true);\n\n        if (snapContainerTarget) {\n            const snapContainerRect = getClientRect(snapContainerTarget);\n            const offset1 = getDragDistByState(state, [\n                snapContainerRect.left - containerClientRect.left,\n                snapContainerRect.top - containerClientRect.top,\n            ]);\n            const offset2 = getDragDistByState(state, [\n                snapContainerRect.right - containerClientRect.right,\n                snapContainerRect.bottom - containerClientRect.bottom,\n            ]);\n\n            snapOffset.left = throttle(offset1[0], 0.00001);\n            snapOffset.top = throttle(offset1[1], 0.00001);\n            snapOffset.right = throttle(offset2[0], 0.00001);\n            snapOffset.bottom = throttle(offset2[1], 0.00001);\n        }\n    }\n\n    state.snapContainer = snapContainer;\n    state.snapOffset = snapOffset;\n    state.guidelines = getTotalGuidelines(moveable);\n    state.enableSnap = true;\n    return true;\n}\n\nfunction getNextFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedDirection: number[],\n    fixedPos: number[],\n    is3d: boolean\n) {\n    const nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextFixedPos = getPosByDirection(nextPoses, fixedDirection);\n\n    return getAbsolutePoses(nextPoses, minus(fixedPos, nextFixedPos));\n}\n\nexport function normalized(value: number) {\n    return value ? value / Math.abs(value) : 0;\n}\n\n\nexport function getSizeOffsetInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    const { fixedDirection } = datas;\n    const directions = getCheckSnapDirections(direction, fixedDirection, keepRatio);\n    const innerBoundLineInfos = getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio);\n    const offsets = [\n        ...getSnapBoundInfo(\n            moveable,\n            poses,\n            directions,\n            keepRatio,\n            isRequest,\n            datas\n        ),\n        ...getInnerBoundInfo(\n            moveable,\n            innerBoundLineInfos,\n            datas\n        ),\n    ];\n    const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0],\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1],\n        },\n    };\n}\nexport function recheckSizeByTwoDirection(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    width: number,\n    height: number,\n    maxWidth: number,\n    maxHeight: number,\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const snapPos = getPosByDirection(poses, direction);\n\n    const {\n        horizontal: { offset: horizontalOffset },\n        vertical: { offset: verticalOffset },\n    } = checkMoveableSnapBounds(moveable, isRequest, {\n        vertical: [snapPos[0]],\n        horizontal: [snapPos[1]],\n    });\n\n    if (throttle(verticalOffset, FLOAT_POINT_NUM) || throttle(horizontalOffset, FLOAT_POINT_NUM)) {\n        const [nextWidthOffset, nextHeightOffset] = getDragDist({\n            datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset,\n        });\n        const nextWidth = Math.min(\n            maxWidth || Infinity,\n            width + direction[0] * nextWidthOffset\n        );\n        const nextHeight = Math.min(\n            maxHeight || Infinity,\n            height + direction[1] * nextHeightOffset\n        );\n\n        return [nextWidth - width, nextHeight - height];\n    }\n    return [0, 0];\n}\nexport function checkSizeDist(\n    moveable: MoveableManagerInterface<any, any>,\n    getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const keepRatio = moveable.props.keepRatio;\n\n    let widthOffset = 0;\n    let heightOffset = 0;\n\n    for (let i = 0; i < 2; ++i) {\n        const nextPoses = getNextPoses(widthOffset, heightOffset);\n        const {\n            width: widthOffsetInfo,\n            height: heightOffsetInfo,\n        } = getSizeOffsetInfo(\n            moveable,\n            nextPoses,\n            direction,\n            keepRatio,\n            isRequest,\n            datas\n        );\n\n        const isWidthBound = widthOffsetInfo.isBound;\n        const isHeightBound = heightOffsetInfo.isBound;\n        let nextWidthOffset = widthOffsetInfo.offset;\n        let nextHeightOffset = heightOffsetInfo.offset;\n\n\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [0, 0];\n        }\n        if (keepRatio) {\n            const widthDist =\n                Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n            const heightDist =\n                Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n            const isGetWidthOffset =\n                isWidthBound && isHeightBound\n                    ? widthDist < heightDist\n                    : isHeightBound ||\n                    (!isWidthBound && widthDist < heightDist);\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = (width * nextHeightOffset) / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = (height * nextWidthOffset) / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    if (direction[0] && direction[1]) {\n        const { maxWidth, maxHeight } = checkMaxBounds(\n            moveable,\n            poses,\n            direction,\n            fixedPosition,\n            datas\n        );\n\n        const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n            moveable,\n            getNextPoses(widthOffset, heightOffset).map(pos => pos.map(p => throttle(p, FLOAT_POINT_NUM))),\n            width + widthOffset,\n            height + heightOffset,\n            maxWidth,\n            maxHeight,\n            direction,\n            isRequest,\n            datas\n        );\n\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    return [widthOffset, heightOffset];\n}\n\nexport function checkSnapRotate(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    rotation: number\n) {\n    if (!hasGuidelines(moveable, \"rotatable\")) {\n        return {\n            isSnap: false,\n            rotation,\n        };\n    }\n\n    const { pos1, pos2, pos3, pos4, origin: origin2 } = rect;\n    const rad = (rotation * Math.PI) / 180;\n    const prevPoses = [pos1, pos2, pos3, pos4].map((pos) => minus(pos, origin2));\n    const nextPoses = prevPoses.map((pos) => rotate(pos, rad));\n\n    // console.log(moveable.state.left, moveable.state.top, moveable.state.origin);\n    // console.log(pos1, pos2, pos3, pos4, origin, rad, prevPoses, nextPoses);\n    const result = [\n        ...checkRotateBounds(moveable, prevPoses, nextPoses, origin2, rotation),\n        ...checkRotateInnerBounds(\n            moveable,\n            prevPoses,\n            nextPoses,\n            origin2,\n            rotation\n        ),\n    ];\n    result.sort((a, b) => Math.abs(a - rotation) - Math.abs(b - rotation));\n    const isSnap = result.length > 0;\n\n    return {\n        isSnap,\n        rotation: isSnap ? result[0] : rotation,\n    };\n}\nexport function checkSnapResize(\n    moveable: MoveableManagerInterface<{}, {}>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const { fixedDirection, nextAllMatrix } = datas;\n    const { allMatrix, is3d } = moveable.state;\n\n    return checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                nextAllMatrix || allMatrix,\n                width + widthOffset,\n                height + heightOffset,\n                fixedDirection,\n                fixedPosition,\n                is3d\n            );\n        },\n        width,\n        height,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n}\nexport function checkSnapScale(\n    moveable: MoveableManagerInterface<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const { startOffsetWidth, startOffsetHeight, fixedPosition, fixedDirection, is3d } = datas;\n    const sizeDist = checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                scaleMatrix(\n                    datas,\n                    plus(scale, [widthOffset / startOffsetWidth, heightOffset / startOffsetHeight]),\n                ),\n                startOffsetWidth,\n                startOffsetHeight,\n                fixedDirection,\n                fixedPosition,\n                is3d\n            );\n        },\n        startOffsetWidth,\n        startOffsetHeight,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n    return [sizeDist[0] / startOffsetWidth, sizeDist[1] / startOffsetHeight];\n}\n\nexport function startCheckSnapDrag(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: any\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\n\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: SnapGuideline[] = [];\n\n    posInfos.forEach((posInfo) => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (guidelines.indexOf(guideline) > -1) {\n                return;\n            }\n            guidelines.push(guideline);\n        });\n    });\n\n    return guidelines;\n}\n\nfunction addBoundGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    verticalSnapPoses: SnappableRenderType[],\n    horizontalSnapPoses: SnappableRenderType[],\n    externalBounds?: BoundType | false | null\n) {\n    const {\n        vertical: verticalBoundInfos,\n        horizontal: horizontalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable, externalBounds),\n        verticalPoses,\n        horizontalPoses\n    );\n    verticalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            verticalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    horizontalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            horizontalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    const {\n        vertical: verticalInnerBoundPoses,\n        horizontal: horizontalInnerBoundPoses,\n    } = checkInnerBoundPoses(moveable);\n\n    verticalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                verticalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n\n    horizontalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                horizontalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n}\n\nconst directionCondition = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]);\n\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\nexport default {\n    name: \"snappable\",\n    dragRelation: \"strong\",\n    props: {\n        snappable: [Boolean, Array],\n        snapContainer: Object,\n\n        snapDirections: [Boolean, Object],\n        elementSnapDirections: [Boolean, Object],\n\n        snapGap: Boolean,\n        snapGridWidth: Number,\n        snapGridHeight: Number,\n        isDisplaySnapDigit: Boolean,\n        isDisplayInnerSnapDigit: Boolean,\n        snapDigit: Number,\n        snapThreshold: Number,\n        snapRenderThreshold: Number,\n\n        horizontalGuidelines: Array,\n        verticalGuidelines: Array,\n        elementGuidelines: Array,\n\n        bounds: Object,\n        innerBounds: Object,\n        snapDistFormat: Function,\n\n\n        maxSnapElementGuidelineDistance: Number,\n        maxSnapElementGapDistance: Number,\n    } as const,\n    events: {\n        onSnap: \"snap\",\n    } as const,\n    css: [\n        `:host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n`,\n    ],\n    render(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        React: Renderer\n    ): any[] {\n        const state = moveable.state;\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            snapRenderInfo,\n        } = state;\n        const {\n            snapRenderThreshold = 1,\n        } = moveable.props;\n\n        if (!snapRenderInfo || !snapRenderInfo.render || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n        state.guidelines = getTotalGuidelines(moveable);\n\n\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n        const externalPoses = snapRenderInfo.externalPoses || [];\n        const poses = getAbsolutePosesByState(moveable.state);\n        const verticalSnapPoses: SnappableRenderType[] = [];\n        const horizontalSnapPoses: SnappableRenderType[] = [];\n        const verticalGuidelines: SnapGuideline[] = [];\n        const horizontalGuidelines: SnapGuideline[] = [];\n        const snapInfos: Array<{\n            vertical: SnapInfo;\n            horizontal: SnapInfo;\n        }> = [];\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const targetRect = { left, right, top, bottom, center: (left + right) / 2, middle: (top + bottom) / 2 };\n        const hasExternalPoses = externalPoses.length > 0;\n        const externalRect = hasExternalPoses\n            ? getRect(externalPoses)\n            : ({} as ReturnType<typeof getRect>);\n\n        if (!snapRenderInfo.request) {\n            if (snapRenderInfo.direction) {\n                snapInfos.push(\n                    getSnapInfosByDirection(\n                        moveable,\n                        poses,\n                        snapRenderInfo.direction,\n                        snapRenderThreshold,\n                    )\n                );\n            }\n            if (snapRenderInfo.snap) {\n                const rect = getRect(poses);\n                if (snapRenderInfo.center) {\n                    (rect as any).middle = (rect.top + rect.bottom) / 2;\n                    (rect as any).center = (rect.left + rect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, rect, snapRenderThreshold));\n            }\n            if (hasExternalPoses) {\n                if (snapRenderInfo.center) {\n                    (externalRect as any).middle =\n                        (externalRect.top + externalRect.bottom) / 2;\n                    (externalRect as any).center =\n                        (externalRect.left + externalRect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, externalRect, snapRenderThreshold));\n            }\n            snapInfos.forEach((snapInfo) => {\n                const {\n                    vertical: { posInfos: verticalPosInfos },\n                    horizontal: { posInfos: horizontalPosInfos },\n                } = snapInfo;\n                verticalSnapPoses.push(\n                    ...verticalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n                horizontalSnapPoses.push(\n                    ...horizontalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n                verticalGuidelines.push(...getSnapGuidelines(verticalPosInfos));\n                horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n            });\n        }\n\n        addBoundGuidelines(\n            moveable,\n            [left, right],\n            [top, bottom],\n            verticalSnapPoses,\n            horizontalSnapPoses\n        );\n        if (hasExternalPoses) {\n            addBoundGuidelines(\n                moveable,\n                [externalRect.left, externalRect.right],\n                [externalRect.top, externalRect.bottom],\n                verticalSnapPoses,\n                horizontalSnapPoses,\n                snapRenderInfo.externalBounds\n            );\n        }\n        const allGuidelines = [...verticalGuidelines, ...horizontalGuidelines];\n        const elementGuidelines = allGuidelines.filter(guideline => guideline.element && !guideline.gapRects);\n        const gapGuidelines = allGuidelines.filter(guideline => guideline.gapRects).sort((a, b) => {\n            return a.gap! - b.gap!;\n        });\n\n        triggerEvent(\n            moveable,\n            \"onSnap\",\n            {\n                guidelines: allGuidelines.filter(({ element }) => !element),\n                elements: elementGuidelines,\n                gaps: gapGuidelines,\n            },\n            true\n        );\n        return [\n            ...renderDashedGuidelines(\n                moveable,\n                elementGuidelines,\n                [minLeft, minTop],\n                targetRect,\n                React,\n            ),\n            ...renderGapGuidelines(\n                moveable,\n                gapGuidelines,\n                [minLeft, minTop],\n                targetRect,\n                React,\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"horizontal\",\n                horizontalGuidelines,\n                [targetLeft, targetTop],\n                targetRect,\n                React\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"vertical\",\n                verticalGuidelines,\n                [targetLeft, targetTop],\n                targetRect,\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"horizontal\",\n                horizontalSnapPoses,\n                minLeft,\n                targetTop,\n                width,\n                0,\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"vertical\",\n                verticalSnapPoses,\n                minTop,\n                targetLeft,\n                height,\n                1,\n                React\n            ),\n        ];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        e: any\n    ) {\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        checkSnapInfo(moveable);\n    },\n    drag(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        const state = moveable.state;\n        if (!checkSnapInfo(moveable)) {\n            state.guidelines = getTotalGuidelines(moveable);\n        }\n        if (state.snapRenderInfo) {\n            state.snapRenderInfo.render = true;\n        }\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragControlCondition(moveable: MoveableManagerInterface, e: any) {\n        if (directionCondition(moveable, e) || rotatableDragControlCondtion(moveable, e)) {\n            return true;\n        }\n        if (!e.isRequest && e.inputEvent) {\n            return hasClass(e.inputEvent.target, prefix(\"snap-control\"));\n        }\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        checkSnapInfo(moveable);\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        checkSnapInfo(moveable);\n    },\n    dragGroupControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupControlEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n        state.elementRects = [];\n    },\n};\n\n\n/**\n * Whether or not target can be snapped to the guideline. (default: false)\n * @name Moveable.Snappable#snappable\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snappable = true;\n */\n/**\n *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)\n * @name Moveable.Snappable#snapContainer\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.querySelector(\".container\"));\n *\n * moveable.snapContainer = document.body;\n */\n/**\n * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })\n * @name Moveable.Snappable#snapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapDirections: true,\n * });\n * // snap center\n * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n\n/**\n * You can specify the snap directions of elements. (default: { left: true, top: true, right: true, bottom: true })\n * @name Moveable.Snappable#elementSnapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   elementSnapDirections: true,\n * });\n * // snap center\n * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidelines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidelines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries.\n * @name Moveable.Snappable#bounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * You can set up inner boundaries.\n * @name Moveable.Snappable#innerBounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n\n/**\n * If width size is greater than 0, you can vertical snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridWidth\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridWidth = 5;\n */\n\n/**\n * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridHeight\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridHeight = 5;\n */\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * Whether to show element inner snap distance (default: false)\n * @name Moveable.Snappable#isDisplayInnerSnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplayInnerSnapDigit = true;\n */\n\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: (v, type) => v,\n * });\n * moveable.snapDistFormat = (v, type) => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n","import { prefix, getControlTransform, getLineStyle, getProps } from \"./utils\";\nimport {\n    Renderer, MoveableManagerInterface,\n    RenderDirections,\n} from \"./types\";\nimport { DIRECTION_INDEXES, DIRECTION_ROTATIONS, DIRECTIONS, DIRECTIONS4 } from \"./consts\";\nimport { IObject, throttle, getRad, getKeys } from \"@daybrush/utils\";\n\nexport interface DirectionControlInfo {\n    data: Record<string, any>;\n    classNames: string[];\n    dir: string;\n}\nexport function renderDirectionControlsByInfos(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    ableName: string,\n    renderDirections: DirectionControlInfo[],\n    React: Renderer,\n): any[] {\n\n    const {\n        renderPoses,\n        rotation: rotationRad,\n        direction,\n    } = moveable.getState();\n    const {\n        zoom,\n    } = getProps(moveable.props, ableName as any);\n\n\n    const sign = (direction > 0 ? 1 : -1);\n    const degRotation = rotationRad / Math.PI * 180;\n    const directionMap: IObject<boolean> = {};\n\n    const renderState = moveable.renderState;\n    if (!renderState.renderDirectionMap) {\n        renderState.renderDirectionMap = {};\n    }\n    const renderDirectionMap = renderState.renderDirectionMap;\n\n    renderDirections.forEach(({ dir }) => {\n        directionMap[dir] = true;\n    });\n\n    return renderDirections.map(({ data, classNames, dir }) => {\n        const indexes = DIRECTION_INDEXES[dir];\n\n        if (!indexes || !directionMap[dir]) {\n            return null;\n        }\n        renderDirectionMap[dir] = true;\n        const directionRotation = (throttle(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n\n        const dataAttrs: Record<string, string> = {};\n\n        getKeys(data).forEach(name => {\n            dataAttrs[`data-${name}`] = data[name];\n        });\n        return (\n            <div className={prefix(\"control\", \"direction\", dir, ableName, ...classNames)}\n                data-rotation={directionRotation}\n                data-direction={dir}\n                {...dataAttrs}\n                key={`direction-${dir}`}\n                style={getControlTransform(rotationRad, zoom!, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\nexport function renderDirectionControls(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    defaultDirections: string[],\n    ableName: string,\n    React: Renderer,\n): any[] {\n    const {\n        renderDirections: directions = defaultDirections,\n    } = getProps(moveable.props, ableName as any);\n\n    if (!directions) {\n        return [];\n    }\n    const renderDirections = directions === true ? DIRECTIONS : directions;\n\n    return renderDirectionControlsByInfos(\n        moveable,\n        ableName,\n        renderDirections.map(dir => {\n            return {\n                data: {},\n                classNames: [],\n                dir,\n            };\n        }),\n        React,\n    );\n}\nexport function renderAroundControls(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    React: Renderer,\n): any[] {\n    const renderState = moveable.renderState;\n    if (!renderState.renderDirectionMap) {\n        renderState.renderDirectionMap = {};\n    }\n    const {\n        renderPoses,\n        rotation: rotationRad,\n        direction,\n    } = moveable.getState();\n\n    const renderDirectionMap = renderState.renderDirectionMap;\n\n    const {\n        zoom,\n    } = moveable.props;\n    const sign = (direction > 0 ? 1 : -1);\n    const degRotation = rotationRad / Math.PI * 180;\n\n    return getKeys(renderDirectionMap).map(dir => {\n        const indexes = DIRECTION_INDEXES[dir];\n\n        if (!indexes) {\n            return null;\n        }\n        const directionRotation = (throttle(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n\n        return (\n            <div className={prefix(\"around-control\")} data-rotation={directionRotation} data-direction={dir} key={`direction-around-${dir}`}\n                style={getControlTransform(rotationRad, zoom!, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\n\nexport function renderLine(\n    React: Renderer,\n    direction: string,\n    pos1: number[],\n    pos2: number[],\n    zoom: number,\n    key: number | string,\n    ...classNames: string[]\n): any {\n    const rad = getRad(pos1, pos2);\n    const rotation = direction ? (throttle(rad / Math.PI * 180, 15)) % 180 : -1;\n\n    return <div key={`line-${key}`}\n        className={prefix(\"line\", \"direction\", direction ? \"edge\" : \"\", direction, ...classNames)}\n        data-rotation={rotation}\n        data-line-key={key}\n        data-direction={direction} style={getLineStyle(pos1, pos2, zoom, rad)}></div>;\n}\n\nexport function renderEdgeLines(\n    React: Renderer,\n    ableName: string,\n    edge: true | string[],\n    poses: number[][],\n    zoom: number,\n): any[] {\n    const directions = edge === true ? DIRECTIONS4 : edge;\n\n    return directions.map((direction, i) => {\n        const [index1, index2] = DIRECTION_INDEXES[direction];\n\n        if (index2 == null) {\n            return;\n        }\n        return renderLine(React, direction, poses[index1], poses[index2], zoom, `${ableName}Edge${i}`, ableName);\n    }).filter(Boolean);\n}\nexport function getRenderDirections(ableName: string) {\n    return (\n        moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n        React: Renderer,\n    ) => {\n        const edge = getProps(moveable.props, ableName as any).edge;\n\n        if (edge && (edge === true || edge.length)) {\n            return [\n                ...renderEdgeLines(\n                    React,\n                    ableName,\n                    edge,\n                    moveable.getState().renderPoses,\n                    moveable.props.zoom!,\n                ),\n                ...renderDiagonalDirections(moveable, ableName, React),\n            ];\n        }\n        return renderAllDirections(moveable, ableName, React);\n    };\n}\nexport function renderAllDirections(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    ableName: string,\n    React: Renderer,\n) {\n    return renderDirectionControls(moveable, DIRECTIONS, ableName, React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    ableName: string,\n    React: Renderer,\n): any[] {\n    return renderDirectionControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], ableName, React);\n}\n","import {\n    setDragStart, getBeforeDragDist, getTransformDist,\n    convertTransformFormat, resolveTransformEvent, fillTransformStartEvent,\n    setDefaultTransformIndex, fillOriginalTransform,\n} from \"../gesto/GestoUtils\";\nimport {\n    triggerEvent, fillParams,\n    getDistSize, prefix,\n    fillEndParams,\n    fillCSSObject,\n} from \"../utils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState,\n    Renderer, OnDragGroupEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildGesto } from \"../groupUtils\";\nimport { startCheckSnapDrag } from \"./Snappable\";\nimport { IObject, getRad, throttle, throttleArray } from \"@daybrush/utils\";\nimport { checkSnapBoundsDrag } from \"./snappable/snapBounds\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\nexport default {\n    name: \"draggable\",\n    props: {\n        draggable: Boolean,\n        throttleDrag: Number,\n        throttleDragRotate: Number,\n        startDragRotate: Number,\n        edgeDraggable: Boolean,\n    } as const,\n    events: {\n        onDragStart: \"dragStart\",\n        onDrag: \"drag\",\n        onDragEnd: \"dragEnd\",\n        onDragGroupStart: \"dragGroupStart\",\n        onDragGroup: \"dragGroup\",\n        onDragGroupEnd: \"dragGroupEnd\",\n    } as const,\n    requestStyle(): string[] {\n        return [\"left\", \"top\", \"right\", \"bottom\"];\n    },\n    render(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        React: Renderer,\n    ): any[] {\n        const { throttleDragRotate, zoom } = moveable.props;\n        const { dragInfo, beforeOrigin } = moveable.getState();\n\n        if (!throttleDragRotate || !dragInfo) {\n            return [];\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return [];\n        }\n\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return [<div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        }} />];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentGesto } = e;\n        const state = moveable.state;\n        const {\n            gestos,\n            style,\n        } = state;\n\n        if (gestos.draggable) {\n            return false;\n        }\n        gestos.draggable = parentGesto || moveable.targetGesto;\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.startValue = [0, 0];\n\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(e, \"translate\");\n        startCheckSnapDrag(moveable, datas);\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n        datas.deltaOffset = [0, 0];\n\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startValue = translate;\n            },\n            ...fillTransformStartEvent(e),\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            gestos.draggable = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        if (!e) {\n            return;\n        }\n        resolveTransformEvent(e, \"translate\");\n\n        const { datas, parentEvent, parentFlag, isPinch, isRequest, deltaOffset } = e;\n        let { distX, distY } = e;\n        const { isDrag, prevDist, prevBeforeDist, startValue } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n\n        if (deltaOffset) {\n            distX += deltaOffset[0];\n            distY += deltaOffset[1];\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let dragRotateRad = 0;\n        let isVerticalSnap = false;\n        let isVerticalBound = false;\n        let isHorizontalSnap = false;\n        let isHorizontalBound = false;\n\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n            const startDragRotate = props.startDragRotate || 0;\n            const deg\n                = throttle(startDragRotate + getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate)\n                - startDragRotate;\n            const ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n            const rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n            const r = getDistSize([rx, ry]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag) {\n            const [verticalInfo, horizontalInfo] = checkSnapBoundsDrag(\n                moveable, distX, distY,\n                throttleDragRotate,\n                isRequest || deltaOffset, datas,\n            );\n            isVerticalSnap = verticalInfo.isSnap;\n            isVerticalBound = verticalInfo.isBound;\n            isHorizontalSnap = horizontalInfo.isSnap;\n            isHorizontalBound = horizontalInfo.isBound;\n\n            const verticalOffset = verticalInfo.offset;\n            const horizontalOffset = horizontalInfo.offset;\n\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n\n        const beforeTranslate = plus(getBeforeDragDist({ datas, distX, distY }), startValue);\n        const translate = plus(getTransformDist({ datas, distX, distY }), startValue);\n\n        throttleArray(translate, TINY_NUM);\n        throttleArray(beforeTranslate, TINY_NUM);\n\n        if (!throttleDragRotate) {\n            if (!isVerticalSnap && !isVerticalBound) {\n                translate[0] = throttle(translate[0], throttleDrag);\n                beforeTranslate[0] = throttle(beforeTranslate[0], throttleDrag);\n            }\n            if (!isHorizontalSnap && !isHorizontalBound) {\n                translate[1] = throttle(translate[1], throttleDrag);\n                beforeTranslate[1] = throttle(beforeTranslate[1], throttleDrag);\n            }\n        }\n\n\n        const beforeDist = minus(beforeTranslate, startValue);\n        const dist = minus(translate, startValue);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n\n        datas.passDelta = delta; //distX - (datas.passDistX || 0);\n        // datas.passDeltaY = distY - (datas.passDistY || 0);\n        datas.passDist = dist; //distX;\n        // datas.passDistY = distY;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = convertTransformFormat(datas,\n            `translate(${translate[0]}px, ${translate[1]}px)`, `translate(${dist[0]}px, ${dist[1]}px)`);\n\n        fillOriginalTransform(e, nextTransform);\n\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            width,\n            height,\n            isPinch,\n            ...fillCSSObject({\n                transform: nextTransform,\n            }, e),\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragAfter(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            deltaOffset,\n        } = datas;\n\n        if (deltaOffset[0] || deltaOffset[1]) {\n            datas.deltaOffset = [0, 0];\n            return this.drag(moveable, {...e, deltaOffset });\n        }\n        return false;\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas } = e;\n\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        const param = fillEndParams<OnDragEnd>(moveable, e, {});\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", param);\n        return param;\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas, clientX, clientY } = e;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildGesto(moveable, this, \"dragStart\", [\n            clientX || 0,\n            clientY || 0,\n        ], e, false, \"draggable\");\n\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDelta } = e.datas;\n        const events = triggerChildGesto(moveable, this, \"drag\", passDelta, e, false, \"draggable\");\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        const events = triggerChildGesto(moveable, this, \"dragEnd\", [0, 0], e, false, \"draggable\");\n        triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams<OnDragGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        }));\n\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        return {\n            isControl: false,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n\n                return { datas, distX, distY };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n    unset(moveable: MoveableManagerInterface<any, Record<string, any>>) {\n        moveable.state.gestos.draggable = null;\n        moveable.state.dragInfo = null;\n    },\n};\n\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n* throttle of angle of x, y when drag.\n* @name Moveable.Draggable#throttleDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.throttleDragRotate = 45;\n*/\n\n/**\n* start angle of throttleDragRotate of x, y when drag.\n* @name Moveable.Draggable#startDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* // 45, 135, 225, 315\n* moveable.throttleDragRotate = 90;\n* moveable.startDragRotate = 45;\n*/\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group drag starts, the `dragGroupStart` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroupStart\n* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroupStart\", ({ targets }) => {\n*     console.log(\"onDragGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group drag, the `dragGroup` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroup\n* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroup\", ({ targets, events }) => {\n*     console.log(\"onDragGroup\", targets);\n*     events.forEach(ev => {\n*          // drag event\n*          console.log(\"onDrag left, top\", ev.left, ev.top);\n*          // ev.target!.style.left = `${ev.left}px`;\n*          // ev.target!.style.top = `${ev.top}px`;\n*          console.log(\"onDrag translate\", ev.dist);\n*          ev.target!.style.transform = ev.transform;)\n*     });\n* });\n*/\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    triggerEvent,\n    fillParams,\n    fillEndParams,\n    getAbsolutePosesByState,\n    catchEvent,\n    getOffsetSizeDist,\n    getProps,\n    getDirectionCondition,\n    calculatePoses,\n    fillAfterTransform,\n    getDirectionViewClassName,\n    getTotalDirection,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getResizeDist,\n    getAbsolutePosition,\n    getPosByDirection,\n    getNextMatrix,\n    getNextTransforms,\n    getDirectionByPos,\n} from \"../gesto/GestoUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd, MoveableManagerInterface, MoveableGroupInterface, SnappableProps,\n    OnBeforeResize, OnBeforeResizeGroup, ResizableRequestParam,\n} from \"../types\";\nimport { getRenderDirections } from \"../renderDirections\";\nimport {\n    fillChildEvents,\n    triggerChildAbles,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { calculate, convertDimension, createRotateMatrix, plus } from \"@scena/matrix\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\nimport { checkSnapResize } from \"./Snappable\";\nimport {\n    calculateBoundSize,\n    isString, convertUnitSize,\n    throttle,\n    isNumber,\n} from \"@daybrush/utils\";\nimport { TINY_NUM } from \"../consts\";\nimport { parseMat } from \"css-to-mat\";\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\nconst directionCondition = getDirectionCondition(\"resizable\");\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        resizable: Boolean,\n        throttleResize: Number,\n        renderDirections: Array,\n        keepRatio: Boolean,\n        resizeFormat: Function,\n        keepRatioFinally: Boolean,\n        edge: Boolean,\n        checkResizableError: Boolean,\n    } as const,\n    events: {\n        onResizeStart: \"resizeStart\",\n        onBeforeResize: \"beforeResize\",\n        onResize: \"resize\",\n        onResizeEnd: \"resizeEnd\",\n\n        onResizeGroupStart: \"resizeGroupStart\",\n        onBeforeResizeGroup: \"beforeResizeGroup\",\n        onResizeGroup: \"resizeGroup\",\n        onResizeGroupEnd: \"resizeGroupEnd\",\n    } as const,\n    render: getRenderDirections(\"resizable\"),\n    dragControlCondition: directionCondition,\n    viewClassName: getDirectionViewClassName(\"resizable\"),\n    dragControlStart(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            isPinch,\n            isGroup,\n            parentDirection,\n            parentGesto,\n            datas,\n            parentFixedDirection,\n            parentEvent,\n        } = e;\n\n        const direction = getTotalDirection(\n            parentDirection,\n            isPinch,\n            inputEvent,\n            datas,\n        );\n\n        const state = moveable.state;\n        const { target, width, height, gestos } = state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (gestos.resizable) {\n            return false;\n        }\n        gestos.resizable = parentGesto || moveable.controlGesto;\n        !isPinch && setDragStart(moveable, e);\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n\n        datas.minSize = [0, 0];\n\n\n        datas.startWidth = state.inlineCSSWidth || state.cssWidth;\n        datas.startHeight = state.inlineCSSHeight || state.cssHeight;\n        datas.maxSize = [Infinity, Infinity];\n\n        if (!isGroup) {\n            datas.minSize = [\n                state.minOffsetWidth,\n                state.minOffsetHeight,\n            ];\n            datas.maxSize = [\n                state.maxOffsetWidth,\n                state.maxOffsetHeight,\n            ];\n        }\n        const transformOrigin = moveable.props.transformOrigin || \"% %\";\n\n        datas.transformOrigin = transformOrigin && isString(transformOrigin)\n            ? transformOrigin.split(\" \")\n            : transformOrigin;\n\n        datas.startOffsetMatrix = state.offsetMatrix;\n        datas.startTransformOrigin = state.transformOrigin;\n\n        datas.isWidth = e?.parentIsWidth ?? ((!direction[0] && !direction[1]) || direction[0] || !direction[1]);\n\n        function setRatio(ratio: number) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n\n\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\n\n        function setFixedDirection(fixedDirection: number[]) {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);\n        }\n        function setFixedPosition(fixedPosition: number[]) {\n            const {\n                width,\n                height,\n            } = moveable.state;\n\n            datas.fixedPosition = fixedPosition;\n            datas.fixedDirection = getDirectionByPos(fixedPosition, width, height);\n        }\n        function setMin(minSize: Array<string | number>)  {\n            datas.minSize = [\n                convertUnitSize(`${minSize[0]}`, 0) || 0,\n                convertUnitSize(`${minSize[1]}`, 0) || 0,\n            ];\n        }\n        function setMax(maxSize: Array<string | number>) {\n            const nextMaxSize = [\n                maxSize[0] || Infinity,\n                maxSize[1] || Infinity,\n            ];\n            if (!isNumber(nextMaxSize[0]) || isFinite(nextMaxSize[0])) {\n                nextMaxSize[0] = convertUnitSize(`${nextMaxSize[0]}`, 0) || Infinity;\n            }\n            if (!isNumber(nextMaxSize[1]) || isFinite(nextMaxSize[1])) {\n                nextMaxSize[1] = convertUnitSize(`${nextMaxSize[1]}`, 0) || Infinity;\n            }\n            datas.maxSize = nextMaxSize;\n        }\n\n        setRatio(width / height);\n        setFixedDirection(parentFixedDirection || [-direction[0], -direction[1]]);\n\n        datas.setFixedDirection = setFixedDirection;\n        datas.setFixedPosition = setFixedPosition;\n        datas.setMin = setMin;\n        datas.setMax = setMax;\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            startRatio: datas.ratio,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setMin,\n            setMax,\n            setRatio,\n            setFixedDirection,\n            setFixedPosition,\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ),\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onResizeStart\", params);\n\n        datas.startFixedDirection = datas.fixedDirection;\n        datas.startFixedPosition = datas.fixedPosition;\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps & SnappableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            parentFlag,\n            isPinch,\n            parentKeepRatio,\n            dragClient,\n            parentDist,\n            isRequest,\n            isGroup,\n            parentEvent,\n            resolveMatrix,\n        } = e;\n\n        const {\n            isResize,\n            transformOrigin,\n            startWidth,\n            startHeight,\n            prevWidth,\n            prevHeight,\n            minSize,\n            maxSize,\n            ratio,\n            startOffsetWidth,\n            startOffsetHeight,\n            isWidth,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        if (resolveMatrix) {\n            const {\n                is3d,\n            } = moveable.state;\n            const {\n                startOffsetMatrix,\n                startTransformOrigin,\n            } = datas;\n            const n = is3d ? 4 : 3;\n            let targetMatrix = parseMat(getNextTransforms(e));\n            const targetN = Math.sqrt(targetMatrix.length);\n\n            if (n !== targetN) {\n                targetMatrix = convertDimension(targetMatrix, targetN, n);\n            }\n\n            const nextAllMatrix = getNextMatrix(\n                startOffsetMatrix,\n                targetMatrix,\n                startTransformOrigin,\n                n,\n            );\n            const poses = calculatePoses(nextAllMatrix, startOffsetWidth, startOffsetHeight, n);\n\n            datas.startPositions = poses;\n            datas.nextTargetMatrix = targetMatrix;\n            datas.nextAllMatrix = nextAllMatrix;\n        }\n        const props = getProps(moveable.props, \"resizable\");\n        const {\n            resizeFormat,\n            throttleResize = parentFlag ? 0 : 1,\n            parentMoveable,\n            keepRatioFinally,\n        } = props;\n        const direction = datas.direction;\n        let sizeDirection = direction;\n        let distWidth = 0;\n        let distHeight = 0;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = (ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) || false;\n\n        function getNextBoundingSize() {\n            const fixedDirection = datas.fixedDirection;\n            const nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n\n            distWidth = nextSize.distWidth;\n            distHeight = nextSize.distHeight;\n\n            let nextWidth = (sizeDirection[0] - fixedDirection[0]) || keepRatio\n                ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n            let nextHeight = (sizeDirection[1] - fixedDirection[1]) || keepRatio\n                ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n                if (isWidth) {\n                    nextHeight = nextWidth / ratio;\n                } else {\n                    nextWidth = nextHeight * ratio;\n                }\n            }\n            return [nextWidth, nextHeight];\n        }\n\n        let [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n        if (!parentEvent) {\n            datas.setFixedDirection(datas.fixedDirection);\n\n            triggerEvent(moveable, \"onBeforeResize\", fillParams<OnBeforeResize>(moveable, e, {\n                startFixedDirection: datas.startFixedDirection,\n                startFixedPosition: datas.startFixedPosition,\n                setFixedDirection(nextFixedDirection: number[]) {\n                    datas.setFixedDirection(nextFixedDirection);\n\n                    [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n                    return [boundingWidth, boundingHeight];\n                },\n                setFixedPosition(nextFixedPosition: number[]) {\n                    datas.setFixedPosition(nextFixedPosition);\n\n                    [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n                    return [boundingWidth, boundingHeight];\n                },\n                boundingWidth,\n                boundingHeight,\n                setSize(size: number[]) {\n                    [boundingWidth, boundingHeight] = size;\n                },\n            }, true));\n        }\n\n        let fixedPosition = dragClient;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapResize(\n                moveable,\n                boundingWidth,\n                boundingHeight,\n                direction,\n                fixedPosition,\n                isRequest,\n                datas,\n            );\n        }\n        if (parentDist) {\n            !parentDist[0] && (snapDist[0] = 0);\n            !parentDist[1] && (snapDist[1] = 0);\n        }\n\n        function computeSize() {\n            if (resizeFormat) {\n                [boundingWidth, boundingHeight] = resizeFormat([boundingWidth, boundingHeight]);\n            }\n            boundingWidth = throttle(boundingWidth, throttleResize!);\n            boundingHeight = throttle(boundingHeight, throttleResize!);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                // pre-compute before maintaining the ratio\n                computeSize();\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                boundingWidth += snapDist[0];\n                boundingHeight = boundingWidth / ratio;\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                boundingHeight += snapDist[1];\n                boundingWidth = boundingHeight * ratio;\n            }\n        } else {\n            boundingWidth += snapDist[0];\n            boundingHeight += snapDist[1];\n\n            boundingWidth = Math.max(0, boundingWidth);\n            boundingHeight = Math.max(0, boundingHeight);\n        }\n\n        [boundingWidth, boundingHeight] = calculateBoundSize(\n            [boundingWidth, boundingHeight],\n            minSize,\n            maxSize,\n            keepRatio ? ratio : false,\n        );\n        computeSize();\n\n        if (keepRatio && (isGroup || keepRatioFinally)) {\n            if (isWidth) {\n                boundingHeight = boundingWidth / ratio;\n            } else {\n                boundingWidth = boundingHeight * ratio;\n            }\n        }\n        distWidth = boundingWidth - startOffsetWidth;\n        distHeight = boundingHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        const inverseDelta = getResizeDist(\n            moveable,\n            boundingWidth,\n            boundingHeight,\n            fixedPosition,\n            transformOrigin,\n            datas,\n        );\n\n        if (!parentMoveable && delta.every(num => !num) && inverseDelta.every(num => !num)) {\n            return;\n        }\n        const drag = Draggable.drag(\n            moveable,\n            setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false, \"draggable\"),\n        ) as OnDrag;\n        const transform = drag.transform;\n\n        const nextWidth = startWidth + distWidth;\n        const nextHeight = startHeight + distHeight;\n\n        const params = fillParams<OnResize>(moveable, e, {\n            width: nextWidth,\n            height: nextHeight,\n            offsetWidth: Math.round(boundingWidth),\n            offsetHeight: Math.round(boundingHeight),\n            startRatio: ratio,\n            boundingWidth,\n            boundingHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!isPinch,\n            drag,\n            ...fillAfterTransform({\n                style: {\n                    width: `${nextWidth}px`,\n                    height: `${nextHeight}px`,\n                },\n                transform,\n            }, drag, e),\n        });\n        !parentEvent && triggerEvent(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize || moveable.props.checkResizableError === false) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            return this.dragControl(moveable, e);\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, parentEvent } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        datas.isResize = false;\n\n        const params = fillEndParams<OnResizeEnd>(moveable, e, {});\n        !parentEvent && triggerEvent(moveable, \"onResizeEnd\", params);\n        return params;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, {...e, isGroup: true });\n\n        if (!params) {\n            return false;\n        }\n        const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n        function setDist(child: MoveableManagerInterface, ev: any) {\n            const fixedDirection = datas.fixedDirection;\n            const fixedPosition = datas.fixedPosition;\n\n            const startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);\n            const pos = getPosByDirection(startPositions, fixedDirection);\n            const [originalX, originalY] = calculate(\n                createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                3,\n            );\n            ev.datas.originalX = originalX;\n            ev.datas.originalY = originalY;\n\n            return ev;\n        }\n        const {\n            startOffsetWidth: parentStartOffsetWidth,\n            startOffsetHeight: parentStartOffsetHeight,\n        } = datas;\n\n        function updateGroupMin() {\n            const originalMinSize = datas.minSize;\n            originalEvents.forEach(ev => {\n                const {\n                    minSize: childMinSize,\n                    startOffsetWidth: childStartOffsetWidth,\n                    startOffsetHeight: childStartOffsetHeight,\n                } = ev.datas;\n\n                const parentMinWidth = parentStartOffsetWidth\n                    * (childStartOffsetWidth ? childMinSize[0] / childStartOffsetWidth : 0);\n                const parentMinHeight = parentStartOffsetHeight\n                    * (childStartOffsetHeight ? childMinSize[1] / childStartOffsetHeight : 0);\n\n                originalMinSize[0] = Math.max(originalMinSize[0], parentMinWidth);\n                originalMinSize[1] = Math.max(originalMinSize[1], parentMinHeight);\n            });\n        }\n\n        function updateGroupMax() {\n            const originalMaxSize = datas.maxSize;\n            originalEvents.forEach(ev => {\n                const {\n                    maxSize: childMaxSize,\n                    startOffsetWidth: childStartOffsetWidth,\n                    startOffsetHeight: childStartOffsetHeight,\n                } = ev.datas;\n\n                const parentMaxWidth = parentStartOffsetWidth\n                    * (childStartOffsetWidth ? childMaxSize[0] / childStartOffsetWidth : 0);\n                const parentMaxHeight = parentStartOffsetHeight\n                    * (childStartOffsetHeight ? childMaxSize[1] / childStartOffsetHeight : 0);\n\n                originalMaxSize[0] = Math.min(originalMaxSize[0], parentMaxWidth);\n                originalMaxSize[1] = Math.min(originalMaxSize[1], parentMaxHeight);\n            });\n        }\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                return setDist(child, ev);\n            },\n        );\n\n\n        updateGroupMin();\n        updateGroupMax();\n\n        const setFixedDirection = (fixedDirection: number[]) => {\n            params.setFixedDirection(fixedDirection);\n            events.forEach((ev, i) => {\n                ev.setFixedDirection(fixedDirection);\n                setDist(ev.moveable, originalEvents[i]);\n            });\n        };\n\n        datas.setFixedDirection = setFixedDirection;\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events: events.map(ev => {\n                return {\n                    ...ev,\n                    setMin: (minSize: Array<number | string>) => {\n                        ev.setMin(minSize);\n                        updateGroupMin();\n                    },\n                    setMax: (maxSize: Array<number | string>) => {\n                        ev.setMax(maxSize);\n                        updateGroupMax();\n                    },\n                };\n            }),\n            setFixedDirection,\n            setMin: (minSize: Array<number | string>) => {\n                params.setMin(minSize);\n                updateGroupMin();\n            },\n            setMax: (maxSize: Array<number | string>) => {\n                params.setMax(maxSize);\n                updateGroupMax();\n            },\n        };\n        const result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const props = getProps(moveable.props, \"resizable\");\n\n        catchEvent(moveable, \"onBeforeResize\", parentEvent => {\n            triggerEvent(moveable, \"onBeforeResizeGroup\", fillParams<OnBeforeResizeGroup>(moveable, e, {\n                ...parentEvent,\n                targets: props.targets!,\n            }, true));\n        });\n\n\n        const params = this.dragControl(moveable, {...e, isGroup: true });\n\n        if (!params) {\n            return;\n        }\n        const {\n            boundingWidth,\n            boundingHeight,\n            dist,\n        } = params;\n\n        const keepRatio = props.keepRatio;\n\n        const parentScale = [\n            boundingWidth / (boundingWidth - dist[0]),\n            boundingHeight / (boundingHeight - dist[1]),\n        ];\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [clientX, clientY] = calculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        ev.datas.originalX * parentScale[0],\n                        ev.datas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...ev,\n                    parentDist: null,\n                    parentScale,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                    parentKeepRatio: keepRatio,\n                };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams: OnResizeGroupEnd = fillEndParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        });\n\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Resizable#request\n     * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any>) {\n        const datas: Record<string, any> = {};\n        let distWidth = 0;\n        let distHeight = 0;\n        const rect = moveable.getRect();\n\n        return {\n            isControl: true,\n            requestStart(e: ResizableRequestParam) {\n                return { datas, parentDirection: e.direction || [1, 1], parentIsWidth: e?.horizontal ?? true };\n            },\n            request(e: ResizableRequestParam) {\n                if (\"offsetWidth\" in e) {\n                    distWidth = e.offsetWidth! - rect.offsetWidth;\n                } else if (\"deltaWidth\" in e) {\n                    distWidth += e.deltaWidth!;\n                }\n                if (\"offsetHeight\" in e) {\n                    distHeight = e.offsetHeight! - rect.offsetHeight;\n                } else if (\"deltaHeight\" in e) {\n                    distHeight += e.deltaHeight!;\n                }\n\n\n                return { datas, parentDist: [distWidth, distHeight], parentKeepRatio: e.keepRatio };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n    unset(moveable: MoveableManagerInterface<any, {}>) {\n        moveable.state.gestos.resizable = null;\n    },\n};\n\n/**\n * Whether or not target can be resized.\n * @name Moveable.Resizable#resizable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize. If throttleResize is set to less than 1, the target may shake.\n * @name Moveable.Resizable#throttleResize\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 1,\n * });\n *\n * moveable.throttleResize = 0;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height.\n * @name Moveable.Resizable#keepRatio\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * Set directions to show the control box.\n * @name Moveable.Resizable#renderDirections\n * @default [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"]\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * Function to convert size for resize\n * @name Moveable.Resizable#resizeFormat\n * @default oneself\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   resizeFormat: v => v,\n * });\n *\n * moveable.resizeFormat = (size: number[]) => ([Math.trunc(size[0]), Math.trunc(size[1])];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When resizing, `beforeResize` is called before `resize` occurs. In `beforeResize`, you can get and set the pre-value before resizing.\n * @memberof Moveable.Resizable\n * @event beforeResize\n * @param {Moveable.Resizable.OnBeforeResize} - Parameters for the `beforeResize` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"beforeResize\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"resize\", ({ target, width, height, drag }) => {\n *     target.style.width = `${width}px`;\n *     target.style.height = `${height}px`;\n *     target.style.transform = drag.transform;\n * });\n */\n\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group resize starts, the `resizeGroupStart` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroupStart\n* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroupStart\", ({ targets }) => {\n*     console.log(\"onResizeGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group resize, the `resizeGroup` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroup\n* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroup\", ({ targets, events }) => {\n*     console.log(\"onResizeGroup\", targets);\n*     events.forEach(ev => {\n*         const offset = [\n*             direction[0] < 0 ? -ev.delta[0] : 0,\n*             direction[1] < 0 ? -ev.delta[1] : 0,\n*         ];\n*         // ev.drag is a drag event that occurs when the group resize.\n*         const left = offset[0] + ev.drag.beforeDist[0];\n*         const top = offset[1] + ev.drag.beforeDist[1];\n*         const width = ev.width;\n*         const top = ev.top;\n*     });\n* });\n*/\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    prefix, triggerEvent, fillParams,\n    calculatePosition, fillEndParams, getRotationRad, getRefTargets,\n    catchEvent, getProps, calculateMoveableClientPositions,\n    fillAfterTransform,\n} from \"../utils\";\nimport {\n    IObject, hasClass, getRad,\n    throttle,\n    getDist,\n    getKeys,\n    isArray,\n} from \"@daybrush/utils\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate,\n    OnRotateEnd, MoveableClientRect, SnappableProps,\n    SnappableState, MoveableManagerInterface, MoveableGroupInterface, DraggableProps,\n    OnBeforeRotate,\n    OnBeforeRotateGroup,\n    OnResizeStart,\n    OnResize,\n    TransformObject,\n    OnDragStart,\n} from \"../types\";\nimport { triggerChildAbles } from \"../groupUtils\";\nimport { calculate, convertPositionMatrix, getOrigin, minus, plus, rotate as rotateMatrix } from \"@scena/matrix\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\nimport { checkSnapRotate } from \"./Snappable\";\nimport {\n    fillTransformStartEvent,\n    convertTransformFormat, getRotateDist,\n    getDirectionOffset,\n    fillTransformEvent,\n    setDefaultTransformIndex,\n    resolveTransformEvent,\n    getTransformDirection,\n    getPosByDirection,\n    getDirectionByPos,\n} from \"../gesto/GestoUtils\";\nimport { DirectionControlInfo, renderAroundControls, renderDirectionControlsByInfos } from \"../renderDirections\";\nimport { DIRECTIONS, DIRECTION_REGION_TO_DIRECTION } from \"../consts\";\nimport Resizable from \"./Resizable\";\nimport Draggable from \"./Draggable\";\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\nfunction setRotateStartInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: IObject<any>, clientX: number, clientY: number,\n    rect: MoveableClientRect,\n) {\n    const groupable = moveable.props.groupable;\n    const state = moveable.state;\n    const n = state.is3d ? 4 : 3;\n    const origin = datas.origin;\n    const nextOrigin = calculatePosition(\n        moveable.state.rootMatrix,\n        // TO-DO #710\n        minus([origin[0], origin[1]], groupable ? [0, 0] : [state.left, state.top]),\n        n,\n    );\n    const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\n    datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.defaultDeg = datas.prevDeg;\n    datas.prevSnapDeg = 0;\n    datas.loop = 0;\n    datas.startDist = getDist(startAbsoluteOrigin, [clientX, clientY]);\n}\n\nfunction getAbsoluteDist(\n    deg: number,\n    direction: number,\n    datas: IObject<any>,\n) {\n    const {\n        defaultDeg,\n        prevDeg,\n    } = datas;\n\n\n    let normalizedPrevDeg = prevDeg % 360;\n    let loop = Math.floor(prevDeg / 360);\n\n    if (normalizedPrevDeg < 0) {\n        normalizedPrevDeg += 360;\n    }\n\n    if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++loop;\n    } else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --loop;\n    }\n    const dist = direction * (loop * 360 + deg - defaultDeg);\n\n    datas.prevDeg = defaultDeg + dist;\n\n    return dist;\n}\nfunction getAbsoluteDistByClient(\n    clientX: number, clientY: number,\n    direction: number,\n    datas: IObject<any>,\n) {\n    return getAbsoluteDist(\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        datas,\n    );\n}\nfunction getRotateInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    dist: number,\n    startValue: number,\n    checkSnap?: boolean,\n) {\n    const {\n        throttleRotate = 0,\n    } = moveable.props;\n    const prevSnapDeg = datas.prevSnapDeg;\n    let snapRotation = 0;\n    let isSnap = false;\n\n    if (checkSnap) {\n        const result = checkSnapRotate(moveable, moveableRect, dist);\n\n        isSnap = result.isSnap;\n        snapRotation = startValue + result.rotation;\n    }\n\n    if (!isSnap) {\n        snapRotation = throttle(startValue + dist, throttleRotate);\n    }\n    const snapDeg = snapRotation - startValue;\n\n    datas.prevSnapDeg = snapDeg;\n\n    return [snapDeg - prevSnapDeg, snapDeg, snapRotation];\n\n\n}\n\nexport function getReversePositionX(dir: string) {\n    if (dir === \"left\") {\n        return \"right\";\n    } else if (dir === \"right\") {\n        return \"left\";\n    }\n    return dir;\n}\nexport function getReversePositionY(dir: string) {\n    if (dir === \"top\") {\n        return \"bottom\";\n    } else if (dir === \"bottom\") {\n        return \"top\";\n    }\n    return dir;\n}\nexport function getRotationPositions(\n    rotationPosition: RotatableProps[\"rotationPosition\"],\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number,\n): [number[], number][] {\n    if (rotationPosition === \"none\") {\n        return [];\n    }\n    if (isArray(rotationPosition)) {\n        return rotationPosition.map(child => getRotationPositions(\n            child,\n            [pos1, pos2, pos3, pos4],\n            direction,\n        )[0]);\n    }\n    const [dir1, dir2] = (rotationPosition || \"top\").split(\"-\");\n    let radPoses = [pos1, pos2];\n\n    if (dir1 === \"left\") {\n        radPoses = [pos3, pos1];\n    } else if (dir1 === \"right\") {\n        radPoses = [pos2, pos4];\n    } else if (dir1 === \"bottom\") {\n        radPoses = [pos4, pos3];\n    }\n    let pos = [\n        (radPoses[0][0] + radPoses[1][0]) / 2,\n        (radPoses[0][1] + radPoses[1][1]) / 2,\n    ];\n    const rad = getRotationRad(radPoses, direction);\n    if (dir2) {\n        const isStart = dir2 === \"top\" || dir2 === \"left\";\n        const isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n\n        pos = radPoses[(isStart && !isReverse) || (!isStart && isReverse) ? 0 : 1];\n    }\n    return [[pos, rad]];\n}\n\nexport function dragControlCondition(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n    if (e.isRequest) {\n        return e.requestAble === \"rotatable\";\n    }\n    const target = e.inputEvent.target as HTMLElement;\n    if (\n        hasClass(target, prefix(\"rotation-control\"))\n        || hasClass(target, prefix(\"around-control\"))\n        || (hasClass(target, prefix(\"control\")) && hasClass(target, prefix(\"rotatable\")))\n    ) {\n        return true;\n    }\n    const rotationTarget = moveable.props.rotationTarget;\n\n    if (rotationTarget) {\n        return getRefTargets(rotationTarget, true).some(element => {\n            if (!element) {\n                return false;\n            }\n            return target === element || target.contains(element);\n        });\n    }\n    return false;\n}\n\nconst directionCSS = DIRECTIONS.map(dir => {\n    let top = \"\";\n    let left = \"\";\n    let originX = \"center\";\n    let originY = \"center\";\n\n    if (dir.indexOf(\"n\") > -1) {\n        top = \"top: -20px;\";\n        originY = \"bottom\";\n    }\n    if (dir.indexOf(\"s\") > -1) {\n        top = \"top: 0px;\";\n        originY = \"top\";\n    }\n    if (dir.indexOf(\"w\") > -1) {\n        left = \"left: -20px;\";\n        originX = \"right\";\n    }\n    if (dir.indexOf(\"e\") > -1) {\n        left = \"left: 0px;\";\n        originX = \"left\";\n    }\n    return `.around-control[data-direction*=\"${dir}\"] {\n        ${left}${top}\n        transform-origin: ${originX} ${originY};\n    }`;\n}).join(\"\\n\");\nconst css = `.rotation {\n    position: absolute;\n    height: 40px;\n    width: 1px;\n    transform-origin: 50% 100%;\n    height: calc(40px * var(--zoom));\n    top: auto;\n    left: 0;\n    bottom: 100%;\n    will-change: transform;\n}\n.rotation .rotation-line {\n    display: block;\n    width: 100%;\n    height: 100%;\n    transform-origin: 50% 50%;\n}\n.rotation .rotation-control {\n    border-color: #4af;\n    border-color: var(--moveable-color);\n    background:#fff;\n    cursor: alias;\n}\n:global .view-rotation-dragging, .rotatable.direction.control {\n    cursor: alias;\n}\n.around-control {\n    position: absolute;\n    will-change: transform;\n    width: 20px;\n    height: 20px;\n    left: -10px;\n    top: -10px;\n    box-sizing: border-box;\n    background: transparent;\n    z-index: 8;\n    cursor: alias;\n    transform-origin: center center;\n}\n.rotatable.direction.control.move {\n    cursor: move;\n}\n${directionCSS}\n`;\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n    props: {\n        rotatable: Boolean,\n        rotationPosition: String,\n        throttleRotate: Number,\n        renderDirections: Object,\n        rotationTarget: Object,\n        rotateAroundControls: Boolean,\n        edge: Boolean,\n        resolveAblesWithRotatable: Object,\n    } as const,\n    events: {\n        onRotateStart: \"rotateStart\",\n        onBeforeRotate: \"beforeRotate\",\n        onRotate: \"rotate\",\n        onRotateEnd: \"rotateEnd\",\n        onRotateGroupStart: \"rotateGroupStart\",\n        onBeforeRotateGroup: \"beforeRotateGroup\",\n        onRotateGroup: \"rotateGroup\",\n        onRotateGroupEnd: \"rotateGroupEnd\",\n    } as const,\n    css: [css],\n    viewClassName(moveable: MoveableManagerInterface<RotatableProps>) {\n        if (!moveable.isDragging(\"rotatable\")) {\n            return \"\";\n        }\n        return prefix(\"view-rotation-dragging\");\n    },\n    render(moveable: MoveableManagerInterface<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n            zoom,\n            renderDirections,\n            rotateAroundControls,\n            resolveAblesWithRotatable,\n        } = getProps(moveable.props, \"rotatable\");\n        const {\n            renderPoses,\n            direction,\n        } = moveable.getState();\n        if (!rotatable) {\n            return null;\n        }\n        const positions = getRotationPositions(rotationPosition!, renderPoses, direction);\n        const jsxs: any[] = [];\n\n        positions.forEach(([pos, rad], i) => {\n            jsxs.push(\n                <div key={`rotation${i}`} className={prefix(\"rotation\")} style={{\n                    // tslint:disable-next-line: max-line-length\n                    transform: `translate(-50%) translate(${pos[0]}px, ${pos[1]}px) rotate(${rad}rad)`,\n                }}>\n                    <div className={prefix(\"line rotation-line\")} style={{\n                        transform: `scaleX(${zoom})`,\n                    }}></div>\n                    <div className={prefix(\"control rotation-control\")} style={{\n                        transform: `translate(0.5px) scale(${zoom})`,\n                    }}></div>\n                </div>\n            );\n        });\n        if (renderDirections) {\n            const ables = getKeys(resolveAblesWithRotatable || {});\n            const resolveMap: Record<string, string> = {};\n\n            ables.forEach(name => {\n                resolveAblesWithRotatable![name]!.forEach(direction => {\n                    resolveMap[direction] = name;\n                });\n            });\n\n            let directionControlInfos: DirectionControlInfo[] = [];\n\n            if (isArray(renderDirections)) {\n                directionControlInfos = renderDirections.map(dir => {\n                    const able = resolveMap[dir];\n\n                    return {\n                        data: able ? { resolve: able } : {},\n                        classNames: able ? [`move`] : [],\n                        dir,\n                    };\n                });\n            }\n\n            jsxs.push(...renderDirectionControlsByInfos(\n                moveable,\n                \"rotatable\",\n                directionControlInfos,\n                React,\n            ));\n        }\n        if (rotateAroundControls) {\n            jsxs.push(...renderAroundControls(moveable, React));\n        }\n\n        return jsxs;\n    },\n    dragControlCondition: dragControlCondition as (moveable: any, e: any) => boolean,\n    dragControlStart(\n        moveable: MoveableManagerInterface<RotatableProps & SnappableProps & DraggableProps, SnappableState>,\n        e: any) {\n        const {\n            datas,\n            clientX, clientY,\n            parentRotate, parentFlag, isPinch,\n            isRequest,\n        } = e;\n        const state = moveable.state;\n        const {\n            target, left, top,\n            direction, beforeDirection, targetTransform,\n            moveableClientRect,\n            offsetMatrix,\n            targetMatrix,\n            allMatrix,\n            width,\n            height,\n        } = state;\n\n        if (!isRequest && !target) {\n            return false;\n        }\n\n        const rect = moveable.getRect();\n        datas.rect = rect;\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n        let setFixedPosition = (fixedPosition: number[]) => {\n            const {\n                allMatrix,\n                is3d,\n                width,\n                height,\n            } = moveable.state;\n            const fixedDirection = getDirectionByPos(fixedPosition, width, height);\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = calculatePosition(allMatrix, fixedPosition, is3d ? 4 : 3);\n\n            if (resizeStart) {\n                resizeStart.setFixedPosition(fixedPosition);\n            }\n        };\n        let setFixedDirection: OnRotateStart[\"setFixedDirection\"] = (fixedDirection: number[]) => {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getDirectionOffset(moveable, fixedDirection);\n\n            if (resizeStart) {\n                resizeStart.setFixedDirection(fixedDirection);\n            }\n        };\n        let startClientX = clientX;\n        let startClientY = clientY;\n\n        if (isRequest || isPinch || parentFlag) {\n            const externalRotate = parentRotate || 0;\n\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin,\n                prevDeg: externalRotate,\n                defaultDeg: externalRotate,\n                prevSnapDeg: 0,\n                startDist: 0,\n            };\n            datas.afterInfo = {\n                ...datas.beforeInfo,\n                origin: rect.origin,\n            };\n            datas.absoluteInfo = {\n                ...datas.beforeInfo,\n                origin: rect.origin,\n                startValue: externalRotate,\n            };\n        } else {\n            const inputTarget = e.inputEvent?.target;\n\n            if (inputTarget) {\n                const regionDirection = inputTarget.getAttribute(\"data-direction\") || \"\";\n                const controlDirection = DIRECTION_REGION_TO_DIRECTION[regionDirection];\n\n                if (controlDirection) {\n                    datas.isControl = true;\n                    datas.isAroundControl = hasClass(inputTarget, prefix(\"around-control\"));\n                    datas.controlDirection = controlDirection;\n                    const resolve = inputTarget.getAttribute(\"data-resolve\");\n\n                    if (resolve) {\n                        datas.resolveAble = resolve;\n                    }\n\n                    const clientPoses = calculateMoveableClientPositions(\n                        state.rootMatrix,\n                        state.renderPoses,\n                        moveableClientRect,\n                    );\n\n\n                    [startClientX, startClientY] = getPosByDirection(clientPoses, controlDirection);\n                }\n            }\n            datas.beforeInfo = { origin: rect.beforeOrigin };\n            datas.afterInfo = { origin: rect.origin };\n            datas.absoluteInfo = {\n                origin: rect.origin,\n                startValue: rect.rotation,\n            };\n\n            const originalFixedPosition = setFixedPosition;\n\n            setFixedPosition = (fixedPosition: number[]) => {\n                const n = state.is3d ? 4 : 3;\n                const [originX, originY] = plus(getOrigin(targetMatrix, n), fixedPosition);\n                const fixedBeforeOrigin = calculate(\n                    offsetMatrix,\n                    convertPositionMatrix([originX, originY], n),\n                );\n                const fixedAfterOrigin = calculate(\n                    allMatrix,\n                    convertPositionMatrix([fixedPosition[0], fixedPosition[1]], n),\n                );\n                originalFixedPosition(fixedPosition);\n                const posDelta = state.posDelta;\n\n                datas.beforeInfo.origin = minus(fixedBeforeOrigin, posDelta);\n                datas.afterInfo.origin = minus(fixedAfterOrigin, posDelta);\n                datas.absoluteInfo.origin = minus(fixedAfterOrigin, posDelta);\n\n                setRotateStartInfo(moveable, datas.beforeInfo, startClientX, startClientY, moveableClientRect);\n                setRotateStartInfo(moveable, datas.afterInfo, startClientX, startClientY, moveableClientRect);\n                setRotateStartInfo(moveable, datas.absoluteInfo, startClientX, startClientY, moveableClientRect);\n            };\n            setFixedDirection = (fixedDirection: number[]) => {\n                const fixedPosition = getPosByDirection([\n                    [0, 0],\n                    [width, 0],\n                    [0, height],\n                    [width, height],\n                ], fixedDirection);\n\n                setFixedPosition(fixedPosition);\n            };\n        }\n\n        datas.startClientX = startClientX;\n        datas.startClientY = startClientY;\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startValue = 0;\n        datas.datas = {};\n\n        setDefaultTransformIndex(e, \"rotate\");\n\n        let dragStart: OnDragStart | false = false;\n        let resizeStart: OnResizeStart | false = false;\n\n        if (datas.isControl && datas.resolveAble) {\n            const resolveAble = datas.resolveAble;\n\n            if  (resolveAble === \"resizable\") {\n                resizeStart = Resizable.dragControlStart(moveable, {\n                    ...(new CustomGesto(\"resizable\").dragStart([0, 0], e)),\n                    parentPosition: datas.controlPosition,\n                    parentFixedPosition: datas.fixedPosition,\n                });\n            }\n        }\n\n        if (!resizeStart) {\n            dragStart = Draggable.dragStart!(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            );\n        }\n\n        setFixedPosition(state.transformOrigin);\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startValue = rotatation * Math.PI / 180;\n            },\n            setFixedDirection,\n            setFixedPosition,\n            ...fillTransformStartEvent(e),\n            dragStart,\n            resizeStart,\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        state.snapRenderInfo = {\n            request: e.isRequest,\n        };\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<RotatableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, clientDistX, clientDistY, parentRotate, parentFlag, isPinch, groupDelta } = e;\n        const {\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            absoluteInfo,\n            isRotate,\n            startValue,\n            rect,\n            startClientX,\n            startClientY,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n\n        resolveTransformEvent(e, \"rotate\");\n\n        const targetDirection = getTransformDirection(e);\n        const direction = beforeDirection * targetDirection;\n        const {\n            parentMoveable,\n        } = moveable.props;\n\n\n        let beforeDelta = 0;\n        let beforeDist: number;\n        let beforeRotation: number;\n\n        let delta = 0;\n        let dist: number;\n        let rotation: number;\n\n        let absoluteDelta = 0;\n        let absoluteDist: number;\n        let absoluteRotation: number;\n\n        const startRotation = 180 / Math.PI * startValue;\n        const absoluteStartRotation = absoluteInfo.startValue;\n        let isSnap = false;\n        const nextClientX = startClientX + clientDistX;\n        const nextClientY = startClientY + clientDistY;\n\n        if (!parentFlag && \"parentDist\" in e) {\n            const parentDist = e.parentDist;\n\n            beforeDist = parentDist;\n            dist = parentDist;\n            absoluteDist = parentDist;\n        } else if (isPinch || parentFlag) {\n            beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);\n            dist = getAbsoluteDist(parentRotate, direction, afterInfo);\n            absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);\n        } else {\n            beforeDist = getAbsoluteDistByClient(nextClientX, nextClientY, beforeDirection, beforeInfo);\n            dist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, afterInfo);\n            absoluteDist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, absoluteInfo);\n            isSnap = true;\n        }\n        beforeRotation = startRotation + beforeDist;\n        rotation = startRotation + dist;\n        absoluteRotation = absoluteStartRotation + absoluteDist;\n\n\n        triggerEvent(moveable, \"onBeforeRotate\", fillParams<OnBeforeRotate>(moveable, e, {\n            beforeRotation,\n            rotation,\n            absoluteRotation,\n            setRotation(nextRotation: number) {\n                dist = nextRotation - startRotation;\n                beforeDist = dist;\n                absoluteDist = dist;\n            },\n        }, true));\n\n        [\n            beforeDelta,\n            beforeDist,\n            beforeRotation,\n        ] = getRotateInfo(moveable, rect, beforeInfo, beforeDist, startRotation, isSnap);\n\n        [\n            delta,\n            dist,\n            rotation,\n        ] = getRotateInfo(moveable, rect, afterInfo, dist, startRotation, isSnap);\n\n        [\n            absoluteDelta,\n            absoluteDist,\n            absoluteRotation,\n        ] = getRotateInfo(moveable, rect, absoluteInfo, absoluteDist, absoluteStartRotation, isSnap);\n\n        if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n\n        const nextTransform = convertTransformFormat(\n            datas, `rotate(${rotation}deg)`, `rotate(${dist}deg)`,\n        );\n\n        const inverseDist = getRotateDist(moveable, dist, datas);\n        const inverseDelta = minus(\n            plus(groupDelta || [0, 0], inverseDist),\n            datas.prevInverseDist || [0, 0],\n        );\n        datas.prevInverseDist = inverseDist;\n\n        datas.requestValue = null;\n\n        const dragEvent = fillTransformEvent(\n            moveable,\n            nextTransform,\n            inverseDelta,\n            isPinch,\n            e,\n        );\n\n        let transformEvent: TransformObject = dragEvent;\n        const parentDistance = getDist(\n            [nextClientX, nextClientY],\n            absoluteInfo.startAbsoluteOrigin,\n        ) - absoluteInfo.startDist;\n\n        let resize: OnResize | undefined = undefined;\n\n        if (datas.resolveAble === \"resizable\") {\n            const resizeEvent = Resizable.dragControl(\n                moveable,\n                {\n                    ...setCustomDrag(e, moveable.state, [e.deltaX, e.deltaY], !!isPinch, false, \"resizable\"),\n                    resolveMatrix: true,\n                    parentDistance,\n                },\n            );\n\n            if (resizeEvent) {\n                resize = resizeEvent;\n                transformEvent = fillAfterTransform(transformEvent, resizeEvent, e);\n            }\n        }\n\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate: rotation,\n            rotation,\n\n            beforeDist,\n            beforeDelta,\n            beforeRotate: beforeRotation,\n            beforeRotation,\n\n            absoluteDist,\n            absoluteDelta,\n            absoluteRotate: absoluteRotation,\n            absoluteRotation,\n\n            isPinch: !!isPinch,\n            resize,\n            ...dragEvent,\n            ...transformEvent,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        datas.isRotate = false;\n\n        const params = fillEndParams<OnRotateEnd>(moveable, e, {});\n\n        triggerEvent(moveable, \"onRotateEnd\", params);\n        return params;\n    },\n    dragGroupControlCondition: dragControlCondition as (moveable: any, e: any) => boolean,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        params.set(datas.beforeDirection * moveable.rotation);\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                ev.datas.startGroupClient = childClient;\n                ev.datas.groupClient = childClient;\n                return { ...ev, parentRotate: 0 };\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        catchEvent(moveable, \"onBeforeRotate\", parentEvent => {\n            triggerEvent(moveable, \"onBeforeRotateGroup\", fillParams<OnBeforeRotateGroup>(moveable, e, {\n                ...parentEvent,\n                targets: moveable.props.targets!,\n            }, true));\n        });\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const direction = datas.beforeDirection;\n        const parentRotate = params.beforeDist;\n        const rad = parentRotate / 180 * Math.PI;\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const startGroupClient = ev.datas.startGroupClient;\n                const [prevClientX, prevClientY] = ev.datas.groupClient;\n                const [clientX, clientY] = rotateMatrix(startGroupClient, rad * direction);\n                const delta = [clientX - prevClientX, clientY - prevClientY];\n\n                ev.datas.groupClient = [clientX, clientY];\n                return { ...ev, parentRotate, groupDelta: delta };\n            },\n        );\n        moveable.rotation = direction * params.beforeRotation;\n\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            set(rotation: number) {\n                moveable.rotation = rotation;\n            },\n            setGroupRotation(rotation: number) {\n                moveable.rotation = rotation;\n            },\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams = fillEndParams<OnRotateGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n     *\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * requester.request({ rotate: 10 });\n     * requester.request({ rotate: 20 });\n     * requester.request({ rotate: 30 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<RotatableProps>) {\n        const datas = {};\n        let distRotate = 0;\n\n        const startRotation = moveable.getRotation();\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaRotate\" in e) {\n                    distRotate += e.deltaRotate;\n                } else if (\"rotate\" in e) {\n                    distRotate = e.rotate - startRotation;\n                }\n\n                return { datas, parentDist: distRotate };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n* When rotating, the rotate event is called.\n* @memberof Moveable.Rotatable\n* @event rotate\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { rotatable: true });\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\n*     target.style.transform = transform;\n* });\n*/\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n* When the group rotate, the `rotateGroup` event is called.\n* @memberof Moveable.Rotatable\n* @event rotateGroup\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     rotatable: true\n* });\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\n*     console.log(\"onRotateGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group rotate.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const deg = ev.beforeDist;\n*     });\n* });\n*/\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    triggerEvent, multiply2,\n    fillParams, fillEndParams, getAbsolutePosesByState,\n    catchEvent, getOffsetSizeDist, getDirectionCondition, getDirectionViewClassName, getTotalDirection,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport {\n    setDragStart, resolveTransformEvent,\n    convertTransformFormat,\n    getScaleDist,\n    fillTransformStartEvent,\n    fillTransformEvent,\n    getAbsolutePosition,\n    setDefaultTransformIndex,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { getRenderDirections } from \"../renderDirections\";\nimport {\n    ScalableProps, OnScaleGroup, OnScaleGroupEnd,\n    OnScaleGroupStart, DraggableProps, OnDragStart,\n    SnappableState, GroupableProps, OnScaleStart,\n    OnScale, OnScaleEnd, MoveableManagerInterface, MoveableGroupInterface,\n    OnBeforeScaleGroup,\n    OnBeforeScale,\n} from \"../types\";\nimport {\n    fillChildEvents,\n    triggerChildAbles,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { calculate, createRotateMatrix, plus, minus } from \"@scena/matrix\";\nimport CustomGesto from \"../gesto/CustomGesto\";\nimport { checkSnapScale } from \"./Snappable\";\nimport {\n    isArray, IObject, getDist,\n    throttle,\n} from \"@daybrush/utils\";\n\nconst directionCondition = getDirectionCondition(\"scalable\");\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        scalable: Boolean,\n        throttleScale: Number,\n        renderDirections: String,\n        keepRatio: Boolean,\n        edge: Boolean,\n    } as const,\n    events: {\n        onScaleStart: \"scaleStart\",\n        onBeforeScale: \"beforeScale\",\n        onScale: \"scale\",\n        onScaleEnd: \"scaleEnd\",\n        onScaleGroupStart: \"scaleGroupStart\",\n        onBeforeScaleGroup: \"beforeScaleGroup\",\n        onScaleGroup: \"scaleGroup\",\n        onScaleGroupEnd: \"scaleGroupEnd\",\n    } as const,\n    render: getRenderDirections(\"scalable\"),\n    dragControlCondition: directionCondition,\n    viewClassName: getDirectionViewClassName(\"scalable\"),\n    dragControlStart(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n        const { datas, isPinch, inputEvent, parentDirection } = e;\n\n        const direction = getTotalDirection(\n            parentDirection,\n            isPinch,\n            inputEvent,\n            datas,\n        );\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n            pos1,\n            pos2,\n            pos4,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!isPinch) {\n            setDragStart(moveable, e);\n        }\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.startValue = [1, 1];\n\n        const scaleWidth = getDist(pos1, pos2);\n        const scaleHeight = getDist(pos2, pos4);\n        const isWidth = (!direction[0] && !direction[1]) || direction[0] || !direction[1];\n\n\n        datas.scaleWidth = scaleWidth;\n        datas.scaleHeight = scaleHeight;\n        datas.scaleXRatio = scaleWidth / width;\n        datas.scaleYRatio = scaleHeight / height;\n\n        setDefaultTransformIndex(e, \"scale\");\n\n\n\n        datas.isWidth = isWidth;\n\n\n        function setRatio(ratio: number) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\n        function setFixedDirection(fixedDirection: number[]) {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);\n        }\n\n\n        datas.setFixedDirection = setFixedDirection;\n        setRatio(getDist(pos1, pos2) / getDist(pos2, pos4));\n        setFixedDirection([-direction[0], -direction[1]]);\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startValue = scale;\n            },\n            setRatio,\n            setFixedDirection,\n            ...fillTransformStartEvent(e),\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        datas.startFixedDirection = datas.fixedDirection;\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        resolveTransformEvent(e, \"scale\");\n        const {\n            datas,\n            parentKeepRatio,\n            parentFlag, isPinch,\n            dragClient,\n            isRequest,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            startOffsetWidth,\n            startOffsetHeight,\n            isScale,\n            startValue,\n            isWidth,\n            ratio,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const props = moveable.props;\n        const {\n            throttleScale,\n            parentMoveable,\n        } = props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = (ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) || false;\n        const state = moveable.state;\n\n        function getNextScale() {\n            const {\n                distWidth,\n                distHeight,\n            } = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n\n\n            let scaleX = startOffsetWidth ? (startOffsetWidth + distWidth) / startOffsetWidth : 1;\n            let scaleY = startOffsetHeight ? (startOffsetHeight + distHeight) / startOffsetHeight : 1;\n\n            scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];\n            scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];\n\n            if (scaleX === 0) {\n                scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n            }\n            if (scaleY === 0) {\n                scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n            }\n            return [scaleX, scaleY];\n        }\n\n\n        let scale = getNextScale();\n\n        if (!isPinch && moveable.props.groupable) {\n            const snapRenderInfo = state.snapRenderInfo || {};\n            const stateDirection = snapRenderInfo.direction;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = { direction, request: e.isRequest };\n            }\n        }\n\n        triggerEvent(moveable, \"onBeforeScale\", fillParams<OnBeforeScale>(moveable, e, {\n            scale,\n            setFixedDirection(nextFixedDirection: number[]) {\n                datas.setFixedDirection(nextFixedDirection);\n\n                scale = getNextScale();\n\n                return scale;\n            },\n            startFixedDirection: datas.startFixedDirection,\n            setScale(nextScale: number[]) {\n                scale = nextScale;\n            },\n        }, true));\n\n        const dist = [scale[0] / startValue[0], scale[1] / startValue[1]];\n        let fixedPosition = dragClient;\n        let snapDist = [0, 0];\n\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n        if (!isPinch) {\n            snapDist = checkSnapScale(\n                moveable,\n                dist,\n                direction,\n                isRequest,\n                datas,\n            );\n        }\n\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0] * startOffsetWidth) > Math.abs(snapDist[1] * startOffsetHeight)) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    dist[0] = throttle(dist[0] * startValue[0], throttleScale!) / startValue[0];\n                } else {\n                    dist[1] = throttle(dist[1] * startValue[1], throttleScale!) / startValue[1];\n                }\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                dist[0] += snapDist[0];\n                const snapHeight = startOffsetWidth * dist[0] * startValue[0] / ratio;\n\n                dist[1] = snapHeight / startOffsetHeight / startValue[1];\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                dist[1] += snapDist[1];\n                const snapWidth = startOffsetHeight * dist[1] * startValue[1] * ratio;\n\n                dist[0] = snapWidth / startOffsetWidth / startValue[0];\n            }\n        } else {\n            dist[0] += snapDist[0];\n            dist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                dist[0] = throttle(dist[0] * startValue[0], throttleScale!) / startValue[0];\n            }\n            if (!snapDist[1]) {\n                dist[1] = throttle(dist[1] * startValue[1], throttleScale!) / startValue[1];\n            }\n        }\n\n        if (dist[0] === 0) {\n            dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (dist[1] === 0) {\n            dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];\n        scale = multiply2(dist, startValue);\n\n        const inverseDist = getScaleDist(moveable, dist, datas.fixedDirection, fixedPosition, datas);\n        const inverseDelta = minus(inverseDist, datas.prevInverseDist || [0, 0]);\n\n        datas.prevDist = dist;\n        datas.prevInverseDist = inverseDist;\n        if (\n            scale[0] === prevDist[0] && scale[1] === prevDist[1]\n            && inverseDelta.every(num => !num)\n            && !parentMoveable\n        ) {\n            return false;\n        }\n\n\n        const nextTransform = convertTransformFormat(\n            datas, `scale(${scale.join(\", \")})`, `scale(${dist.join(\", \")})`);\n        const params = fillParams<OnScale>(moveable, e, {\n            offsetWidth: startOffsetWidth,\n            offsetHeight: startOffsetHeight,\n            direction,\n\n            scale,\n            dist,\n            delta,\n\n            isPinch: !!isPinch,\n            ...fillTransformEvent(\n                moveable,\n                nextTransform,\n                inverseDelta,\n                isPinch,\n                e,\n            ),\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScalableProps>, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        const scaleEndParam = fillEndParams<OnScaleEnd>(moveable, e, {});\n        triggerEvent(moveable, \"onScaleEnd\", scaleEndParam);\n        return scaleEndParam;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n\n        function setDist(child: MoveableManagerInterface, ev: any) {\n            const fixedDirection = datas.fixedDirection;\n            const fixedPosition = datas.fixedPosition;\n            const startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);\n            const pos = getPosByDirection(startPositions, fixedDirection);\n            const [originalX, originalY] = calculate(\n                createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                3,\n            );\n            ev.datas.originalX = originalX;\n            ev.datas.originalY = originalY;\n\n            return ev;\n        }\n\n        datas.moveableScale = moveable.scale;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                return setDist(child, ev);\n            },\n        );\n\n        const setFixedDirection = (fixedDirection: number[]) => {\n            params.setFixedDirection(fixedDirection);\n            events.forEach((ev, i) => {\n                ev.setFixedDirection(fixedDirection);\n                setDist(ev.moveable, originalEvents[i]);\n            });\n        };\n\n        datas.setFixedDirection = setFixedDirection;\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n            setFixedDirection,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n\n        catchEvent(moveable, \"onBeforeScale\", parentEvent => {\n            triggerEvent(moveable, \"onBeforeScaleGroup\", fillParams<OnBeforeScaleGroup>(moveable, e, {\n                ...parentEvent,\n                targets: moveable.props.targets!,\n            }, true));\n        });\n\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n\n        const moveableScale = datas.moveableScale;\n        moveable.scale = [\n            params.scale[0] * moveableScale[0],\n            params.scale[1] * moveableScale[1],\n        ];\n        const keepRatio = moveable.props.keepRatio;\n        const { dist, scale } = params;\n\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [clientX, clientY] = calculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        ev.datas.originalX * dist[0],\n                        ev.datas.originalY * dist[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...ev,\n                    parentDist: null,\n                    parentScale: scale,\n                    parentKeepRatio: keepRatio,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        const events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams = fillEndParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Scalable#request\n     * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                distWidth += e.deltaWidth;\n                distHeight += e.deltaHeight;\n\n                return { datas, parentDist: [distWidth, distHeight], parentKeepRatio: e.keepRatio };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can scaled.\n *\n * @name Moveable.Scalable#scalable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, `beforeScale` is called before `scale` occurs. In `beforeScale`, you can get and set the pre-value before scaling.\n * @memberof Moveable.Scalable\n * @event beforeScale\n * @param {Moveable.Scalable.OnBeforeScale} - Parameters for the `beforeScale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"beforeScale\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n\n/**\n * When scaling, the `scale` event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the `scale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the `scaleEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the `scaleEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group scale starts, the `scaleGroupStart` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroupStart\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\n*     console.log(\"onScaleGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group scale, the `scaleGroup` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroup\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\n*     console.log(\"onScaleGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group scale.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const scaleX = ev.scale[0];\n*         const scaleY = ev.scale[1];\n*     });\n* });\n*/\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    prefix, getLineStyle, getDirection, getAbsolutePosesByState,\n    triggerEvent, fillParams, fillEndParams, getDirectionViewClassName, fillCSSObject,\n} from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    calculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    minus,\n    createWarpMatrix,\n    plus,\n} from \"@scena/matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport {\n    setDragStart, getDragDist, getPosIndexesByDirection, setDefaultTransformIndex,\n    fillTransformStartEvent, resolveTransformEvent,\n    convertTransformFormat, fillOriginalTransform, getTransfromMatrix,\n} from \"../gesto/GestoUtils\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { hasClass, dot, getRad } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirections\";\nimport { hasGuidelines } from \"./snappable/utils\";\nimport { checkMoveableSnapBounds } from \"./snappable/snapBounds\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: {\n        warpable: Boolean,\n        renderDirections: Array,\n        edge: Boolean,\n    } as const,\n    events: {\n        onWarpStart: \"warpStart\",\n        onWarp: \"warp\",\n        onWarpEnd: \"warpEnd\",\n    } as const,\n    viewClassName: getDirectionViewClassName(\"warpable\"),\n    render(moveable: MoveableManagerInterface<ResizableProps & ScalableProps & WarpableProps>, React: Renderer): any[] {\n        const { resizable, scalable, warpable, zoom } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return [];\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")}\n                key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4, zoom)}></div>,\n            ...renderAllDirections(moveable, \"warpable\", React),\n        ];\n    },\n    dragControlCondition(moveable: any, e: any) {\n        if (e.isRequest) {\n            return false;\n        }\n        const target = e.inputEvent.target;\n\n        return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"warpable\"));\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget, datas);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map(p => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => calculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startValue = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(e, \"matrix3d\");\n\n        state.snapRenderInfo = {\n            request: e.isRequest,\n            direction,\n        };\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startValue = matrix;\n            },\n            ...fillTransformStartEvent(e),\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, isRequest } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startValue,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n        resolveTransformEvent(e, \"matrix3d\");\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkMoveableSnapBounds(\n                moveable,\n                isRequest,\n                {\n                    horizontal: selectedPoses.map(pos => pos[1] + distY),\n                    vertical: selectedPoses.map(pos => pos[0] + distX),\n                },\n            );\n\n            distY -= horizontalSnapInfo.offset;\n            distX -= verticalSnapInfo.offset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[2],\n            poses[1],\n            poses[3],\n            nextPoses[0],\n            nextPoses[2],\n            nextPoses[1],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n        // B * A * M\n        const afterMatrix = multiply(targetInverseMatrix, h, 4);\n\n        // B * M * A\n        const matrix = getTransfromMatrix(datas, afterMatrix, true);\n\n        const delta = multiply(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n        const totalMatrix = multiply(startValue, matrix, 4);\n        const nextTransform = convertTransformFormat(\n            datas, `matrix3d(${totalMatrix.join(\", \")})`, `matrix3d(${matrix.join(\", \")})`);\n\n        fillOriginalTransform(e, nextTransform);\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: totalMatrix,\n            dist: matrix,\n            multiply,\n            transform: nextTransform,\n            ...fillCSSObject({\n                transform: nextTransform,\n            }, e),\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillEndParams<OnWarpEnd>(moveable, e, {}));\n        return isDrag;\n    },\n};\n\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n/**\n* Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n* @name Moveable.Warpable#renderDirections\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     warpable: true,\n*     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n* });\n*\n* moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n*/\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable.Warpable\n* @event warpStart\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n","import { prefix } from \"./utils\";\n\nexport const AREA_PIECES = /*#__PURE__*/prefix(\"area-pieces\");\nexport const AREA_PIECE = /*#__PURE__*/prefix(\"area-piece\");\nexport const AVOID = /*#__PURE__*/prefix(\"avoid\");\nexport const VIEW_DRAGGING = prefix(\"view-dragging\");\n","import {\n    createWarpMatrix,\n} from \"@scena/matrix\";\nimport { ref } from \"framework-utils\";\nimport { getRect, calculateInversePosition, makeMatrixCSS, prefix } from \"../utils\";\nimport {\n    Renderer, GroupableProps, DragAreaProps, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { AREA_PIECE, AVOID, AREA_PIECES } from \"../classNames\";\nimport { addClass, removeClass, requestAnimationFrame } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManagerInterface) {\n    const el = moveable.areaElement;\n\n    if (!el) {\n        return;\n    }\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    props: {\n        dragArea: Boolean,\n        passDragArea: Boolean,\n    } as const,\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    render(moveable: MoveableManagerInterface<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable, passDragArea } = moveable.props;\n        const { width, height, renderPoses } = moveable.getState();\n\n        const className = passDragArea ? prefix(\"area\", \"pass\") : prefix(\"area\");\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={className}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            renderPoses[0],\n            renderPoses[1],\n            renderPoses[2],\n            renderPoses[3],\n        );\n        const transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={className} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManagerInterface, { datas, clientX, clientY, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        datas.isDragArea = false;\n        const areaElement = moveable.areaElement;\n        const state = moveable.state;\n        const {\n            moveableClientRect,\n            renderPoses,\n            rootMatrix,\n            is3d,\n        } = state;\n        const { left, top } = moveableClientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n            width,\n            height,\n        } = getRect(renderPoses);\n        const n = is3d ? 4 : 3;\n        let [posX, posY] = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n);\n\n        posX -= relativeLeft;\n        posY -= relativeTop;\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n        state.disableNativeEvent = true;\n        return;\n    },\n    drag(moveable: MoveableManagerInterface, { datas, inputEvent }: any) {\n        this.enableNativeEvent(moveable);\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManagerInterface<DragAreaProps>, e: any) {\n        this.enableNativeEvent(moveable);\n        const { inputEvent, datas } = e;\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            restoreStyle(moveable);\n        }\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<DragAreaProps>,\n        e: any,\n    ) {\n        return this.dragEnd(moveable, e);\n    },\n    unset(moveable: MoveableManagerInterface<DragAreaProps>) {\n        restoreStyle(moveable);\n        moveable.state.disableNativeEvent = false;\n    },\n    enableNativeEvent(moveable: MoveableManagerInterface<DragAreaProps>) {\n        const state = moveable.state;\n        if (state.disableNativeEvent) {\n            requestAnimationFrame(() => {\n                state.disableNativeEvent = false;\n            });\n        }\n    },\n};\n\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n/**\n * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)\n * @name Moveable#passDragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n","import { prefix, getControlTransform } from \"../utils\";\nimport { Renderer, OriginOptions, MoveableManagerInterface } from \"../types\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"origin\", {\n    render(moveable: MoveableManagerInterface<OriginOptions>, React: Renderer): any[] {\n        const { zoom } = moveable.props;\n        const { beforeOrigin, rotation } = moveable.getState();\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, zoom!, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n});\n\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n","\nimport {\n    ScrollableProps, OnScroll, MoveableManagerInterface,\n    MoveableGroupInterface, MoveableRefType,\n} from \"../types\";\nimport { triggerEvent, fillParams, getRefTarget } from \"../utils\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: {\n        scrollable: Boolean,\n        scrollContainer: Object,\n        scrollThreshold: Number,\n        scrollThrottleTime: Number,\n        getScrollPosition: Function,\n        scrollOptions: Object,\n    } as const,\n    events: {\n        onScroll: \"scroll\",\n        onScrollGroup: \"scrollGroup\",\n    } as const,\n    dragRelation: \"strong\",\n    dragStart(moveable: MoveableManagerInterface<ScrollableProps, Record<string, any>>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer() as HTMLElement,\n            scrollOptions,\n        } = props;\n\n        const dragScroll = new DragScroll();\n        const scrollContainerElement = getRefTarget<HTMLElement>(scrollContainer, true);\n\n        e.datas.dragScroll = dragScroll;\n        moveable.state.dragScroll = dragScroll;\n\n        const gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY, inputEvent }) => {\n            moveable[gestoName].scrollBy(offsetX, offsetY, inputEvent.inputEvent, true);\n        }).on(\"scrollDrag\", ({ next }) => {\n            next(moveable[gestoName].getCurrentEvent());\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainerElement!,\n            ...scrollOptions,\n        });\n    },\n    checkScroll(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const dragScroll = e.datas.dragScroll as DragScroll;\n\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer() as MoveableRefType<HTMLElement>,\n            scrollThreshold = 0,\n            scrollThrottleTime = 0,\n            getScrollPosition = getDefaultScrollPosition,\n            scrollOptions,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer!,\n            threshold: scrollThreshold,\n            throttleTime: scrollThrottleTime,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n            ...scrollOptions,\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragStart(moveable, { ...e, isControl: true });\n    },\n    dragControl(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets, isControl: true });\n    },\n    dragGroupControl(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    unset(moveable: MoveableManagerInterface<ScrollableProps, Record<string, any>>) {\n        const state = moveable.state;\n\n        state.dragScroll?.dragEnd();\n        state.dragScroll = null;\n    },\n};\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n","export default {\n    name: \"\",\n    props: {\n        target: Object,\n        dragTarget: Object,\n        container: Object,\n        portalContainer: Object,\n        rootContainer: Object,\n        useResizeObserver: Boolean,\n        zoom: Number,\n        transformOrigin: Array,\n        edge: Object,\n        ables: Array,\n        className: String,\n        pinchThreshold: Number,\n        pinchOutside: Boolean,\n        triggerAblesSimultaneously: Boolean,\n        checkInput: Boolean,\n        cspNonce: String,\n        translateZ: Number,\n        hideDefaultLines: Boolean,\n        props: Object,\n        flushSync: Function,\n        stopPropagation: Boolean,\n        preventClickEventOnDrag: Boolean,\n        preventClickDefault: Boolean,\n        viewContainer: Object,\n        persistData: Object,\n        useAccuratePosition: Boolean,\n        firstRenderState: Object,\n        linePadding: Boolean,\n    } as const,\n    events: {\n        onChangeTargets: \"changeTargets\",\n    } as const,\n};\n","import { prefix, makeMatrixCSS } from \"../utils\";\nimport { Renderer, MoveableManagerInterface } from \"../types\";\nimport { createWarpMatrix } from \"@scena/matrix\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"padding\", {\n    render(moveable: MoveableManagerInterface, React: Renderer): any[] {\n        const props = moveable.props;\n        if (props.dragArea) {\n            return [];\n        }\n        const padding = props.padding || {};\n        const {\n            left = 0,\n            top = 0,\n            right = 0,\n            bottom = 0,\n        } = padding;\n        const {\n            renderPoses,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        } = moveable.getState();\n\n        const poses = [pos1, pos2, pos3, pos4];\n        const paddingDirections: number[][] = [];\n\n        if (left > 0) {\n            paddingDirections.push([0, 2]);\n        }\n        if (top > 0) {\n            paddingDirections.push([0, 1]);\n        }\n        if (right > 0) {\n            paddingDirections.push([1, 3]);\n        }\n        if (bottom > 0) {\n            paddingDirections.push([2, 3]);\n        }\n        return paddingDirections.map(([dir1, dir2], i) => {\n            const paddingPos1 = poses[dir1];\n            const paddingPos2 = poses[dir2];\n            const paddingPos3 = renderPoses[dir1];\n            const paddingPos4 = renderPoses[dir2];\n\n            const h = createWarpMatrix(\n                [0, 0],\n                [100, 0],\n                [0, 100],\n                [100, 100],\n                paddingPos1,\n                paddingPos2,\n                paddingPos3,\n                paddingPos4,\n            );\n            if (!h.length) {\n                return undefined;\n            }\n            return (<div key={`padding${i}`} className={prefix(\"padding\")} style={{\n                transform: makeMatrixCSS(h, true),\n            }}></div>);\n        });\n    },\n});\n\n/**\n * Add padding around the target to increase the drag area.\n * @name Moveable#padding\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n","import { convertCSSSize } from \"../../utils\";\nimport { ControlPose } from \"../../types\";\nimport { convertUnitSize } from \"@daybrush/utils\";\n\nconst RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"] as const;\n\nfunction calculateRatio(values: number[], size: number) {\n    const sumSize = values[0] + values[1];\n    const sumRatio = sumSize > size ? size / sumSize : 1;\n\n    values[0] *= sumRatio;\n    values[1] = size - values[1] * sumRatio;\n\n    return values;\n}\nexport const HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nexport const VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nexport const HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1] as const;\nexport const VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1] as const;\n\nexport function getRadiusStyles(\n    nextPoses: ControlPose[],\n    isRelative: boolean,\n    width: number,\n    height: number,\n    left = 0,\n    top = 0,\n    right: number = width,\n    bottom: number = height,\n) {\n    const clipStyles: string[] = [];\n    let isVertical = false;\n\n    const radiusPoses = nextPoses.filter(pos => !pos.virtual);\n    const raws = radiusPoses.map(posInfo => {\n        const { horizontal, vertical, pos } = posInfo;\n\n        if (vertical && !isVertical) {\n            isVertical = true;\n            clipStyles.push(\"/\");\n        }\n\n        if (isVertical) {\n            const rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n            clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n\n            return rawPos;\n        } else {\n            const rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n            clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n\n            return rawPos;\n        }\n    });\n\n    return {\n        radiusPoses,\n        styles: clipStyles,\n        raws,\n    };\n}\nexport function getRadiusRange(controlPoses: ControlPose[]) {\n    // [start, length]\n    const horizontalRange = [0, 0];\n    const verticalRange = [0, 0];\n    const length = controlPoses.length;\n\n    for (let i = 0; i < length; ++i) {\n        const clipPose = controlPoses[i];\n\n        if (!clipPose.sub) {\n            continue;\n        }\n        if (clipPose.horizontal) {\n            if (horizontalRange[1] === 0) {\n                horizontalRange[0] = i;\n            }\n            horizontalRange[1] = i - horizontalRange[0] + 1;\n            verticalRange[0] = i + 1;\n        }\n        if (clipPose.vertical) {\n            if (verticalRange[1] === 0) {\n                verticalRange[0] = i;\n            }\n            verticalRange[1] = i - verticalRange[0] + 1;\n        }\n    }\n\n    return {\n        horizontalRange,\n        verticalRange,\n    };\n}\nexport function getRadiusValues(\n    values: string[],\n    width: number,\n    height: number,\n    left: number,\n    top: number,\n    minCounts: number[] = [0, 0],\n    full = false,\n): ControlPose[] {\n    const splitIndex = values.indexOf(\"/\");\n    const splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n    const horizontalValues = values.slice(0, splitLength);\n    const verticalValues = values.slice(splitLength + 1);\n    const horizontalValuesLength = horizontalValues.length;\n    const verticalValuesLength = verticalValues.length;\n    const hasVerticalValues = verticalValuesLength > 0;\n    const [\n        nwValue = \"0px\",\n        neValue = nwValue,\n        seValue = nwValue,\n        swValue = neValue,\n    ] = horizontalValues;\n    const [\n        wnValue = nwValue,\n        enValue = hasVerticalValues ? wnValue : neValue,\n        esValue = hasVerticalValues ? wnValue : seValue,\n        wsValue = hasVerticalValues ? enValue : swValue,\n    ] = verticalValues;\n\n    const horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(pos => convertUnitSize(pos, width));\n    const verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(pos => convertUnitSize(pos, height));\n    const horizontalPoses = horizontalRawPoses.slice();\n    const verticalPoses = verticalRawPoses.slice();\n\n    [horizontalPoses[0], horizontalPoses[1]] = calculateRatio(\n        [horizontalPoses[0], horizontalPoses[1]],\n        width,\n    );\n    [horizontalPoses[3], horizontalPoses[2]] = calculateRatio(\n        [horizontalPoses[3], horizontalPoses[2]],\n        width,\n    );\n    [verticalPoses[0], verticalPoses[3]] = calculateRatio(\n        [verticalPoses[0], verticalPoses[3]], height,\n    );\n    [verticalPoses[1], verticalPoses[2]] = calculateRatio(\n        [verticalPoses[1], verticalPoses[2]], height,\n    );\n\n    const nextHorizontalPoses = full\n        ? horizontalPoses\n        : horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValuesLength));\n    const nextVerticalPoses = full\n        ? verticalPoses\n        : verticalPoses.slice(0, Math.max(minCounts[1], verticalValuesLength));\n\n    return [\n        ...nextHorizontalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                virtual: i >= horizontalValuesLength,\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\n                sub: true,\n                raw: horizontalRawPoses[i],\n                direction,\n            };\n        }),\n        ...nextVerticalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                virtual: i >= verticalValuesLength,\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\n                sub: true,\n                raw: verticalRawPoses[i],\n                direction,\n            };\n        }),\n    ];\n}\nexport function removeRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    index: number,\n    startIndex: number,\n    length: number = poses.length,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    const radiuslIndex = index - startIndex;\n    let deleteCount = 0;\n\n    if (radiuslIndex === 0) {\n        deleteCount = length;\n    } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n        deleteCount = horizontalRange[1] - radiuslIndex;\n    } else if (radiuslIndex >= verticalRange[0]) {\n        deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n    } else {\n        return;\n    }\n    controlPoses.splice(index, deleteCount);\n    poses.splice(index, deleteCount);\n}\nexport function addRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    startIndex: number,\n    horizontalIndex: number,\n    verticalIndex: number,\n    distX: number,\n    distY: number,\n    right: number,\n    bottom: number,\n    left = 0,\n    top = 0,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    if (horizontalIndex > -1) {\n        const radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1\n            ? distX - left\n            : right - distX;\n        for (let i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n            const y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n            let x = 0;\n            if (horizontalIndex === i) {\n                x = distX;\n            } else if (i === 0) {\n                x = left + radiusX;\n            } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n                x = right - (poses[startIndex][0] - left);\n            }\n            controlPoses.splice(startIndex + i, 0, {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [x, y],\n            });\n            poses.splice(startIndex + i, 0, [x, y]);\n\n            if (i === 0) {\n                break;\n            }\n        }\n    } else if (verticalIndex > - 1) {\n        const radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1\n            ? distY - top\n            : bottom - distY;\n        if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n            const pos = [\n                left + radiusY,\n                top,\n            ];\n            controlPoses.push({\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n                vertical: 0,\n                pos,\n            });\n            poses.push(pos);\n        }\n\n        const startVerticalIndex = verticalRange[0];\n        for (let i = verticalRange[1]; i <= verticalIndex; ++i) {\n            const x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n            let y = 0;\n            if (verticalIndex === i) {\n                y = distY;\n            } else if (i === 0) {\n                y = top + radiusY;\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n                y = poses[startIndex + startVerticalIndex][1];\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n                y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n            }\n            controlPoses.push({\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [x, y],\n            });\n            poses.push([x, y]);\n            if (i === 0) {\n                break;\n            }\n        }\n    }\n}\nexport function splitRadiusPoses(\n    controlPoses: ControlPose[],\n    raws: number[] = controlPoses.map(pos => pos.raw!),\n) {\n    const horizontals = controlPoses\n        .map((pos, i) => pos.horizontal ? raws[i] : null).filter(pos => pos != null) as number[];\n    const verticals = controlPoses\n        .map((pos, i) => pos.vertical ? raws[i] : null).filter(pos => pos != null) as number[];\n\n    return {\n        horizontals,\n        verticals,\n    };\n}\n","import { splitBracket, splitComma, convertUnitSize, splitSpace, splitUnit } from \"@daybrush/utils\";\nimport { minus } from \"@scena/matrix\";\nimport { convertCSSSize } from \"../../utils\";\nimport { getRadiusStyles, getRadiusValues } from \"../roundable/borderRadius\";\nimport { MoveableManagerInterface, ClippableProps, ControlPose } from \"../../types\";\nimport { getMinMaxs } from \"overlap-area\";\n\n\nexport const CLIP_DIRECTIONS = [\n    [0, -1, \"n\"],\n    [1, 0, \"e\"],\n] as const;\n\nexport const CLIP_RECT_DIRECTIONS = [\n    [-1, -1, \"nw\"],\n    [0, -1, \"n\"],\n    [1, -1, \"ne\"],\n    [1, 0, \"e\"],\n    [1, 1, \"se\"],\n    [0, 1, \"s\"],\n    [-1, 1, \"sw\"],\n    [-1, 0, \"w\"],\n] as const;\n\n// 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nexport function getClipStyles(\n    moveable: MoveableManagerInterface<ClippableProps>,\n    clipPath: ReturnType<typeof getClipPath>,\n    poses: number[][],\n) {\n    const {\n        clipRelative,\n    } = moveable.props;\n    const {\n        width,\n        height,\n    } = moveable.state;\n    const {\n        type: clipType,\n        poses: clipPoses,\n    } = clipPath!;\n\n    const isRect = clipType === \"rect\";\n    const isCircle = clipType === \"circle\";\n    if (clipType === \"polygon\") {\n        return poses.map(pos => `${convertCSSSize(pos[0], width, clipRelative)} ${convertCSSSize(pos[1], height, clipRelative)}`);\n    } else if (isRect || clipType === \"inset\") {\n        const top = poses[1][1];\n        const right = poses[3][0];\n        const left = poses[7][0];\n        const bottom = poses[5][1];\n\n        if (isRect) {\n            return [\n                top,\n                right,\n                bottom,\n                left,\n            ].map(pos => `${pos}px`);\n        }\n        const clipStyles\n            = [top, width - right, height - bottom, left]\n                .map((pos, i) => convertCSSSize(pos, i % 2 ? width : height, clipRelative));\n\n        if (poses.length > 8) {\n            const [subWidth, subHeight] = minus(poses[4], poses[0]);\n\n            clipStyles.push(\"round\", ...getRadiusStyles(\n                clipPoses.slice(8).map((info, i) => {\n                    return {\n                        ...info,\n                        pos: poses[i],\n                    };\n                }),\n                clipRelative!,\n                subWidth,\n                subHeight,\n                left, top, right, bottom,\n            ).styles);\n        }\n        return clipStyles;\n    } else if (isCircle || clipType === \"ellipse\") {\n        const center = poses[0];\n        const ry = convertCSSSize(\n            Math.abs(poses[1][1] - center[1]),\n            isCircle ? Math.sqrt((width * width + height * height) / 2) : height,\n            clipRelative,\n        );\n\n        const clipStyles = isCircle ? [ry]\n            : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];\n\n        clipStyles.push(\n            \"at\", convertCSSSize(center[0], width, clipRelative),\n            convertCSSSize(center[1], height, clipRelative));\n\n        return clipStyles;\n    }\n}\n\nexport function getRectPoses(top: number, right: number, bottom: number, left: number): ControlPose[] {\n    const xs = [left, (left + right) / 2, right];\n    const ys = [top, (top + bottom) / 2, bottom];\n\n    return CLIP_RECT_DIRECTIONS.map(([dirx, diry, dir]) => {\n        const x = xs[dirx + 1];\n        const y = ys[diry + 1];\n        return {\n            vertical: Math.abs(diry),\n            horizontal: Math.abs(dirx),\n            direction: dir,\n            pos: [x, y],\n        };\n    });\n}\n\nexport function getControlSize(\n    controlPoses: ControlPose[],\n) {\n    const xRange = [Infinity, -Infinity];\n    const yRange = [Infinity, -Infinity];\n\n    controlPoses.forEach(({ pos }) => {\n        xRange[0] = Math.min(xRange[0], pos[0]);\n        xRange[1] = Math.max(xRange[1], pos[0]);\n        yRange[0] = Math.min(yRange[0], pos[1]);\n        yRange[1] = Math.max(yRange[1], pos[1]);\n    });\n\n    return [\n        Math.abs(xRange[1] - xRange[0]),\n        Math.abs(yRange[1] - yRange[0]),\n    ];\n}\n\n\nexport function getClipPath(\n    target: HTMLElement | SVGElement | undefined | null,\n    width: number,\n    height: number,\n    defaultClip?: string,\n    customClip?: string,\n) {\n    if (!target) {\n        return;\n    }\n    let clipText: string | undefined = customClip;\n\n    if (!clipText) {\n        const style = getComputedStyle(target!);\n        const clipPath = style.clipPath!;\n\n        clipText = clipPath !== \"none\" ? clipPath : style.clip!;\n    }\n    if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n        clipText = defaultClip;\n\n        if (!clipText) {\n            return;\n        }\n    }\n    const {\n        prefix: clipPrefix = clipText,\n        value = \"\",\n    } = splitBracket(clipText);\n    const isCircle = clipPrefix === \"circle\";\n    let splitter = \" \";\n\n    if (clipPrefix === \"polygon\") {\n        const values = splitComma(value! || `0% 0%, 100% 0%, 100% 100%, 0% 100%`);\n        splitter = \",\";\n\n        const poses: ControlPose[] = values.map(pos => {\n            const [xPos, yPos] = pos.split(\" \");\n\n            return {\n                vertical: 1,\n                horizontal: 1,\n                pos: [\n                    convertUnitSize(xPos, width),\n                    convertUnitSize(yPos, height),\n                ],\n            };\n        });\n        const minMaxs = getMinMaxs(poses.map(pos => pos.pos));\n\n        return {\n            type: clipPrefix,\n            clipText,\n            poses,\n            splitter,\n            left: minMaxs.minX,\n            right: minMaxs.maxX,\n            top: minMaxs.minY,\n            bottom: minMaxs.maxY,\n        } as const;\n    } else if (isCircle || clipPrefix === \"ellipse\") {\n        let xPos = \"\";\n        let yPos = \"\";\n        let radiusX = 0;\n        let radiusY = 0;\n        const values = splitSpace(value!);\n\n        if (isCircle) {\n            let radius = \"\";\n            [radius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = convertUnitSize(radius, Math.sqrt((width * width + height * height) / 2));\n            radiusY = radiusX;\n        } else {\n            let xRadius = \"\";\n            let yRadius = \"\";\n            [xRadius = \"50%\", yRadius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = convertUnitSize(xRadius, width);\n            radiusY = convertUnitSize(yRadius, height);\n        }\n        const centerPos = [\n            convertUnitSize(xPos, width),\n            convertUnitSize(yPos, height),\n        ];\n        const poses: ControlPose[] = [\n            {\n                vertical: 1,\n                horizontal: 1,\n                pos: centerPos,\n                direction: \"nesw\",\n            },\n            ...CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(dir => ({\n                vertical: Math.abs(dir[1]),\n                horizontal: dir[0],\n                direction: dir[2],\n                sub: true,\n                pos: [\n                    centerPos[0] + dir[0] * radiusX,\n                    centerPos[1] + dir[1] * radiusY,\n                ],\n            })),\n        ];\n        return {\n            type: clipPrefix as \"circle\" | \"ellipse\",\n            clipText,\n            radiusX,\n            radiusY,\n            left: centerPos[0] - radiusX,\n            top: centerPos[1] - radiusY,\n            right: centerPos[0] + radiusX,\n            bottom: centerPos[1] + radiusY,\n            poses,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"inset\") {\n        const values = splitSpace(value! || \"0 0 0 0\");\n        const roundIndex = values.indexOf(\"round\");\n\n        const rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n        const radiusValues = values.slice(rectLength + 1);\n        const [\n            topValue,\n            rightValue = topValue,\n            bottomValue = topValue,\n            leftValue = rightValue,\n        ] = values.slice(0, rectLength);\n        const [top, bottom] = [topValue, bottomValue].map(pos => convertUnitSize(pos, height));\n        const [left, right] = [leftValue, rightValue].map(pos => convertUnitSize(pos, width));\n        const nextRight = width - right;\n        const nextBottom = height - bottom;\n        const radiusPoses = getRadiusValues(\n            radiusValues,\n            nextRight - left,\n            nextBottom - top,\n            left,\n            top,\n        );\n        const poses: ControlPose[] = [\n            ...getRectPoses(top, nextRight, nextBottom, left),\n            ...radiusPoses,\n        ];\n\n        return {\n            type: \"inset\",\n            clipText,\n            poses,\n            top,\n            left,\n            right: nextRight,\n            bottom: nextBottom,\n            radius: radiusValues,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"rect\") {\n        // top right bottom left\n        const values = splitComma(value! || `0px, ${width}px, ${height}px, 0px`);\n\n        splitter = \",\";\n        const [top, right, bottom, left] = values.map(pos => {\n            const { value: posValue } = splitUnit(pos);\n\n            return posValue;\n        });\n        const poses = getRectPoses(top, right, bottom, left);\n\n        return {\n            type: \"rect\",\n            clipText,\n            poses,\n            top,\n            right,\n            bottom,\n            left,\n            values,\n            splitter,\n        } as const;\n    }\n    return;\n}\n","import {\n    Renderer, ClippableProps, OnClip,\n    ClippableState, OnClipEnd, OnClipStart,\n    ControlPose, MoveableManagerInterface, DraggableProps,\n} from \"../types\";\nimport { convertUnitSize, getRad } from \"@daybrush/utils\";\nimport {\n    prefix, calculatePosition, getDiagonalSize,\n    fillParams, triggerEvent,\n    makeMatrixCSS, getRect, fillEndParams,\n    getSizeDistByDist,\n    getProps,\n    fillCSSObject,\n} from \"../utils\";\nimport { plus, minus, multiply } from \"@scena/matrix\";\nimport { getDragDist, calculatePointerDist, setDragStart } from \"../gesto/GestoUtils\";\nimport {\n    HORIZONTAL_RADIUS_ORDER, VERTICAL_RADIUS_ORDER, addRadiusPos, removeRadiusPos,\n} from \"./roundable/borderRadius\";\nimport { renderLine } from \"../renderDirections\";\nimport { checkSnapBoundPriority } from \"./snappable/snap\";\nimport { checkSnapBounds } from \"./snappable/snapBounds\";\nimport { getDefaultGuidelines } from \"./snappable/getTotalGuidelines\";\nimport {\n    getControlSize, getClipPath,\n    getClipStyles, getRectPoses,\n} from \"./clippable/utils\";\n\nexport function moveControlPos(\n    controlPoses: ControlPose[],\n    index: number,\n    dist: number[],\n    isRect?: boolean,\n    keepRatio?: boolean,\n) {\n    const { direction, sub } = controlPoses[index];\n    const dists = controlPoses.map(() => [0, 0]);\n    const directions = direction ? direction.split(\"\") : [];\n\n    if (isRect && index < 8) {\n        const verticalDirections = directions.filter(dir => dir === \"w\" || dir === \"e\");\n        const horizontalDirections = directions.filter(dir => dir === \"n\" || dir === \"s\");\n\n        const verticalDirection = verticalDirections[0];\n        const horizontalDirection = horizontalDirections[0];\n\n        dists[index] = dist;\n        const [width, height] = getControlSize(controlPoses);\n        const ratio = width && height ? width / height : 0;\n\n        if (ratio && keepRatio) {\n            // 0 1 2\n            // 7   3\n            // 6 5 4\n\n            const fixedIndex = (index + 4) % 8;\n            const fixedPosition = controlPoses[fixedIndex].pos;\n            const sizeDirection = [0, 0];\n\n            if (direction!.indexOf(\"w\") > -1) {\n                sizeDirection[0] = -1;\n            } else if (direction!.indexOf(\"e\") > -1) {\n                sizeDirection[0] = 1;\n            }\n            if (direction!.indexOf(\"n\") > -1) {\n                sizeDirection[1] = -1;\n            } else if (direction!.indexOf(\"s\") > -1) {\n                sizeDirection[1] = 1;\n            }\n\n\n            const nextDist = getSizeDistByDist(\n                [width, height],\n                dist,\n                ratio,\n                sizeDirection,\n                true,\n            );\n            const nextWidth = width + nextDist[0];\n            const nextHeight = height + nextDist[1];\n            let top = fixedPosition[1];\n            let bottom = fixedPosition[1];\n            let left = fixedPosition[0];\n            let right = fixedPosition[0];\n\n            if (sizeDirection[0] === -1) {\n                left = right - nextWidth;\n            } else if (sizeDirection[0] === 1) {\n                right = left + nextWidth;\n            } else {\n                left = left - nextWidth / 2;\n                right = right + nextWidth / 2;\n            }\n            if (sizeDirection[1] === -1) {\n                top = bottom - nextHeight;\n            } else if (sizeDirection[1] === 1) {\n                bottom = top + nextHeight;\n            } else {\n                top = bottom - nextHeight / 2;\n                bottom = top + nextHeight;\n            }\n\n            const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n            controlPoses.forEach((controlPose, i) => {\n                dists[i][0] = nextControlPoses[i].pos[0] - controlPose.pos[0];\n                dists[i][1] = nextControlPoses[i].pos[1] - controlPose.pos[1];\n            });\n        } else {\n            controlPoses.forEach((controlPose, i) => {\n                const {\n                    direction: controlDir,\n                } = controlPose;\n\n                if (!controlDir) {\n                    return;\n                }\n                if (controlDir.indexOf(verticalDirection) > -1) {\n                    dists[i][0] = dist[0];\n                }\n                if (controlDir.indexOf(horizontalDirection) > -1) {\n                    dists[i][1] = dist[1];\n                }\n            });\n            if (verticalDirection) {\n                dists[1][0] = dist[0] / 2;\n                dists[5][0] = dist[0] / 2;\n            }\n            if (horizontalDirection) {\n                dists[3][1] = dist[1] / 2;\n                dists[7][1] = dist[1] / 2;\n            }\n        }\n    } else if (direction && !sub) {\n        directions.forEach(dir => {\n            const isVertical = dir === \"n\" || dir === \"s\";\n\n            controlPoses.forEach((controlPose, i) => {\n                const {\n                    direction: dirDir,\n                    horizontal: dirHorizontal,\n                    vertical: dirVertical,\n                } = controlPose;\n\n                if (!dirDir || dirDir.indexOf(dir) === -1) {\n                    return;\n                }\n                dists[i] = [\n                    isVertical || !dirHorizontal ? 0 : dist[0],\n                    !isVertical || !dirVertical ? 0 : dist[1],\n                ];\n            });\n        });\n    } else {\n        dists[index] = dist;\n    }\n\n    return dists;\n}\n\n\nfunction addClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const [distX, distY] = calculatePointerDist(moveable, e);\n    const { clipPath, clipIndex } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    if (clipType === \"polygon\") {\n        poses.splice(clipIndex, 0, [distX, distY]);\n    } else if (clipType === \"inset\") {\n        const horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(clipIndex);\n        const verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(clipIndex);\n        const length = clipPoses.length;\n\n        addRadiusPos(\n            clipPoses,\n            poses,\n            8,\n            horizontalIndex,\n            verticalIndex,\n            distX,\n            distY,\n            poses[4][0],\n            poses[4][1],\n            poses[0][0],\n            poses[0][1],\n        );\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    const clipStyle = `${clipType}(${clipStyles.join(splitter)})`;\n\n    triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"added\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle,\n        distX: 0,\n        distY: 0,\n        ...fillCSSObject({\n            clipPath: clipStyle,\n        }, e),\n    }));\n}\nfunction removeClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const { clipPath, clipIndex } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    const length = poses.length;\n    if (clipType === \"polygon\") {\n        clipPoses.splice(clipIndex, 1);\n        poses.splice(clipIndex, 1);\n    } else if (clipType === \"inset\") {\n        if (clipIndex < 8) {\n            return;\n        }\n        removeRadiusPos(clipPoses, poses, clipIndex, 8, length);\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    const clipStyle = `${clipType}(${clipStyles.join(splitter)})`;\n\n    triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"removed\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle,\n        distX: 0,\n        distY: 0,\n        ...fillCSSObject({\n            clipPath: clipStyle,\n        }, e),\n    }));\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\nexport default {\n    name: \"clippable\",\n    props: {\n        clippable: Boolean,\n        defaultClipPath: String,\n        customClipPath: String,\n        keepRatio: Boolean,\n        clipRelative: Boolean,\n        clipArea: Boolean,\n        dragWithClip: Boolean,\n        clipTargetBounds: Boolean,\n        clipVerticalGuidelines: Array,\n        clipHorizontalGuidelines: Array,\n        clipSnapThreshold: Boolean,\n    } as const,\n    events: {\n        onClipStart: \"clipStart\",\n        onClip: \"clip\",\n        onClipEnd: \"clipEnd\",\n    } as const,\n    css: [\n        `.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`,\n        `:host {\n    --bounds-color: #d66;\n}`,\n        `.guideline {\n    pointer-events: none;\n    z-index: 2;\n}`,\n        `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, React: Renderer): any[] {\n        const {\n            customClipPath,\n            defaultClipPath,\n            clipArea, zoom,\n            groupable,\n        } = moveable.props;\n        const {\n            target, width, height, allMatrix, is3d, left, top,\n            pos1, pos2, pos3, pos4,\n            clipPathState,\n            snapBoundInfos,\n            rotation: rotationRad,\n        } = moveable.getState();\n\n        if (!target || groupable) {\n            return [];\n        }\n\n        const clipPath = getClipPath(\n            target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n\n        if (!clipPath) {\n            return [];\n        }\n        const n = is3d ? 4 : 3;\n        const type = clipPath.type;\n        const clipPoses = clipPath.poses;\n        const poses = clipPoses.map(pos => {\n            // return [x, y];\n            const calculatedPos = calculatePosition(allMatrix, pos.pos, n);\n\n            return [\n                calculatedPos[0] - left,\n                calculatedPos[1] - top,\n            ];\n        });\n\n        let controls: any[] = [];\n        let lines: any[] = [];\n\n        const isRect = type === \"rect\";\n        const isInset = type === \"inset\";\n        const isPolygon = type === \"polygon\";\n\n        if (isRect || isInset || isPolygon) {\n            const linePoses = isInset ? poses.slice(0, 8) : poses;\n\n            lines = linePoses.map((to, i) => {\n                const from = i === 0 ? linePoses[linePoses.length - 1] : linePoses[i - 1];\n\n                const rad = getRad(from, to);\n                const dist = getDiagonalSize(from, to);\n                return <div key={`clipLine${i}`} className={prefix(\"line\", \"clip-line\", \"snap-control\")}\n                    data-clip-index={i}\n                    style={{\n                        width: `${dist}px`,\n                        transform: `translate(${from[0]}px, ${from[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n                    }}></div>;\n            });\n        }\n        controls = poses.map((pos, i) => {\n            return <div key={`clipControl${i}`}\n                className={prefix(\"control\", \"clip-control\", \"snap-control\")}\n                data-clip-index={i}\n                style={{\n                    transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n                }}></div>;\n        });\n\n        if (isInset) {\n            controls.push(...poses.slice(8).map((pos, i) => {\n                return <div key={`clipRadiusControl${i}`}\n                    className={prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\")}\n                    data-clip-index={8 + i}\n                    style={{\n                        transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n                    }}></div>;\n            }));\n        }\n        if (type === \"circle\" || type === \"ellipse\") {\n            const {\n                left: clipLeft,\n                top: clipTop,\n                radiusX,\n                radiusY,\n            } = clipPath;\n\n            const [distLeft, distTop] = minus(\n                calculatePosition(allMatrix, [clipLeft!, clipTop!], n),\n                calculatePosition(allMatrix, [0, 0], n),\n            );\n            let ellipseClipPath = \"none\";\n\n            if (!clipArea) {\n                const piece = Math.max(10, radiusX! / 5, radiusY! / 5);\n                const areaPoses: number[][] = [];\n\n                for (let i = 0; i <= piece; ++i) {\n                    const rad = Math.PI * 2 / piece * i;\n                    areaPoses.push([\n                        radiusX! + (radiusX! - zoom!) * Math.cos(rad),\n                        radiusY! + (radiusY! - zoom!) * Math.sin(rad),\n                    ]);\n                }\n                areaPoses.push([radiusX!, -2]);\n                areaPoses.push([-2, -2]);\n                areaPoses.push([-2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, -2]);\n                areaPoses.push([radiusX!, -2]);\n\n                ellipseClipPath = `polygon(${areaPoses.map(pos => `${pos[0]}px ${pos[1]}px`).join(\", \")})`;\n            }\n            controls.push(<div key=\"clipEllipse\" className={prefix(\"clip-ellipse\", \"snap-control\")} style={{\n                width: `${radiusX! * 2}px`,\n                height: `${radiusY! * 2}px`,\n                clipPath: ellipseClipPath,\n                transform: `translate(${-left + distLeft}px, ${-top + distTop}px) ${makeMatrixCSS(allMatrix)}`,\n            }}></div>);\n        }\n        if (clipArea) {\n            const {\n                width: allWidth,\n                height: allHeight,\n                left: allLeft,\n                top: allTop,\n            } = getRect([pos1, pos2, pos3, pos4, ...poses]);\n            if (isPolygon || isRect || isInset) {\n                const areaPoses = isInset ? poses.slice(0, 8) : poses;\n                controls.push(<div key=\"clipArea\" className={prefix(\"clip-area\", \"snap-control\")} style={{\n                    width: `${allWidth}px`,\n                    height: `${allHeight}px`,\n                    transform: `translate(${allLeft}px, ${allTop}px)`,\n                    clipPath: `polygon(${areaPoses.map(pos => `${pos[0] - allLeft}px ${pos[1] - allTop}px`).join(\", \")})`,\n                }}></div>);\n            }\n        }\n        if (snapBoundInfos) {\n            ([\"vertical\", \"horizontal\"] as const).forEach(directionType => {\n                const info = snapBoundInfos[directionType];\n                const isHorizontal = directionType === \"horizontal\";\n\n                if (info.isSnap) {\n                    lines.push(...info.snap.posInfos.map(({ pos }, i) => {\n                        const snapPos1 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n                        const snapPos2 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n\n                        return renderLine(\n                            React, \"\", snapPos1, snapPos2, zoom!,\n                            `clip${directionType}snap${i}`, \"guideline\");\n                    }));\n                }\n                if (info.isBound) {\n                    lines.push(...info.bounds.map(({ pos }, i) => {\n                        const snapPos1 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n                        const snapPos2 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n\n                        return renderLine(\n                            React, \"\", snapPos1, snapPos2, zoom!,\n                            `clip${directionType}bounds${i}`, \"guideline\", \"bounds\", \"bold\");\n                    }));\n                }\n            });\n        }\n        return [\n            ...controls,\n            ...lines,\n        ];\n    },\n    dragControlCondition(moveable: any, e: any) {\n        return e.inputEvent && (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n    },\n    dragStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const props = moveable.props;\n        const {\n            dragWithClip = true,\n        } = props;\n\n        if (dragWithClip) {\n            return false;\n        }\n\n        return this.dragControlStart(moveable, e);\n    },\n    drag(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        return this.dragControl(moveable, { ...e, isDragTarget: true });\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        return this.dragControlEnd(moveable, e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const state = moveable.state;\n        const { defaultClipPath, customClipPath } = moveable.props;\n        const { target, width, height } = state;\n        const inputTarget = e.inputEvent ? e.inputEvent.target : null;\n        const className = (inputTarget && inputTarget.getAttribute(\"class\")) || \"\";\n        const datas = e.datas;\n        const clipPath = getClipPath(target!, width, height, defaultClipPath || \"inset\", customClipPath);\n\n        if (!clipPath) {\n            return false;\n        }\n        const { clipText, type, poses } = clipPath;\n        const result = triggerEvent(moveable, \"onClipStart\", fillParams<OnClipStart>(moveable, e, {\n            clipType: type,\n            clipStyle: clipText,\n            poses: poses.map(pos => pos.pos),\n        }));\n\n        if (result === false) {\n            datas.isClipStart = false;\n            return false;\n        }\n        datas.isControl = className && className.indexOf(\"clip-control\") > -1;\n        datas.isLine = className.indexOf(\"clip-line\") > -1;\n        datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n        datas.clipIndex = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n        datas.clipPath = clipPath;\n        datas.isClipStart = true;\n        state.clipPathState = clipText;\n        setDragStart(moveable, e);\n\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<ClippableProps & DraggableProps, ClippableState>, e: any) {\n        const { datas, originalDatas, isDragTarget } = e;\n\n        if (!datas.isClipStart) {\n            return false;\n        }\n        const { isControl, isLine, isArea, clipIndex, clipPath } = datas as {\n            clipPath: ReturnType<typeof getClipPath>,\n            [key: string]: any,\n        };\n        if (!clipPath) {\n            return false;\n        }\n        const props = getProps(moveable.props, \"clippable\");\n\n        const { keepRatio } = props;\n        let distX = 0;\n        let distY = 0;\n\n        const originalDraggable = originalDatas.draggable;\n        const originalDist = getDragDist(e);\n\n        if (isDragTarget && originalDraggable) {\n            [distX, distY] = originalDraggable.prevBeforeDist;\n        } else {\n            [distX, distY] = originalDist;\n        }\n\n        const firstDist = [distX, distY];\n\n        const state = moveable.state;\n        const { width, height } = state;\n        const isDragWithTarget = !isArea && !isControl && !isLine;\n        const {\n            type: clipType,\n            poses: clipPoses,\n            splitter,\n        } = clipPath;\n        const poses = clipPoses.map(pos => pos.pos);\n\n        if (isDragWithTarget) {\n            distX = -distX;\n            distY = -distY;\n        }\n        const isAll = !isControl || clipPoses[clipIndex].direction === \"nesw\";\n        const isRect = clipType === \"inset\" || clipType === \"rect\";\n        let dists = clipPoses.map(() => [0, 0]);\n\n        if (isControl && !isAll) {\n            const { horizontal, vertical } = clipPoses[clipIndex];\n            const dist = [\n                distX * Math.abs(horizontal),\n                distY * Math.abs(vertical),\n            ];\n            dists = moveControlPos(clipPoses, clipIndex, dist, isRect, keepRatio);\n        } else if (isAll) {\n            dists = poses.map(() => [distX, distY]);\n        }\n        const nextPoses: number[][] = poses.map((pos, i) => plus(pos, dists[i]));\n        const guidePoses = [...nextPoses];\n\n        state.snapBoundInfos = null;\n        const isCircle = clipPath.type === \"circle\";\n        const isEllipse = clipPath.type === \"ellipse\";\n\n        if (isCircle || isEllipse) {\n            const guideRect = getRect(nextPoses);\n            const ry = Math.abs(guideRect.bottom - guideRect.top);\n            const rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);\n            const bottom = nextPoses[0][1] + ry;\n            const left = nextPoses[0][0] - rx;\n            const right = nextPoses[0][0] + rx;\n\n            // right\n            if (isCircle) {\n                guidePoses.push([right, guideRect.bottom]);\n                dists.push([1, 0]);\n            }\n            // bottom\n            guidePoses.push([guideRect.left, bottom]);\n            dists.push([0, 1]);\n            // left\n            guidePoses.push([left, guideRect.bottom]);\n            dists.push([1, 0]);\n        }\n\n        const guidelines = getDefaultGuidelines(\n            (props.clipHorizontalGuidelines || []).map(v => convertUnitSize(`${v}`, height)),\n            (props.clipVerticalGuidelines || []).map(v => convertUnitSize(`${v}`, width)),\n            width!, height!,\n        );\n        let guideXPoses: number[] = [];\n        let guideYPoses: number[] = [];\n\n        if (isCircle || isEllipse) {\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n        } else if (isRect) {\n            const rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n            const rectDists = [dists[0], dists[2], dists[4], dists[6]];\n\n            guideXPoses = rectPoses.filter((_, i) => rectDists[i][0]).map(pos => pos[0]);\n            guideYPoses = rectPoses.filter((_, i) => rectDists[i][1]).map(pos => pos[1]);\n        } else {\n            guideXPoses = guidePoses.filter((_, i) => dists[i][0]).map(pos => pos[0]);\n            guideYPoses = guidePoses.filter((_, i) => dists[i][1]).map(pos => pos[1]);\n        }\n        const boundDelta = [0, 0];\n        const {\n            horizontal: horizontalSnapInfo,\n            vertical: verticalSnapInfo,\n        } = checkSnapBounds(\n            guidelines,\n            props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height },\n            guideXPoses,\n            guideYPoses,\n            5,\n        );\n        let snapOffsetY = horizontalSnapInfo.offset;\n        let snapOffsetX = verticalSnapInfo.offset;\n\n        if (horizontalSnapInfo.isBound) {\n            boundDelta[1] += snapOffsetY;\n        }\n        if (verticalSnapInfo.isBound) {\n            boundDelta[0] += snapOffsetX;\n        }\n        if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\n            const guideRect = getRect(nextPoses);\n            let cy = guideRect.bottom - guideRect.top;\n            let cx = isEllipse ? guideRect.right - guideRect.left : cy;\n\n\n            const distSnapX = verticalSnapInfo.isBound\n                ? Math.abs(snapOffsetX)\n                : (verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX);\n            const distSnapY = horizontalSnapInfo.isBound\n                ? Math.abs(snapOffsetY)\n                : (horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY);\n            cx -= distSnapX;\n            cy -= distSnapY;\n\n            if (isCircle) {\n                cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;\n                cx = cy;\n            }\n            const center = guidePoses[0];\n\n            guidePoses[1][1] = center[1] - cy;\n            guidePoses[2][0] = center[0] + cx;\n            guidePoses[3][1] = center[1] + cy;\n            guidePoses[4][0] = center[0] - cx;\n        } else if (isRect && keepRatio && isControl) {\n            const [width, height] = getControlSize(clipPoses);\n            const ratio = width && height ? width / height : 0;\n            const clipPose = clipPoses[clipIndex];\n            const direction = clipPose.direction! || \"\";\n            let top = guidePoses[1][1];\n            let bottom = guidePoses[5][1];\n            let left = guidePoses[7][0];\n            let right = guidePoses[3][0];\n\n\n            if (snapOffsetY <= snapOffsetX) {\n                snapOffsetY = snapOffsetX / ratio;\n            } else {\n                snapOffsetX = snapOffsetY * ratio;\n            }\n            if (direction!.indexOf(\"w\") > -1) {\n                left -= snapOffsetX;\n            } else if (direction!.indexOf(\"e\") > -1) {\n                right -= snapOffsetX;\n            } else {\n                left += snapOffsetX / 2;\n                right -= snapOffsetX / 2;\n            }\n            if (direction!.indexOf(\"n\") > -1) {\n                top -= snapOffsetY;\n            } else if (direction!.indexOf(\"s\") > -1) {\n                bottom -= snapOffsetY;\n            } else {\n                top += snapOffsetY / 2;\n                bottom -= snapOffsetY / 2;\n            }\n\n            const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n            guidePoses.forEach((pos, i) => {\n                [pos[0], pos[1]] = nextControlPoses[i].pos;\n            });\n        } else {\n            guidePoses.forEach((pos, j) => {\n                const dist = dists[j];\n\n                if (dist[0]) {\n                    pos[0] -= snapOffsetX;\n                }\n                if (dist[1]) {\n                    pos[1] -= snapOffsetY;\n                }\n            });\n        }\n        const nextClipStyles = getClipStyles(moveable, clipPath, nextPoses)!;\n        const clipStyle = `${clipType}(${nextClipStyles.join(splitter)})`;\n\n        state.clipPathState = clipStyle;\n\n        if (isCircle || isEllipse) {\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n        } else if (isRect) {\n            const rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n\n            guideXPoses = rectPoses.map(pos => pos[0]);\n            guideYPoses = rectPoses.map(pos => pos[1]);\n        } else {\n            guideXPoses = guidePoses.map(pos => pos[0]);\n            guideYPoses = guidePoses.map(pos => pos[1]);\n        }\n        state.snapBoundInfos = checkSnapBounds(\n            guidelines,\n            props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height },\n            guideXPoses,\n            guideYPoses,\n            1,\n        );\n\n        if (originalDraggable) {\n            const {\n                is3d,\n                allMatrix,\n            } = state;\n            const n = is3d ? 4 : 3;\n\n            let dragDist = boundDelta;\n\n            if (isDragTarget) {\n                dragDist = [\n                    firstDist[0] + boundDelta[0] - originalDist[0],\n                    firstDist[1] + boundDelta[1] - originalDist[1],\n                ];\n            }\n            originalDraggable.deltaOffset = multiply(allMatrix, [dragDist[0], dragDist[1], 0, 0], n);\n        }\n        triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n            clipEventType: \"changed\",\n            clipType,\n            poses: nextPoses,\n            clipStyle,\n            clipStyles: nextClipStyles,\n            distX,\n            distY,\n            ...fillCSSObject({\n                [clipType === \"rect\" ? \"clip\" : \"clipPath\"]: clipStyle,\n            }, e),\n        }));\n\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        this.unset(moveable);\n        const { isDrag, datas, isDouble } = e;\n        const { isLine, isClipStart, isControl } = datas;\n\n        if (!isClipStart) {\n            return false;\n        }\n        triggerEvent(moveable, \"onClipEnd\", fillEndParams<OnClipEnd>(moveable, e, {}));\n        if (isDouble) {\n            if (isControl) {\n                removeClipPath(moveable, e);\n            } else if (isLine) {\n                // add\n                addClipPath(moveable, e);\n            }\n        }\n        return isDouble || isDrag;\n    },\n    unset(moveable: MoveableManagerInterface<ClippableProps, ClippableState>) {\n        moveable.state.clipPathState = \"\";\n        moveable.state.snapBoundInfos = null;\n    },\n};\n\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea.\n * @name Moveable.Clippable#clipArea\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n* Whether the clip is bound to the target.\n* @name Moveable.Clippable#clipTargetBounds\n* @default false\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipTargetBounds: true,\n* });\n* moveable.on(\"clipStart\", e => {\n*     console.log(e);\n* }).on(\"clip\", e => {\n*     if (e.clipType === \"rect\") {\n*         e.target.style.clip = e.clipStyle;\n*     } else {\n*         e.target.style.clipPath = e.clipStyle;\n*     }\n* }).on(\"clipEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n * Add clip guidelines in the vertical direction.\n * @name Moveable.Clippable#clipVerticalGuidelines\n * @default 0\n * @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n\n/**\n* Add clip guidelines in the horizontal direction.\n* @name Moveable.Clippable#clipHorizontalGuidelines\n* @default []\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n/**\n* istance value that can snap to clip guidelines.\n* @name Moveable.Clippable#clipSnapThreshold\n* @default 5\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    prefix, triggerEvent,\n    fillParams, calculatePoses, getRect, fillEndParams, convertCSSSize, fillCSSObject,\n} from \"../utils\";\nimport {\n    OnDragOriginStart, OnDragOrigin,\n    OnDragOriginEnd, MoveableManagerInterface, DraggableProps, OriginDraggableProps, MoveableGroupInterface,\n} from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, getNextMatrix } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport Draggable from \"./Draggable\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\nexport default {\n    name: \"originDraggable\",\n    props: {\n        originDraggable: Boolean,\n        originRelative: Boolean,\n    } as const,\n    events: {\n        onDragOriginStart: \"dragOriginStart\",\n        onDragOrigin: \"dragOrigin\",\n        onDragOriginEnd: \"dragOriginEnd\",\n    } as const,\n    css: [\n        `:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`,\n    ],\n    dragControlCondition(_: any, e: any) {\n        if (e.isRequest) {\n            return e.requestAble === \"originDraggable\";\n        }\n        return hasClass(e.inputEvent.target, prefix(\"origin\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas } = e;\n\n        setDragStart(moveable, e);\n\n        const params = fillParams<OnDragOriginStart>(moveable, e, {\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ),\n        });\n        const result = triggerEvent(moveable, \"onDragOriginStart\", params);\n\n        datas.startOrigin = moveable.state.transformOrigin;\n        datas.startTargetOrigin = moveable.state.targetOrigin;\n        datas.prevOrigin = [0, 0];\n        datas.isDragOrigin = true;\n\n        if (result === false) {\n            datas.isDragOrigin = false;\n            return false;\n        }\n\n        return params;\n    },\n    dragControl(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas, isPinch, isRequest } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        const [distX, distY] = getDragDist(e);\n        const state = moveable.state;\n        const {\n            width,\n            height,\n            offsetMatrix,\n            targetMatrix,\n            is3d,\n        } = state;\n        const {\n            originRelative = true,\n        } = moveable.props;\n        const n = is3d ? 4 : 3;\n        let dist = [distX, distY];\n\n        if (isRequest) {\n            const distOrigin = e.distOrigin;\n            if (distOrigin[0] || distOrigin[1]) {\n                dist = distOrigin;\n            }\n        }\n        const origin = plus(datas.startOrigin, dist);\n        const targetOrigin = plus(datas.startTargetOrigin, dist);\n        const delta = minus(dist, datas.prevOrigin);\n\n        const nextMatrix = getNextMatrix(\n            offsetMatrix,\n            targetMatrix,\n            origin,\n            n,\n        );\n\n        const rect = moveable.getRect();\n        const nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\n\n        const dragDelta = [\n            rect.left - nextRect.left,\n            rect.top - nextRect.top,\n        ];\n\n        datas.prevOrigin = dist;\n        const transformOrigin = [\n            convertCSSSize(targetOrigin[0], width, originRelative),\n            convertCSSSize(targetOrigin[1], height, originRelative),\n        ].join(\" \");\n        const result = Draggable.drag(\n            moveable,\n            setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false),\n        )!;\n        const params = fillParams<OnDragOrigin>(moveable, e, {\n            width,\n            height,\n            origin,\n            dist,\n            delta,\n            transformOrigin,\n            drag: result,\n            ...fillCSSObject({\n                transformOrigin,\n                transform: result.transform,\n            }, e),\n            afterTransform: result.transform,\n        });\n        triggerEvent(moveable, \"onDragOrigin\", params);\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<OriginDraggableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        triggerEvent(moveable, \"onDragOriginEnd\",\n            fillEndParams<OnDragOriginEnd>(moveable, e, {}));\n        return true;\n    },\n    dragGroupControlCondition(moveable: any, e: any) {\n        return this.dragControlCondition(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        return true;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        moveable.transformOrigin = params.transformOrigin;\n\n        return true;\n    },\n    /**\n    * @method Moveable.OriginDraggable#request\n    * @param {object} e - the OriginDraggable's request parameter\n    * @param {number} [e.x] - x position\n    * @param {number} [e.y] - y position\n    * @param {number} [e.deltaX] - x number to move\n    * @param {number} [e.deltaY] - y number to move\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n    * @param {array} [e.origin] - transform-origin position\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\n    * @return {Moveable.Requester} Moveable Requester\n    * @example\n\n    * // Instantly Request (requestStart - request - requestEnd)\n    * // Use Relative Value\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n    * // Use Transform Value\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n    * // requestStart\n    * const requester = moveable.request(\"originDraggable\");\n    *\n    * // request\n    * // Use Relative Value\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n    *\n    * // requestEnd\n    * requester.requestEnd();\n    */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        const transformOrigin = rect.transformOrigin;\n        const distOrigin = [0, 0];\n\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaOrigin\" in e) {\n                    distOrigin[0] += e.deltaOrigin[0];\n                    distOrigin[1] += e.deltaOrigin[1];\n                } else if (\"origin\" in e) {\n                    distOrigin[0] = e.origin[0] - transformOrigin[0];\n                    distOrigin[1] = e.origin[1] - transformOrigin[1];\n                } else {\n                    if (\"x\" in e) {\n                        distX = e.x - rect.left;\n                    } else if (\"deltaX\" in e) {\n                        distX += e.deltaX;\n                    }\n                    if (\"y\" in e) {\n                        distY = e.y - rect.top;\n                    } else if (\"deltaY\" in e) {\n                        distY += e.deltaY;\n                    }\n                }\n\n                return { datas, distX, distY, distOrigin };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n* When drag start the origin, the `dragOriginStart` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginStart\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag the origin, the `dragOrigin` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOrigin\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag end the origin, the `dragOriginEnd` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginEnd\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n","import {\n    prefix, triggerEvent,\n    fillParams, fillEndParams, calculatePosition,\n    fillCSSObject,\n    catchEvent,\n} from \"../utils\";\nimport {\n    Renderer, RoundableProps, OnRoundStart,\n    RoundableState, OnRound, ControlPose, OnRoundEnd,\n    MoveableManagerInterface,\n    OnRoundGroup,\n    MoveableGroupInterface,\n    OnRoundGroupStart,\n    OnRoundGroupEnd,\n} from \"../types\";\nimport { splitSpace } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, calculatePointerDist } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    getRadiusValues,\n    getRadiusStyles,\n    splitRadiusPoses,\n} from \"./roundable/borderRadius\";\nimport { fillChildEvents } from \"../groupUtils\";\n\n\nfunction addBorderRadiusByLine(\n    controlPoses: ControlPose[],\n    lineIndex: number,\n    distX: number,\n    distY: number,\n) {\n    // lineIndex\n    // 0 top\n    // 1 right\n    // 2 bottom\n    // 3 left\n\n    const horizontalsLength = controlPoses.filter(({ virtual, horizontal }) => horizontal && !virtual).length;\n    const verticalsLength = controlPoses.filter(({ virtual, vertical }) => vertical && !virtual).length;\n    let controlIndex = -1;\n\n    //top\n    if (lineIndex === 0) {\n        if (horizontalsLength === 0) {\n            controlIndex = 0;\n        } else if (horizontalsLength === 1) {\n            controlIndex = 1;\n        }\n    }\n    // bottom\n    if (lineIndex === 2) {\n        if (horizontalsLength <= 2) {\n            controlIndex = 2;\n        } else if (horizontalsLength <= 3) {\n            controlIndex = 3;\n        }\n    }\n    // left\n    if (lineIndex === 3) {\n        if (verticalsLength === 0) {\n            controlIndex = 4;\n        } else if (verticalsLength < 4) {\n            controlIndex = 7;\n        }\n    }\n\n    // right\n    if (lineIndex === 1) {\n        if (verticalsLength <= 1) {\n            controlIndex = 5;\n        } else if (verticalsLength <= 2) {\n            controlIndex = 6;\n        }\n    }\n    if (controlIndex === -1 || !controlPoses[controlIndex].virtual) {\n        return;\n    }\n    const controlPoseInfo = controlPoses[controlIndex];\n\n    addBorderRadius(controlPoses, controlIndex);\n\n    if (controlIndex < 4) {\n        controlPoseInfo.pos[0] = distX;\n    } else {\n        controlPoseInfo.pos[1] = distY;\n    }\n}\nfunction addBorderRadius(\n    controlPoses: ControlPose[],\n    index: number,\n) {\n    if (index < 4) {\n        controlPoses.slice(0, index + 1).forEach(info => {\n            info.virtual = false;\n        });\n    } else {\n        if (controlPoses[0].virtual) {\n            controlPoses[0].virtual = false;\n        }\n        controlPoses.slice(4, index + 1).forEach(info => {\n            info.virtual = false;\n        });\n    }\n}\nfunction removeBorderRadius(\n    controlPoses: ControlPose[],\n    index: number,\n) {\n    if (index < 4) {\n        controlPoses.slice(index, 4).forEach(info => {\n            info.virtual = true;\n        });\n    } else {\n        controlPoses.slice(index).forEach(info => {\n            info.virtual = true;\n        });\n    }\n}\nfunction getBorderRadius(\n    borderRadius: string,\n    width: number,\n    height: number,\n    minCounts: number[] = [0, 0],\n    full?: boolean,\n) {\n    let values: string[] = [];\n\n    if (!borderRadius || borderRadius === \"0px\") {\n        values = [];\n    } else {\n        values = splitSpace(borderRadius);\n    }\n\n    return getRadiusValues(values, width, height, 0, 0, minCounts, full);\n}\n\nfunction triggerRoundEvent(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any,\n    dist: number[],\n    delta: number[],\n    nextPoses: ControlPose[],\n) {\n    const state = moveable.state;\n    const {\n        width,\n        height,\n    } = state;\n    const {\n        raws,\n        styles,\n        radiusPoses,\n    } = getRadiusStyles(\n        nextPoses,\n        moveable.props.roundRelative!,\n        width,\n        height,\n    );\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(radiusPoses, raws);\n    const borderRadius = styles.join(\" \");\n\n    state.borderRadiusState = borderRadius;\n    const params = fillParams<OnRound>(moveable, e, {\n        horizontals,\n        verticals,\n        borderRadius,\n        width,\n        height,\n        delta,\n        dist,\n        ...fillCSSObject({\n            borderRadius,\n        }, e),\n    });\n    triggerEvent(moveable, \"onRound\", params);\n\n    return params;\n}\n\n\nfunction getStyleBorderRadius(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n    const {\n        style,\n    } = moveable.getState();\n    let borderRadius = style.borderRadius || \"\";\n\n    if (!borderRadius && moveable.props.groupable) {\n        const firstTarget = moveable.getTargets()[0];\n\n\n        if (firstTarget) {\n            borderRadius = getComputedStyle(firstTarget).borderRadius;\n            style.borderRadius = borderRadius;\n        }\n    }\n    return borderRadius;\n}\n\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\nexport default {\n    name: \"roundable\",\n    props: {\n        roundable: Boolean,\n        roundRelative: Boolean,\n        minRoundControls: Array,\n        maxRoundControls: Array,\n        roundClickable: Boolean,\n        roundPadding: Number,\n        isDisplayShadowRoundControls: Boolean,\n    } as const,\n    events: {\n        onRoundStart: \"roundStart\",\n        onRound: \"round\",\n        onRoundEnd: \"roundEnd\",\n        onRoundGroupStart: \"roundGroupStart\",\n        onRoundGroup: \"roundGroup\",\n        onRoundGroupEnd: \"roundGroupEnd\",\n    } as const,\n    css: [\n        `.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n    z-index: 3;\n}`,\n        `.control.border-radius.vertical {\n    background: #d6d;\n    z-index: 2;\n}`,\n        `.control.border-radius.virtual {\n    opacity: 0.5;\n    z-index: 1;\n}`,\n        `:host.round-line-clickable .line.direction {\n    cursor: pointer;\n}`,\n    ],\n    className(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n        const roundClickable = moveable.props.roundClickable;\n\n        return roundClickable === true || roundClickable === \"line\" ? prefix(\"round-line-clickable\") : \"\";\n    },\n    requestStyle(): Array<keyof CSSStyleDeclaration> {\n        return [\"borderRadius\"];\n    },\n    render(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, React: Renderer): any {\n        const {\n            target,\n            width,\n            height,\n            allMatrix,\n            is3d,\n            left,\n            top,\n            borderRadiusState,\n        } = moveable.getState();\n\n        const {\n            minRoundControls = [0, 0],\n            maxRoundControls = [4, 4],\n            zoom,\n            roundPadding = 0,\n            isDisplayShadowRoundControls,\n            groupable,\n        } = moveable.props;\n\n        if (!target) {\n            return null;\n        }\n\n        const borderRadius = borderRadiusState || getStyleBorderRadius(moveable);\n        const n = is3d ? 4 : 3;\n        const radiusValues = getBorderRadius(\n            borderRadius,\n            width, height,\n            minRoundControls,\n            true,\n        );\n\n        if (!radiusValues) {\n            return null;\n        }\n        let verticalCount = 0;\n        let horizontalCount = 0;\n        const basePos = groupable ? [0, 0] : [left, top];\n\n        return radiusValues.map((v, i) => {\n            const horizontal = v.horizontal;\n            const vertical = v.vertical;\n            const direction = v.direction || \"\";\n            const originalPos = [...v.pos];\n\n            horizontalCount += Math.abs(horizontal);\n            verticalCount += Math.abs(vertical);\n\n\n            if (horizontal && direction.indexOf(\"n\") > -1) {\n                originalPos[1] -= roundPadding;\n            }\n            if (vertical && direction.indexOf(\"w\") > -1) {\n                originalPos[0] -= roundPadding;\n            }\n            if (horizontal && direction.indexOf(\"s\") > -1) {\n                originalPos[1] += roundPadding;\n            }\n            if (vertical && direction.indexOf(\"e\") > -1) {\n                originalPos[0] += roundPadding;\n            }\n            const pos = minus(calculatePosition(allMatrix, originalPos, n), basePos);\n\n            const isDisplay = v.vertical\n                ? verticalCount <= maxRoundControls[1] && (isDisplayShadowRoundControls || !v.virtual)\n                : horizontalCount <= maxRoundControls[0] && (isDisplayShadowRoundControls || !v.virtual);\n\n            return <div key={`borderRadiusControl${i}`}\n                className={prefix(\n                    \"control\", \"border-radius\",\n                    v.vertical ? \"vertical\" : \"\",\n                    v.virtual ? \"virtual\" : \"\",\n                )}\n                data-radius-index={i}\n                style={{\n                    display: isDisplay ? \"block\" : \"none\",\n                    transform: `translate(${pos[0]}px, ${pos[1]}px) scale(${zoom})`,\n                }}></div>;\n        });\n    },\n    dragControlCondition(moveable: any, e: any) {\n        if (!e.inputEvent || e.isRequest) {\n            return false;\n        }\n        const className = (e.inputEvent.target.getAttribute(\"class\") || \"\");\n\n        return className.indexOf(\"border-radius\") > -1\n            || (className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1);\n    },\n    dragGroupControlCondition(moveable: any, e: any) {\n        return this.dragControlCondition(moveable, e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { inputEvent, datas } = e;\n        const inputTarget = inputEvent.target;\n        const className = (inputTarget.getAttribute(\"class\") || \"\");\n        const isControl = className.indexOf(\"border-radius\") > -1;\n        const isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n        const controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n        let lineIndex = -1;\n\n        if (isLine) {\n            const indexAttr = inputTarget.getAttribute(\"data-line-key\")! || \"\";\n\n            if (indexAttr) {\n                lineIndex = parseInt(indexAttr.replace(/render-line-/g, \"\"), 10);\n\n                if (isNaN(lineIndex)) {\n                    lineIndex = -1;\n                }\n            }\n        }\n\n        if (!isControl && !isLine) {\n            return false;\n        }\n\n        const params = fillParams<OnRoundStart>(moveable, e, {});\n\n        const result = triggerEvent(\n            moveable, \"onRoundStart\", params);\n\n        if (result === false) {\n            return false;\n        }\n\n        datas.lineIndex = lineIndex;\n        datas.controlIndex = controlIndex;\n        datas.isControl = isControl;\n        datas.isLine = isLine;\n\n        setDragStart(moveable, e);\n\n        const {\n            roundRelative,\n            minRoundControls = [0, 0],\n        } = moveable.props;\n        const state = moveable.state;\n        const {\n            width,\n            height,\n        } = state;\n\n        datas.isRound = true;\n        datas.prevDist = [0, 0];\n        const borderRadius = getStyleBorderRadius(moveable);\n        const controlPoses = getBorderRadius(\n            borderRadius || \"\",\n            width,\n            height,\n            minRoundControls,\n            true,\n        ) || [];\n\n        datas.controlPoses = controlPoses;\n\n        state.borderRadiusState = getRadiusStyles(\n            controlPoses,\n            roundRelative!,\n            width,\n            height,\n        ).styles.join(\" \");\n        return params;\n    },\n    dragControl(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { datas } = e;\n        const controlPoses = datas.controlPoses as ControlPose[];\n\n        if (!datas.isRound || !datas.isControl || !controlPoses.length) {\n            return false;\n        }\n        const index = datas.controlIndex as number;\n\n        const [distX, distY] = getDragDist(e);\n        const dist = [distX, distY];\n        const delta = minus(dist, datas.prevDist);\n        const {\n            maxRoundControls = [4, 4],\n        } = moveable.props;\n        const { width, height } = moveable.state;\n        const selectedControlPose = controlPoses[index];\n\n        const selectedVertical = selectedControlPose.vertical;\n        const selectedHorizontal = selectedControlPose.horizontal;\n\n        // 0: [0, 1, 2, 3] maxCount === 1\n        // 0: [0, 2] maxCount === 2\n        // 1: [1, 3] maxCount === 2\n\n        // 0: [0] maxCount === 3\n        // 1: [1, 3] maxCount === 3\n\n        const dists = controlPoses.map(pose => {\n            const { horizontal, vertical } = pose;\n            const poseDist = [\n                horizontal * selectedHorizontal * dist[0],\n                vertical * selectedVertical * dist[1],\n            ];\n            if (horizontal) {\n                if (maxRoundControls[0] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {\n                    return poseDist;\n                }\n            } else if (maxRoundControls[1] === 0) {\n                poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;\n\n                return poseDist;\n            } else if (selectedVertical) {\n                if (maxRoundControls[1] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\n                    return poseDist;\n                }\n            }\n            return [0, 0];\n        });\n\n        dists[index] = dist;\n        const nextPoses = controlPoses.map((info, i) => {\n            return {\n                ...info,\n                pos: plus(info.pos, dists[i]),\n            };\n        });\n\n        if (index < 4) {\n            nextPoses.slice(0, index + 1).forEach(info => {\n                info.virtual = false;\n            });\n        } else {\n            nextPoses.slice(4, index + 1).forEach(info => {\n                info.virtual = false;\n            });\n        }\n\n        datas.prevDist = [distX, distY];\n\n        return triggerRoundEvent(\n            moveable,\n            e,\n            dist,\n            delta,\n            nextPoses,\n        );\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const state = moveable.state;\n\n        state.borderRadiusState = \"\";\n        const { datas, isDouble } = e;\n        if (!datas.isRound) {\n            return false;\n        }\n        const {\n            isControl,\n            controlIndex,\n            isLine,\n            lineIndex,\n        } = datas;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const length = controlPoses.filter(({ virtual }) => virtual).length;\n        const {\n            roundClickable = true,\n        } = moveable.props;\n\n        if (isDouble && roundClickable) {\n            if (isControl && (roundClickable === true || roundClickable === \"control\")) {\n                removeBorderRadius(controlPoses, controlIndex);\n            } else if (isLine && (roundClickable === true || roundClickable === \"line\")) {\n                const [distX, distY] = calculatePointerDist(moveable, e);\n\n                addBorderRadiusByLine(controlPoses, lineIndex, distX, distY);\n            }\n\n            if (length !== controlPoses.filter(({ virtual }) => virtual).length) {\n                triggerRoundEvent(\n                    moveable,\n                    e,\n                    [0, 0],\n                    [0, 0],\n                    controlPoses,\n                );\n            }\n        }\n        const params = fillEndParams<OnRoundEnd>(moveable, e, {});\n\n        triggerEvent(moveable, \"onRoundEnd\", params);\n        state.borderRadiusState = \"\";\n        return params;\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<RoundableProps, RoundableState>, e: any) {\n        const result = this.dragControlStart(moveable, e);\n\n        if (!result) {\n            return false;\n        }\n\n        const moveables = moveable.moveables;\n        const targets = moveable.props.targets!;\n        const events = fillChildEvents(moveable, \"roundable\", e);\n\n        const nextParams: OnRoundGroupStart = {\n            targets: moveable.props.targets!,\n            events: events.map((ev, i) => {\n                return {\n                    ...ev,\n                    target: targets[i],\n                    moveable: moveables[i],\n                    currentTarget: moveables[i],\n                };\n            }),\n            ...result,\n        };\n\n        triggerEvent(moveable, \"onRoundGroupStart\", nextParams);\n        return result;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<RoundableProps, RoundableState>, e: any) {\n        const result = this.dragControl(moveable, e);\n\n\n        if (!result) {\n            return false;\n        }\n\n        const moveables = moveable.moveables;\n        const targets = moveable.props.targets!;\n        const events = fillChildEvents(moveable, \"roundable\", e);\n\n        const nextParams: OnRoundGroup = {\n            targets: moveable.props.targets!,\n            events: events.map((ev, i) => {\n                return {\n                    ...ev,\n                    target: targets[i],\n                    moveable: moveables[i],\n                    currentTarget: moveables[i],\n                    ...fillCSSObject({\n                        borderRadius: result.borderRadius,\n                    }, ev),\n                };\n            }),\n            ...result,\n        };\n\n        triggerEvent(moveable, \"onRoundGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<RoundableProps, RoundableState>, e: any) {\n        const moveables = moveable.moveables;\n        const targets = moveable.props.targets!;\n        const events = fillChildEvents(moveable, \"roundable\", e);\n\n        catchEvent(moveable, \"onRound\", parentEvent => {\n            const nextParams: OnRoundGroup = {\n                targets: moveable.props.targets!,\n                events: events.map((ev, i) => {\n                    return {\n                        ...ev,\n                        target: targets[i],\n                        moveable: moveables[i],\n                        currentTarget: moveables[i],\n                        ...fillCSSObject({\n                            borderRadius: parentEvent.borderRadius,\n                        }, ev),\n                    };\n                }),\n                ...parentEvent,\n            };\n            triggerEvent(moveable, \"onRoundGroup\", nextParams);\n        });\n        const result = this.dragControlEnd(moveable, e);\n\n        if (!result) {\n            return false;\n        }\n        const nextParams: OnRoundGroupEnd = {\n            targets: moveable.props.targets!,\n            events: events.map((ev, i) => {\n                return {\n                    ...ev,\n                    target: targets[i],\n                    moveable: moveables[i],\n                    currentTarget: moveables[i],\n                    lastEvent: ev.datas?.lastEvent,\n                };\n            }),\n            ...result,\n        };\n\n        triggerEvent(moveable, \"onRoundGroupEnd\", nextParams);\n        return nextParams;\n    },\n    unset(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n        moveable.state.borderRadiusState = \"\";\n    },\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])\n * @name Moveable.Roundable#minRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     minRoundControls: [0, 0],\n * });\n * moveable.minRoundControls = [1, 0];\n */\n/**\n * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])\n * @name Moveable.Roundable#maxRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     maxRoundControls: [4, 4],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n/**\n * Whether you can add/delete round controls by double-clicking a line or control.\n * @name Moveable.Roundable#roundClickable\n * @default true\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     roundClickable: true,\n * });\n * moveable.roundClickable = false;\n */\n\n/**\n * Whether to show a round control that does not actually exist as a shadow\n * @name Moveable.Roundable#isDisplayShadowRoundControls\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     isDisplayShadowRoundControls: false,\n * });\n * moveable.isDisplayShadowRoundControls = true;\n */\n\n\n/**\n * The padding value of the position of the round control\n * @name Moveable.Roundable#roundPadding\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundPadding: 0,\n * });\n * moveable.roundPadding = 15;\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag start the clip area or controls, the `roundGroupStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundGroupStart\n * @param {Moveable.Roundable.OnRoundGroupStart} - Parameters for the `roundGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     targets: [target1, target2, target3],\n *     roundable: true,\n * });\n * moveable.on(\"roundGroupStart\", e => {\n *     console.log(e.targets);\n * }).on(\"roundGroup\", e => {\n *   e.events.forEach(ev => {\n *       ev.target.style.cssText += ev.cssText;\n *   });\n * }).on(\"roundGroupEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag or double click the border area or controls, the `roundGroup` event is called.\n * @memberof Moveable.Roundable\n * @event roundGroup\n * @param {Moveable.Roundable.OnRoundGroup} - Parameters for the `roundGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     targets: [target1, target2, target3],\n *     roundable: true,\n * });\n * moveable.on(\"roundGroupStart\", e => {\n *     console.log(e.targets);\n * }).on(\"roundGroup\", e => {\n *   e.events.forEach(ev => {\n *       ev.target.style.cssText += ev.cssText;\n *   });\n * }).on(\"roundGroupEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag end the border area or controls, the `roundGroupEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundGroupEnd\n * @param {Moveable.Roundable.onRoundGroupEnd} - Parameters for the `roundGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     targets: [target1, target2, target3],\n *     roundable: true,\n * });\n * moveable.on(\"roundGroupStart\", e => {\n *     console.log(e.targets);\n * }).on(\"roundGroup\", e => {\n *     e.events.forEach(ev => {\n *         ev.target.style.cssText += ev.cssText;\n *     });\n * }).on(\"roundGroupEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    MoveableManagerInterface, BeforeRenderableProps,\n    OnBeforeRenderStart, OnBeforeRender, OnBeforeRenderEnd,\n    MoveableGroupInterface, OnBeforeRenderGroupStart,\n    OnBeforeRenderGroup, OnBeforeRenderGroupEnd,\n} from \"../types\";\nimport { fillParams, triggerEvent } from \"../utils\";\nimport { convertMatrixtoCSS, createIdentityMatrix } from \"@scena/matrix\";\nimport { isArray, splitSpace } from \"@daybrush/utils\";\nimport { fillChildEvents } from \"../groupUtils\";\n\n\nfunction isIdentityMatrix(matrix: string, is3d?: boolean) {\n    const n = is3d ? 4 : 3;\n    const identityMatrix = createIdentityMatrix(n);\n    const value = `matrix${is3d ? \"3d\" : \"\"}(${identityMatrix.join(\",\")})`;\n\n    return matrix === value || matrix === `matrix(1,0,0,1,0,0)`;\n}\nexport default {\n    isPinch: true,\n    name: \"beforeRenderable\",\n    props: {\n    } as const,\n    events: {\n        onBeforeRenderStart: \"beforeRenderStart\",\n        onBeforeRender: \"beforeRender\",\n        onBeforeRenderEnd: \"beforeRenderEnd\",\n        onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n        onBeforeRenderGroup: \"beforeRenderGroup\",\n        onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\",\n    } as const,\n    dragRelation: \"weak\",\n    setTransform(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        const {\n            is3d,\n            target,\n            targetMatrix,\n        } = moveable.state;\n        const transform = target?.style.transform;\n        const cssMatrix = is3d\n            ? `matrix3d(${targetMatrix.join(\",\")})`\n            : `matrix(${convertMatrixtoCSS(targetMatrix, true)})`;\n        const startTransform = !transform || transform === \"none\" ? cssMatrix : transform;\n\n        e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : splitSpace(startTransform);\n    },\n    resetStyle(e: any) {\n        const datas = e.datas;\n\n        datas.nextStyle = {};\n        datas.nextTransforms = e.datas.startTransforms;\n        datas.nextTransformAppendedIndexes = [];\n    },\n    fillDragStartParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRenderStart>(moveable, e, {\n            setTransform: (transform: string | string[]) => {\n                e.datas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            },\n            isPinch: !!e.isPinch,\n        });\n    },\n    fillDragParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        });\n    },\n    dragStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        this.setTransform(moveable, e);\n        this.resetStyle(e);\n\n        triggerEvent(moveable, `onBeforeRenderStart`, this.fillDragStartParams(moveable, e));\n    },\n    drag(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        this.resetStyle(e);\n        triggerEvent(moveable, `onBeforeRender`, fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    dragEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        triggerEvent(moveable, `onBeforeRenderEnd`, fillParams<OnBeforeRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragStart(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.setTransform(childMoveable, childEvent);\n            this.resetStyle(childEvent);\n\n            return this.fillDragStartParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, `onBeforeRenderGroupStart`, fillParams<OnBeforeRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            setTransform() { },\n            events: params,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.drag(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.resetStyle(childEvent);\n            return this.fillDragParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, `onBeforeRenderGroup`, fillParams<OnBeforeRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            events: params,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragEnd(moveable, e);\n\n        triggerEvent(moveable, `onBeforeRenderGroupEnd`, fillParams<OnBeforeRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n} as const;\n","import { getNextStyle, getNextTransformText } from \"../gesto/GestoUtils\";\nimport { fillChildEvents } from \"../groupUtils\";\nimport {\n    MoveableManagerInterface, RenderableProps, OnRenderStart, OnRender,\n    OnRenderEnd, MoveableGroupInterface,\n    OnRenderGroupStart, OnRenderGroup, OnRenderGroupEnd,\n} from \"../types\";\nimport { triggerEvent, fillParams, fillCSSObject } from \"../utils\";\n\nexport default {\n    name: \"renderable\",\n    props: {\n    } as const,\n    events: {\n        onRenderStart: \"renderStart\",\n        onRender: \"render\",\n        onRenderEnd: \"renderEnd\",\n        onRenderGroupStart: \"renderGroupStart\",\n        onRenderGroup: \"renderGroup\",\n        onRenderGroupEnd: \"renderGroupEnd\",\n    } as const,\n    dragRelation: \"weak\",\n    dragStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderStart`, fillParams<OnRenderStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    drag(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRender`, this.fillDragParams(moveable, e));\n    },\n    dragAfter(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        if (e.resultCount) {\n            return this.drag(moveable, e);\n        }\n    },\n    dragEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderEnd`, this.fillDragEndParams(moveable, e));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderGroupStart`, fillParams<OnRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            return this.fillDragParams(childMoveable, childEvent);\n        });\n\n        triggerEvent(moveable, `onRenderGroup`, fillParams<OnRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n            events: params,\n        },));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            return this.fillDragEndParams(childMoveable, childEvent);\n        });\n\n        triggerEvent(moveable, `onRenderGroupEnd`, fillParams<OnRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n            events: params,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlAfter(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragAfter(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n    fillDragParams(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return fillParams<OnRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n        });\n    },\n    fillDragEndParams(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return fillParams<OnRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n        });\n    },\n} as const;\n","import { Able, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { convertDragDist, defaultSync } from \"../utils\";\nimport Gesto, { GestoOptions } from \"gesto\";\nimport BeforeRenderable from \"../ables/BeforeRenderable\";\nimport Renderable from \"../ables/Renderable\";\n\nexport function triggerAble(\n    moveable: MoveableManagerInterface,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: any,\n    requestInstant?: boolean,\n) {\n    const isStart = eventType === \"Start\";\n    const target = moveable.state.target;\n    const isRequest = e.isRequest;\n\n    if (\n        !target\n        || (isStart && eventAffix.indexOf(\"Control\") > -1\n            && !isRequest && moveable.areaElement === e.inputEvent.target)\n    ) {\n        return false;\n    }\n    // \"drag\" \"Control\" \"After\"\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType === \"After\";\n    const isFirstStart = isStart && (\n        !moveable.targetGesto || !moveable.controlGesto\n        || (!moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag())\n    );\n\n    if (isFirstStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    e.clientDistX = e.distX;\n    e.clientDistY = e.distY;\n    if (eventType === \"\" && !isRequest) {\n        // Convert distX, distY\n        convertDragDist(moveable.state, e);\n    }\n    // const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Able[] = [...(moveable as any)[ableType]];\n\n    if (isRequest) {\n        const requestAble = e.requestAble;\n\n        if (!ables.some(able => able.name === requestAble)) {\n            ables.push(...moveable.props.ables!.filter(able => able.name === requestAble));\n        }\n    }\n    if (!ables.length || ables.every(able => able.dragRelation)) {\n        return false;\n    }\n    const eventAbles: Able[] = [BeforeRenderable, ...ables, Renderable].filter((able: any) => able[eventName]);\n    const datas = e.datas;\n\n    if (isFirstStart) {\n        eventAbles.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n\n    const inputEvent = e.inputEvent;\n    let inputTarget: Element;\n\n    if (isEnd && inputEvent) {\n        inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\n    }\n    let resultCount = 0;\n\n    let isDragStop = false;\n    const stop = () => {\n        isDragStop = true;\n        e.stop?.();\n    };\n    const results = eventAbles.filter((able: any) => {\n        const ableName = able.name;\n        const nextDatas = datas[ableName] || (datas[ableName] = {});\n\n        if (isStart) {\n            nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);\n        }\n\n        if (nextDatas.isEventStart) {\n            const result = able[eventName](moveable, {\n                ...e,\n                stop,\n                resultCount,\n                datas: nextDatas,\n                originalDatas: datas,\n                inputTarget,\n            });\n\n            (moveable as any)._emitter.off();\n            if (isStart && result === false) {\n                nextDatas.isEventStart = false;\n            }\n            resultCount += result || nextDatas.isEventStart ? 1 : 0;\n            return result;\n        }\n        return false;\n    });\n\n    const isUpdate = results.length;\n    let isForceEnd = false;\n\n    // end ables\n    if (isDragStop) {\n        isForceEnd = true;\n    }\n    if (!isForceEnd && isStart && eventAbles.length && !isUpdate) {\n        isForceEnd = eventAbles.filter(able => {\n            const ableName = able.name;\n            const nextDatas = datas[ableName];\n\n            if (nextDatas.isEventStart) {\n                if (able.dragRelation === \"strong\") {\n                    return false;\n                }\n                // start drag\n                return true;\n            }\n            // cancel event\n            return false;\n        }).length as any;\n    }\n\n    if (isEnd || isForceEnd) {\n        moveable.state.gestos = {};\n\n        if ((moveable as MoveableGroupInterface).moveables) {\n            (moveable as MoveableGroupInterface).moveables.forEach(childMoveable => {\n                childMoveable.state.gestos = {};\n            });\n        }\n        eventAbles.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n    if (isStart && !isForceEnd && !isRequest && isUpdate) {\n        e?.preventDefault();\n    }\n    if (moveable.isUnmounted || isForceEnd) {\n        return false;\n    }\n    if ((!isStart && isUpdate && !requestInstant) || isEnd) {\n        const flushSync = moveable.props.flushSync || defaultSync;\n\n        flushSync(() => {\n            moveable.updateRect(isEnd ? eventType : \"\", true, false);\n            moveable.forceUpdate();\n        });\n\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n    return true;\n}\n\nexport function checkMoveableTarget(moveable: MoveableManagerInterface) {\n    return (e: { inputEvent: Event }) => {\n        const {\n            dragTarget,\n        } = moveable.props;\n        const eventTarget = e.inputEvent.target as Element;\n        const areaElement = moveable.areaElement;\n\n        return dragTarget && (eventTarget === dragTarget || dragTarget.contains(eventTarget))\n            || eventTarget === areaElement\n            || (!moveable.isMoveableElement(eventTarget) && !moveable.controlBox.getElement().contains(eventTarget))\n            || hasClass(eventTarget, \"moveable-area\")\n            || hasClass(eventTarget, \"moveable-padding\")\n            || hasClass(eventTarget, \"moveable-edgeDraggable\");\n    };\n}\n\nexport function getTargetAbleGesto(\n    moveable: MoveableManagerInterface,\n    moveableTarget: HTMLElement | SVGElement,\n    eventAffix: string,\n) {\n    const controlBox = moveable.controlBox.getElement();\n    const targets: Array<HTMLElement | SVGElement> = [];\n    const dragTarget = moveable.props.dragTarget;\n\n    targets.push(controlBox);\n\n    if (!moveable.props.dragArea || dragTarget) {\n        targets.push(moveableTarget);\n    }\n\n    return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\n        dragStart: checkMoveableTarget(moveable),\n        pinchStart: checkMoveableTarget(moveable),\n    });\n}\nexport function getAbleGesto(\n    moveable: MoveableManagerInterface,\n    target: HTMLElement | SVGElement | Array<HTMLElement | SVGElement>,\n    ableType: string,\n    eventAffix: string,\n    conditionFunctions: IObject<any> = {},\n) {\n    const isTargetAbles = ableType === \"targetAbles\";\n    const {\n        pinchOutside,\n        pinchThreshold,\n        preventClickEventOnDrag,\n        preventClickDefault,\n        checkInput,\n    } = moveable.props;\n    const options: GestoOptions = {\n        preventDefault: true,\n        preventRightClick: true,\n        preventWheelClick: true,\n        container: window,\n        pinchThreshold,\n        pinchOutside,\n        preventClickEventOnDrag: isTargetAbles ? preventClickEventOnDrag : false,\n        preventClickEventOnDragStart: isTargetAbles ? preventClickDefault : false,\n        preventClickEventByCondition: isTargetAbles ? null : (e: MouseEvent) => {\n            return moveable.controlBox.getElement().contains(e.target as Element);\n        },\n        checkInput: isTargetAbles ? checkInput : false,\n    };\n    const gesto = new Gesto(target!, options);\n    const isControl = eventAffix === \"Control\";\n\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n\n            gesto.on(`${eventOperation}${eventType}` as any, e => {\n                const eventName = e.eventType;\n\n                if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n                    e.stop();\n                    return;\n                }\n                const result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n\n                if (!result) {\n                    e.stop();\n                } else if (moveable.props.stopPropagation || (eventType === \"Start\" && isControl)) {\n                    e?.inputEvent?.stopPropagation();\n                }\n            });\n        });\n    });\n\n    return gesto;\n}\n","import { Able, MoveableManagerInterface } from \"./types\";\n\nexport default class EventManager {\n    private ables: Able[] = [];\n    constructor(\n        private target: HTMLElement | SVGElement | null,\n        private moveable: MoveableManagerInterface | null,\n        private eventName: string,\n    ) {\n        target!.addEventListener(eventName.toLowerCase(), this._onEvent);\n    }\n    public setAbles(ables: Able[]) {\n        this.ables = ables;\n    }\n    public destroy() {\n        this.target!.removeEventListener(this.eventName.toLowerCase(), this._onEvent);\n        this.target = null;\n        this.moveable = null;\n    }\n    private _onEvent = (e: Event) => {\n        const eventName = this.eventName;\n        const moveable = this.moveable!;\n\n        if (moveable.state.disableNativeEvent) {\n            return;\n        }\n        this.ables.forEach(able => {\n            (able as any)[eventName](moveable, {\n                inputEvent: e,\n            });\n        });\n    }\n}\n","import {\n    convertCSStoMatrix, convertDimension,\n    createIdentityMatrix, createOriginMatrix, createScaleMatrix,\n} from \"@scena/matrix\";\nimport { IS_WEBKIT, IS_SAFARI_ABOVE15, IS_FIREFOX } from \"../consts\";\nimport { MatrixInfo } from \"../types\";\nimport {\n    getOffsetInfo, getElementTransform,\n    getTransformMatrix, getPositionFixedInfo,\n    convert3DMatrixes, getOffsetPosInfo,\n    getSVGMatrix, getBodyOffset, getAbsoluteMatrix,\n} from \"../utils\";\n\n\nexport function getShadowRoot(parentElement: HTMLElement | SVGElement) {\n    if (parentElement && parentElement.getRootNode) {\n        const rootNode = parentElement.getRootNode();\n\n        if (rootNode.nodeType === 11) {\n            return rootNode;\n        }\n    }\n    return;\n}\n\nexport function getMatrixStackInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    checkContainer?: boolean,\n) {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: MatrixInfo[] = [];\n    const documentElement = document.documentElement || document.body;\n    let requestEnd = !checkContainer && target === container || target === documentElement;\n    let isEnd = requestEnd;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetTransformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    let hasFixed = false;\n    let offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n    let zoom = 1;\n\n    while (el && !isEnd) {\n        isEnd = requestEnd;\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const position = style.position;\n        const transform = getElementTransform(el, style);\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(transform));\n        const isFixed = position === \"fixed\";\n        let fixedInfo: {\n            hasTransform: boolean;\n            fixedContainer: HTMLElement | null;\n        } = {\n            hasTransform: false,\n            fixedContainer: null,\n        };\n        if (isFixed) {\n            hasFixed = true;\n            fixedInfo = getPositionFixedInfo(el);\n\n            offsetContainer = fixedInfo.fixedContainer!;\n        }\n\n        // convert 3 to 4\n        const length = matrix.length;\n\n        if (!is3d && length === 16) {\n            is3d = true;\n            n = 4;\n\n            convert3DMatrixes(matrixes);\n            if (targetMatrix) {\n                targetMatrix = convertDimension(targetMatrix, 3, 4);\n            }\n        }\n        if (is3d && length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n        const {\n            tagName,\n            hasOffset,\n            isSVG,\n            origin,\n            targetOrigin,\n            offset: offsetPos,\n        } = getOffsetPosInfo(el, target, style);\n        let [\n            offsetLeft,\n            offsetTop,\n        ] = offsetPos;\n\n        if (tagName === \"svg\" && targetMatrix) {\n            // scale matrix for svg's SVGElements.\n            matrixes.push({\n                type: \"target\",\n                target: el,\n                matrix: getSVGMatrix(el as SVGSVGElement, n),\n            });\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createIdentityMatrix(n),\n            });\n        }\n\n        let offsetParent: HTMLElement;\n        let isOffsetEnd = false;\n        let isStatic = false;\n\n        const targetZoom = parseFloat((style as any).zoom) || 1;\n\n        if (isFixed) {\n            offsetParent = fixedInfo.fixedContainer!;\n            isOffsetEnd = true;\n        } else {\n            const offsetInfo = getOffsetInfo(el, container, false, true, style);\n            const offsetZoom = offsetInfo.offsetZoom;\n\n            offsetParent = offsetInfo.offsetParent;\n            isOffsetEnd = offsetInfo.isEnd;\n            isStatic = offsetInfo.isStatic;\n            zoom *= offsetZoom;\n\n            if (offsetZoom !== 1 && isStatic) {\n                offsetLeft -= offsetParent.offsetLeft;\n                offsetTop -= offsetParent.offsetTop;\n            } else if (IS_FIREFOX) {\n                const parentSlotElement = offsetInfo.parentSlotElement;\n\n                if (parentSlotElement) {\n                    let customOffsetParent: HTMLElement | null = offsetParent;\n                    let customOffsetLeft = 0;\n                    let customOffsetTop = 0;\n\n                    while (customOffsetParent) {\n                        if (!getShadowRoot(customOffsetParent)) {\n                            break;\n                        }\n                        customOffsetLeft += customOffsetParent.offsetLeft;\n                        customOffsetTop += customOffsetParent.offsetTop;\n                        customOffsetParent = customOffsetParent.offsetParent as HTMLElement;\n                    }\n                    offsetLeft -= customOffsetLeft;\n                    offsetTop -= customOffsetTop;\n                }\n            }\n        }\n\n        if (\n            IS_WEBKIT && !IS_SAFARI_ABOVE15\n            && hasOffset && !isSVG && isStatic\n            && (position === \"relative\" || position === \"static\")\n        ) {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            requestEnd = requestEnd || isOffsetEnd;\n        }\n\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n        let fixedClientLeft = 0;\n        let fixedClientTop = 0;\n\n        if (isFixed) {\n            if (hasOffset && fixedInfo.hasTransform) {\n                // border\n                fixedClientLeft = offsetParent.clientLeft;\n                fixedClientTop = offsetParent.clientTop;\n            }\n        } else {\n            if (hasOffset && offsetContainer !== offsetParent) {\n                // border\n                parentClientLeft = offsetParent.clientLeft;\n                parentClientTop = offsetParent.clientTop;\n            }\n            if (hasOffset && offsetParent === documentElement) {\n                const margin = getBodyOffset(el, false, style);\n\n                offsetLeft += margin[0];\n                offsetTop += margin[1];\n            }\n        }\n\n        matrixes.push({\n            type: \"target\",\n            target: el,\n            matrix: getAbsoluteMatrix(matrix, n, origin),\n        });\n\n        if (hasOffset) {\n            const isElementTarget = el === target;\n            const scrollLeft = isElementTarget ? 0 : el.scrollLeft;\n            const scrollTop = isElementTarget ? 0 : el.scrollTop;\n\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createOriginMatrix([\n                    offsetLeft - scrollLeft + parentClientLeft - fixedClientLeft,\n                    offsetTop - scrollTop + parentClientTop - fixedClientTop,\n                ], n),\n            });\n        } else {\n            // svg\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                origin,\n            });\n        }\n        // transform   zoom  (0, 0)   matrix .\n        if (targetZoom !== 1) {\n            matrixes.push({\n                type: \"zoom\",\n                target: el,\n                matrix: getAbsoluteMatrix(createScaleMatrix([targetZoom, targetZoom], n), n, [0, 0]),\n            });\n        }\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (!targetTransformOrigin) {\n            targetTransformOrigin = targetOrigin;\n        }\n\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            requestEnd = isOffsetEnd;\n        }\n        if (!checkContainer || el === documentElement) {\n            isEnd = requestEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [0, 0];\n    }\n    if (!targetTransformOrigin) {\n        targetTransformOrigin = [0, 0];\n    }\n\n    return {\n        zoom,\n        offsetContainer,\n        matrixes,\n        targetMatrix,\n        transformOrigin,\n        targetOrigin: targetTransformOrigin,\n        is3d,\n        hasFixed,\n    };\n}\n","import { createIdentityMatrix, convertDimension, multiply, createOriginMatrix, ignoreDimension } from \"@scena/matrix\";\nimport { convert3DMatrixes, getOffsetInfo, getSVGOffset, makeMatrixCSS } from \"../utils\";\nimport { getMatrixStackInfo } from \"./getMatrixStackInfo\";\n\nexport interface MoveableElementMatrixInfo {\n    hasZoom: boolean;\n    hasFixed: boolean;\n    originalRootMatrix: number[];\n    rootMatrix: number[];\n    beforeMatrix: number[];\n    offsetMatrix: number[];\n    allMatrix: number[];\n    targetMatrix: number[];\n    transformOrigin: number[];\n    targetOrigin: number[];\n    is3d: boolean;\n    targetTransform: string;\n    offsetContainer: HTMLElement | null,\n    offsetRootContainer: HTMLElement | null,\n}\n\nexport function calculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null | undefined = container,\n    isAbsolute3d?: boolean,\n    // prevMatrix?: number[],\n    // prevRootMatrix?: number[],\n    // prevN?: number,\n): MoveableElementMatrixInfo {\n    const {\n        matrixes,\n        is3d,\n        targetMatrix: prevTargetMatrix,\n        transformOrigin,\n        targetOrigin,\n        offsetContainer,\n        hasFixed,\n        zoom: containerZoom,\n    } = getMatrixStackInfo(target, container); // prevMatrix\n    const {\n        matrixes: rootMatrixes,\n        is3d: isRoot3d,\n        offsetContainer: offsetRootContainer,\n        zoom: rootZoom,\n    } = getMatrixStackInfo(offsetContainer, rootContainer, true); // prevRootMatrix\n\n    // if (rootContainer === document.body) {\n    //     console.log(offsetContainer, rootContainer, rootMatrixes);\n    // }\n    const isNext3d = isAbsolute3d || isRoot3d || is3d;\n    const n = isNext3d ? 4 : 3;\n    const isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n    let targetMatrix = prevTargetMatrix;\n    // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let allMatrix = createIdentityMatrix(n);\n    let rootMatrix = createIdentityMatrix(n);\n    let beforeMatrix = createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n\n    rootMatrixes.reverse();\n    matrixes.reverse();\n\n    if (!is3d && isNext3d) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n\n        convert3DMatrixes(matrixes);\n    }\n    if (!isRoot3d && isNext3d) {\n        convert3DMatrixes(rootMatrixes);\n    }\n\n\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n    // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n    rootMatrixes.forEach(info => {\n        rootMatrix = multiply(rootMatrix, info.matrix!, n);\n    });\n    const originalRootContainer = rootContainer || document.body;\n    const endContainer = rootMatrixes[0]?.target\n        || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;\n    const rootMatrixBeforeOffset = rootMatrixes.slice(1).reduce((matrix, info) => {\n        return multiply(matrix, info.matrix!, n);\n    }, createIdentityMatrix(n));\n    matrixes.forEach((info, i) => {\n        if (length - 2 === i) {\n            // length - 3\n            beforeMatrix = allMatrix.slice();\n        }\n        if (length - 1 === i) {\n            // length - 2\n            offsetMatrix = allMatrix.slice();\n        }\n\n        // calculate for SVGElement\n        if (!info.matrix) {\n            const nextInfo = matrixes[i + 1];\n            const offset = getSVGOffset(\n                info,\n                nextInfo,\n                endContainer,\n                n,\n                multiply(rootMatrixBeforeOffset, allMatrix, n),\n            );\n            info.matrix = createOriginMatrix(offset, n);\n        }\n        allMatrix = multiply(allMatrix, info.matrix!, n);\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n    }\n    const targetTransform = makeMatrixCSS(\n        isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix,\n        isMatrix3d,\n    );\n\n    const originalRootMatrix = rootMatrix;\n    rootMatrix = ignoreDimension(rootMatrix, n, n);\n\n    return {\n        hasZoom: containerZoom !== 1 || rootZoom !== 1,\n        hasFixed,\n        rootMatrix,\n        originalRootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        allMatrix,\n        targetMatrix,\n        targetTransform,\n        transformOrigin,\n        targetOrigin,\n        is3d: isNext3d,\n        offsetContainer,\n        offsetRootContainer,\n    };\n}\n","import { createIdentityMatrix } from \"@scena/matrix\";\nimport { ElementSizes, MoveablePosition } from \"../types\";\nimport { calculateMoveablePosition, getSize, getRotationRad } from \"../utils\";\nimport { calculateMatrixStack, MoveableElementMatrixInfo } from \"./calculateMatrixStack\";\n\nexport interface MoveableElementInfo extends MoveableElementMatrixInfo, MoveablePosition, ElementSizes {\n    width: number;\n    height: number;\n    rotation: number;\n}\n\nexport function calculateElementInfo(\n    target?: SVGElement | HTMLElement | null,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: HTMLElement | SVGElement | null | undefined = container,\n    isAbsolute3d?: boolean,\n): MoveableElementInfo {\n    let width = 0;\n    let height = 0;\n    let rotation = 0;\n    let allResult: {} = {};\n\n    const sizes = getSize(target);\n\n    if (target) {\n        width = sizes.offsetWidth;\n        height = sizes.offsetHeight;\n    }\n\n    if (target) {\n        const result = calculateMatrixStack(\n            target,\n            container,\n            rootContainer,\n            isAbsolute3d,\n            // prevMatrix, prevRootMatrix, prevN,\n        );\n\n        const position = calculateMoveablePosition(\n            result.allMatrix,\n            result.transformOrigin,\n            width, height,\n        );\n        allResult = {\n            ...result,\n            ...position,\n        };\n        const rotationPosition = calculateMoveablePosition(\n            result.allMatrix, [50, 50], 100, 100,\n        );\n        rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);\n    }\n    const n = isAbsolute3d ? 4 : 3;\n\n    return {\n        hasZoom: false,\n        width,\n        height,\n        rotation,\n        ...sizes,\n        originalRootMatrix: createIdentityMatrix(n),\n        rootMatrix: createIdentityMatrix(n),\n        beforeMatrix: createIdentityMatrix(n),\n        offsetMatrix: createIdentityMatrix(n),\n        allMatrix: createIdentityMatrix(n),\n        targetMatrix: createIdentityMatrix(n),\n        targetTransform: \"\",\n        transformOrigin: [0, 0],\n        targetOrigin: [0, 0],\n        is3d: !!isAbsolute3d,\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        direction: 1,\n        hasFixed: false,\n        offsetContainer: null,\n        offsetRootContainer: null,\n        ...allResult,\n    };\n}\n\n\nexport function getElementInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null | undefined = container,\n) {\n    return calculateElementInfo(target, container, rootContainer, true);\n}\n","import { plus, getOrigin, multiply, minus } from \"@scena/matrix\";\nimport { MoveableClientRect, Writable } from \"../types\";\nimport {\n    calculateInversePosition,\n    calculateMoveablePosition,\n    getClientRect, getClientRectByPosition, getOffsetInfo, getTransformOrigin, resetClientRect,\n} from \"../utils\";\nimport { calculateElementInfo, MoveableElementInfo } from \"./getElementInfo\";\n\n\nexport interface MoveableTargetInfo extends MoveableElementInfo {\n    targetClientRect: MoveableClientRect;\n    containerClientRect: MoveableClientRect;\n    moveableClientRect: MoveableClientRect;\n    rootContainerClientRect: MoveableClientRect;\n    beforeDirection: 1 | -1;\n    beforeOrigin: number[];\n    offsetDelta: number[],\n    originalBeforeOrigin: number[];\n    target: HTMLElement | SVGElement | null | undefined;\n    style: Partial<Writable<CSSStyleDeclaration>>;\n}\n\nexport function getMoveableTargetInfo(\n    moveableElement?: HTMLElement | null,\n    target?: HTMLElement | SVGElement | null,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    rootContainer?: HTMLElement | SVGElement | null,\n    requestStyle: Array<keyof CSSStyleDeclaration> = [],\n): MoveableTargetInfo {\n    let beforeDirection: 1 | -1 = 1;\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let moveableClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let rootContainerClientRect = resetClientRect();\n    let offsetDelta = [0, 0];\n    const style: Partial<Writable<CSSStyleDeclaration>> = {};\n\n    const result = calculateElementInfo(\n        target, container!, rootContainer!,\n        true,\n    );\n    if (target) {\n        const computedStyle = getComputedStyle(target);\n\n        requestStyle.forEach(name => {\n            style[name] = computedStyle[name] as any;\n        });\n        const n = result.is3d ? 4 : 3;\n        const beforePosition = calculateMoveablePosition(\n            result.offsetMatrix,\n            plus(result.transformOrigin, getOrigin(result.targetMatrix, n)),\n            result.width, result.height,\n        );\n        beforeDirection = beforePosition.direction;\n        beforeOrigin = plus(\n            beforePosition.origin,\n            [beforePosition.left - result.left, beforePosition.top - result.top],\n        );\n\n        rootContainerClientRect = getClientRect(result.offsetRootContainer!);\n\n\n        const offsetContainer = getOffsetInfo(parentContainer, parentContainer, true).offsetParent\n            || result.offsetRootContainer!;\n\n        if (result.hasZoom) {\n            const absoluteTargetPosition = calculateMoveablePosition(\n                multiply(result.originalRootMatrix, result.allMatrix),\n                result.transformOrigin,\n                result.width, result.height,\n            );\n            const absoluteContainerPosition = calculateMoveablePosition(\n                result.originalRootMatrix,\n                getTransformOrigin(getComputedStyle(offsetContainer)).map(pos => parseFloat(pos)),\n                offsetContainer.offsetWidth, offsetContainer.offsetHeight,\n            );\n            targetClientRect = getClientRectByPosition(absoluteTargetPosition, rootContainerClientRect);\n            containerClientRect = getClientRectByPosition(\n                absoluteContainerPosition,\n                rootContainerClientRect,\n                offsetContainer,\n                true,\n            );\n\n            if (moveableElement) {\n                const left = absoluteTargetPosition.left;\n                const top = absoluteTargetPosition.top;\n                moveableClientRect = getClientRectByPosition({\n                    left,\n                    top,\n                    bottom: top,\n                    right: top,\n                }, rootContainerClientRect);\n            }\n        } else {\n            targetClientRect = getClientRect(target);\n            containerClientRect = getClientRect(offsetContainer, true);\n\n            if (moveableElement) {\n                moveableClientRect = getClientRect(moveableElement);\n            }\n            const {\n                left: containerClientRectLeft,\n                top: containerClientRectTop,\n                clientLeft: containterClientLeft,\n                clientTop: containerClientTop,\n            } = containerClientRect;\n            const clientDelta = [\n                targetClientRect.left - containerClientRectLeft,\n                targetClientRect.top - containerClientRectTop,\n            ];\n\n            offsetDelta = minus(\n                calculateInversePosition(result.rootMatrix, clientDelta, 4),\n                [containterClientLeft! + result.left, containerClientTop! + result.top],\n            );\n        }\n    }\n\n    return {\n        targetClientRect,\n        containerClientRect,\n        moveableClientRect,\n        rootContainerClientRect,\n        beforeDirection,\n        beforeOrigin,\n        originalBeforeOrigin: beforeOrigin,\n        target,\n        style,\n        offsetDelta,\n        ...result,\n    };\n}\n","import { minus } from \"@scena/matrix\";\nimport { getMinMaxs } from \"overlap-area\";\nimport { MoveableManagerState, PersistRectData } from \"../types\";\n\n\nexport function getPersistState(rect: PersistRectData): Partial<MoveableManagerState> | null {\n    let {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = rect;\n    if (!pos1 || !pos2 || !pos3 || !pos4) {\n        return null;\n    }\n    const minPos = getMinMaxs([pos1!, pos2!, pos3!, pos4!]);\n    const posDelta = [minPos.minX, minPos.minY];\n    const origin = minus(rect.origin!, posDelta);\n\n    pos1 = minus(pos1, posDelta);\n    pos2 = minus(pos2, posDelta);\n    pos3 = minus(pos3, posDelta);\n    pos4 = minus(pos4, posDelta);\n    return {\n        ...rect,\n        left: rect.left,\n        top: rect.top,\n        posDelta,\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n        origin,\n        beforeOrigin: origin,\n        // originalBeforeOrigin: origin,\n        isPersisted: true,\n    };\n}\n","import * as React from \"react\";\nimport { createElement } from \"react\";\nimport { PREFIX } from \"./consts\";\nimport {\n    prefix,\n    unset,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n    flat,\n    groupByMap,\n    calculatePadding,\n    getAbsoluteRotation,\n    defaultSync,\n    getRefTarget,\n    groupBy,\n} from \"./utils\";\nimport Gesto from \"gesto\";\nimport { ref } from \"framework-utils\";\nimport {\n    MoveableManagerProps, MoveableManagerState, Able,\n    RectInfo, Requester, PaddingBox, HitRect, MoveableManagerInterface,\n    MoveableDefaultOptions,\n    GroupableProps,\n} from \"./types\";\nimport { triggerAble, getTargetAbleGesto, getAbleGesto, checkMoveableTarget } from \"./gesto/getAbleGesto\";\nimport { plus } from \"@scena/matrix\";\nimport {\n    addClass, cancelAnimationFrame, find,\n    getKeys, IObject, removeClass, requestAnimationFrame,\n} from \"@daybrush/utils\";\nimport { renderLine } from \"./renderDirections\";\nimport { fitPoints, getAreaSize, getOverlapSize, isInside } from \"overlap-area\";\nimport EventManager from \"./EventManager\";\nimport styled from \"react-css-styled\";\nimport EventEmitter from \"@scena/event-emitter\";\nimport { getMoveableTargetInfo } from \"./utils/getMoveableTargetInfo\";\nimport { VIEW_DRAGGING } from \"./classNames\";\nimport { diff } from \"@egjs/list-differ\";\nimport { getPersistState } from \"./utils/persist\";\n// import { getClipPath } from \"./ables/clippable/utils\";\n\nexport default class MoveableManager<T = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        dragTarget: null,\n        container: null,\n        rootContainer: null,\n        origin: true,\n        parentMoveable: null,\n        wrapperMoveable: null,\n        isWrapperMounted: false,\n        parentPosition: null,\n        portalContainer: null,\n        useResizeObserver: false,\n        linePadding: 0,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        passDragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n        zoom: 1,\n        triggerAblesSimultaneously: false,\n        padding: {},\n        pinchOutside: true,\n        checkInput: false,\n        groupable: false,\n        hideDefaultLines: false,\n        cspNonce: \"\",\n        translateZ: 0,\n        cssStyled: null,\n        customStyledMap: {},\n        props: {},\n        stopPropagation: false,\n        preventClickDefault: false,\n        preventClickEventOnDrag: true,\n        flushSync: defaultSync,\n        firstRenderState: null,\n        persistData: null,\n        viewContainer: null,\n        useAccuratePosition: false,\n    };\n    public state: MoveableManagerState = {\n        container: null,\n        gestos: {},\n        renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n        disableNativeEvent: false,\n        posDelta: [0, 0],\n        ...getMoveableTargetInfo(null),\n    };\n    public renderState: Record<string, any> = {};\n    public enabledAbles: Able[] = [];\n    public targetAbles: Able[] = [];\n    public controlAbles: Able[] = [];\n    public controlBox!: { getElement(): HTMLElement };\n    public areaElement!: HTMLElement;\n    public targetGesto!: Gesto;\n    public controlGesto!: Gesto;\n    public rotation = 0;\n    public scale: number[] = [1, 1];\n    public isMoveableMounted = false;\n    public isUnmounted = false;\n\n    public events: Record<string, EventManager | null> = {\n        \"mouseEnter\": null,\n        \"mouseLeave\": null,\n    };\n\n    protected _emitter: EventEmitter = new EventEmitter();\n    protected _prevTarget: HTMLElement | SVGElement | null | undefined = null;\n    protected _prevDragArea = false;\n    protected _isPropTargetChanged = false;\n    protected _hasFirstTarget = false;\n\n    private _observer: ResizeObserver | null = null;\n    private _observerId = 0;\n    public _rootContainer: HTMLElement | null | undefined = null;\n    private _viewContainer: HTMLElement | null | undefined = null;\n    private _viewClassNames: string[] = [];\n\n    public render() {\n        const props = this.props;\n        const state = this.getState();\n        const {\n            parentPosition,\n            className,\n            target: propsTarget,\n            zoom, cspNonce,\n            translateZ,\n            cssStyled: ControlBoxElement,\n            portalContainer,\n            groupable,\n            linePadding,\n        } = props;\n\n        this._checkUpdateRootContainer();\n        this.checkUpdate();\n        this.updateRenderPoses();\n\n        const [parentLeft, parentTop] = parentPosition as number[] || [0, 0];\n        const {\n            left,\n            top,\n            target: stateTarget,\n            direction,\n            hasFixed,\n            offsetDelta,\n        } = state;\n        const groupTargets = (props as any).targets;\n        const isDragging = this.isDragging();\n        const ableAttributes: IObject<boolean> = {};\n        this.getEnabledAbles().forEach(able => {\n            ableAttributes[`data-able-${able.name.toLowerCase()}`] = true;\n        });\n        const ableClassName = this._getAbleClassName();\n        const isDisplay\n            = (groupTargets && groupTargets.length && (stateTarget || groupable))\n            || propsTarget\n            || (!this._hasFirstTarget && this.state.isPersisted);\n        const isVisible = this.controlBox || this.props.firstRenderState || this.props.persistData;\n        const translate = [left - parentLeft, top - parentTop];\n\n        if (!groupable && props.useAccuratePosition) {\n            translate[0] += offsetDelta[0];\n            translate[1] += offsetDelta[1];\n        }\n        const style: Record<string, any> = {\n            \"position\": hasFixed ? \"fixed\" : \"absolute\",\n            \"display\": isDisplay ? \"block\" : \"none\",\n            \"visibility\": isVisible ? \"visible\" : \"hidden\",\n            \"transform\": `translate3d(${translate[0]}px, ${translate[1]}px, ${translateZ})`,\n            \"--zoom\": zoom,\n            \"--zoompx\": `${zoom}px`,\n        };\n        if (linePadding) {\n            style[\"--moveable-line-padding\"] = linePadding;\n        }\n        return (\n            <ControlBoxElement\n                cspNonce={cspNonce}\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\")} ${ableClassName} ${className}`}\n                {...ableAttributes}\n                onClick={this._onPreventClick}\n                portalContainer={portalContainer}\n                style={style}>\n                {this.renderAbles()}\n                {this._renderLines()}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.isMoveableMounted = true;\n        this.isUnmounted = false;\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container, wrapperMoveable } = props;\n\n\n        this._checkUpdateRootContainer();\n        this._checkUpdateViewContainer();\n        this._updateTargets();\n        this._updateNativeEvents();\n        this._updateEvents();\n        this.updateCheckInput();\n        this._updateObserver(this.props);\n\n        if (!container && !parentMoveable && !wrapperMoveable && !this.state.isPersisted) {\n            this.updateRect(\"\", false, false);\n            this.forceUpdate();\n        }\n    }\n    public componentDidUpdate(prevProps: any) {\n        this._checkUpdateRootContainer();\n        this._checkUpdateViewContainer();\n        this._updateNativeEvents();\n        this._updateEvents();\n        this._updateTargets();\n        this.updateCheckInput();\n        this._updateObserver(prevProps);\n    }\n    public componentWillUnmount() {\n        this.isMoveableMounted = false;\n        this.isUnmounted = true;\n        this._emitter.off();\n\n        const viewContainer = this._viewContainer;\n\n        if (viewContainer) {\n            this._changeAbleViewClassNames([]);\n        }\n        unset(this, \"targetGesto\");\n        unset(this, \"controlGesto\");\n\n        const events = this.events;\n        for (const name in events) {\n            const manager = events[name];\n            manager && manager.destroy();\n        }\n    }\n    public getTargets(): Array<HTMLElement | SVGElement> {\n        const target = this.props.target;\n        return target ? [target] : [];\n    }\n    /**\n     * Get the able used in MoveableManager.\n     * @method Moveable#getAble\n     * @param - able name\n     */\n    public getAble<T extends Able>(ableName: string): T | undefined {\n        const ables: Able[] = this.props.ables || [];\n\n        return find(ables, able => able.name === ableName) as T;\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, wrapperMoveable, container } = this.props;\n\n        return container!\n            || (wrapperMoveable && wrapperMoveable.getContainer())\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @method Moveable#isMoveableElement\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: Element) {\n        return target && (target.getAttribute?.(\"class\") || \"\").indexOf(PREFIX) > -1;\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @method Moveable#dragStart\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent) {\n        const targetGesto = this.targetGesto;\n        const controlGesto = this.controlGesto;\n\n        if (targetGesto && checkMoveableTarget(this)({ inputEvent: e })) {\n            if (!targetGesto.isFlag()) {\n                targetGesto.triggerDragStart(e);\n            }\n        } else if (controlGesto && this.isMoveableElement(e.target as Element)) {\n            if (!controlGesto.isFlag()) {\n                controlGesto.triggerDragStart(e);\n            }\n        }\n        return this;\n    }\n    /**\n     * Hit test an element or rect on a moveable target.\n     * (100% = 100)\n     * @method Moveable#hitTest\n     * @param - element or rect to test\n     * @return - Get hit test rate (rate > 0 is hitted)\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.hitTest(e.target) > 0) {\n     *          console.log(\"hiited\");\n     *     }\n     * });\n     */\n    public hitTest(el: Element | HitRect): number {\n        const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n        if (!target) {\n            return 0;\n        }\n        let rect: Required<HitRect>;\n\n        if (el instanceof Element) {\n            const clientRect = el.getBoundingClientRect();\n\n            rect = {\n                left: clientRect.left,\n                top: clientRect.top,\n                width: clientRect.width,\n                height: clientRect.height,\n            };\n        } else {\n            rect = { width: 0, height: 0, ...el };\n        }\n\n        const {\n            left: rectLeft,\n            top: rectTop,\n            width: rectWidth,\n            height: rectHeight,\n        } = rect;\n        const points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);\n        const size = getOverlapSize(points, [\n            [rectLeft, rectTop],\n            [rectLeft + rectWidth, rectTop],\n            [rectLeft + rectWidth, rectTop + rectHeight],\n            [rectLeft, rectTop + rectHeight],\n        ]);\n        const totalSize = getAreaSize(points);\n\n        if (!size || !totalSize) {\n            return 0;\n        }\n\n        return Math.min(100, size / totalSize * 100);\n    }\n    /**\n     * Whether the coordinates are inside Moveable\n     * @method Moveable#isInside\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number) {\n        const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        return isInside([clientX, clientY], fitPoints([pos1, pos2, pos4, pos3], targetClientRect));\n    }\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @method Moveable#updateRect\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const props = this.props;\n        const parentMoveable = props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        const rootContainer = parentMoveable\n            ? (parentMoveable as any)._rootContainer\n            : this._rootContainer;\n        const nextState = getMoveableTargetInfo(\n            this.controlBox && this.controlBox.getElement(),\n            target,\n            container,\n            container,\n            rootContainer || container,\n            this._getRequestStyles(),\n        );\n\n        if (!target && this._hasFirstTarget && props.persistData) {\n            const persistState = getPersistState(props.persistData);\n\n            for (const name in persistState) {\n                (nextState as any)[name] = (persistState as any)[name];\n            }\n        }\n        this.updateState(\n            nextState,\n            parentMoveable ? false : isSetState,\n        );\n    }\n    /**\n     * Check if the moveable state is being dragged.\n     * @method Moveable#isDragging\n     * @param - If you want to check if able is dragging, specify ableName.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // false\n     * console.log(moveable.isDragging());\n     *\n     * moveable.on(\"drag\", () => {\n     *   // true\n     *   console.log(moveable.isDragging());\n     * });\n     */\n    public isDragging(ableName?: string) {\n        const targetGesto = this.targetGesto;\n        const controlGesto = this.controlGesto;\n\n        if (targetGesto?.isFlag()) {\n            if (!ableName) {\n                return true;\n            }\n            const data = targetGesto.getEventData();\n\n            return !!data[ableName]?.isEventStart;\n        }\n        if (controlGesto?.isFlag()) {\n            if (!ableName) {\n                return true;\n            }\n            const data = controlGesto.getEventData();\n\n            return !!data[ableName]?.isEventStart;\n        }\n        return false;\n    }\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @method Moveable#updateTarget\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @method Moveable#getRect\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        const statePos = [state.left, state.top];\n        const origin = plus(statePos, state.origin);\n        const beforeOrigin = plus(statePos, state.beforeOrigin);\n        const transformOrigin = state.transformOrigin;\n\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n            beforeOrigin,\n            origin,\n            transformOrigin,\n            rotation: this.getRotation(),\n        };\n    }\n    /**\n     * Get a manager that manages the moveable's state and props.\n     * @method Moveable#getManager\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const manager = moveable.getManager(); // real moveable class instance\n     */\n    public getManager(): MoveableManagerInterface<any, any> {\n        return this as any;\n    }\n    /**\n     * You can stop the dragging currently in progress through a method from outside.\n     * @method Moveable#stopDrag\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.stopDrag();\n     */\n    public stopDrag(type?: \"target\" | \"control\"): void {\n        if (!type || type === \"target\") {\n            this.targetGesto?.stop();\n        }\n        if (!type || type === \"control\") {\n            this.controlGesto?.stop();\n        }\n    }\n    public getRotation() {\n        const {\n            pos1,\n            pos2,\n            direction,\n        } = this.state;\n\n        return getAbsoluteRotation(pos1, pos2, direction);\n    }\n    /**\n     * Request able through a method rather than an event.\n     * At the moment of execution, requestStart is executed,\n     * and then request and requestEnd can be executed through Requester.\n     * @method Moveable#request\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n     * @param - ableName\n     * @param - request to be able params.\n     * @param - If isInstant is true, request and requestEnd are executed immediately.\n     * @return - Able Requester. If there is no request in able, nothing will work.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     *\n     * // Start move\n     * const requester = moveable.request(\"draggable\");\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.requestEnd();\n     */\n    public request(ableName: string, param: IObject<any> = {}, isInstant?: boolean): Requester {\n        const { ables, groupable } = this.props as any;\n        const requsetAble: Able = ables!.filter((able: Able) => able.name === ableName)[0];\n\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\n            return {\n                request() {\n                    return this;\n                },\n                requestEnd() {\n                    return this;\n                },\n            };\n        }\n        const self = this;\n        const ableRequester = requsetAble.request(this);\n\n        const requestInstant = isInstant || param.isInstant;\n        const ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n        const eventAffix = `${(groupable ? \"Group\" : \"\")}${ableRequester.isControl ? \"Control\" : \"\"}`;\n\n        const requester = {\n            request(ableParam: IObject<any>) {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"\", {\n                    ...ableRequester.request(ableParam),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n            requestEnd() {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"End\", {\n                    ...ableRequester.requestEnd(),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n        };\n\n        triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", {\n            ...ableRequester.requestStart(param),\n            requestAble: ableName,\n            isRequest: true,\n        }, requestInstant);\n\n        return requestInstant ? requester.request(param).requestEnd() : requester;\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @method Moveable#destroy\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy(): void {\n        this.componentWillUnmount();\n    }\n    public updateRenderPoses() {\n        const state = this.getState();\n        const props = this.props;\n        const {\n            originalBeforeOrigin,\n            transformOrigin,\n            allMatrix, is3d,\n            pos1, pos2, pos3, pos4,\n            left: stateLeft,\n            top: stateTop,\n            // offsetWidth,\n            // offsetHeight,\n            isPersisted,\n        } = state;\n        const {\n            left = 0,\n            top = 0,\n            bottom = 0,\n            right = 0,\n        } = (props.padding || {}) as PaddingBox;\n        const n = is3d ? 4 : 3;\n\n        // const clipPathInfo = getClipPath(\n        //     props.target,\n        //     offsetWidth,\n        //     offsetHeight,\n        // );\n\n        // if (clipPathInfo) {\n        //     left -= Math.max(0, clipPathInfo.left);\n        //     top -= Math.max(0, clipPathInfo.top);\n        //     bottom -= Math.max(0, offsetHeight - clipPathInfo.bottom);\n        //     right -= Math.max(0, offsetWidth - clipPathInfo.right);\n        // }\n\n        let absoluteOrigin: number[] = [];\n\n        if (isPersisted) {\n            absoluteOrigin = transformOrigin;\n        } else if (this.controlBox && props.groupable) {\n            absoluteOrigin = originalBeforeOrigin;\n        } else {\n            absoluteOrigin = plus(originalBeforeOrigin, [stateLeft, stateTop]);\n        }\n\n        state.renderPoses = [\n            plus(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)),\n            plus(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n)),\n        ];\n    }\n    public checkUpdate() {\n        this._isPropTargetChanged = false;\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isTargetChanged = !equals(stateTarget, target);\n        const isChanged = isTargetChanged || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n        const moveableContainer = container || this.controlBox;\n\n        if (moveableContainer) {\n            this.unsetAbles();\n        }\n        this.updateState({ target, container });\n\n        if (!parentMoveable && moveableContainer) {\n            this.updateRect(\"End\", false, false);\n        }\n        this._isPropTargetChanged = isTargetChanged;\n    }\n    public waitToChangeTarget(): Promise<void> {\n        return new Promise(() => { });\n    }\n    public triggerEvent(name: string, e: any): any {\n        this._emitter.trigger(name, e);\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    public useCSS(tag: string, css: string) {\n        const customStyleMap = this.props.customStyledMap as Record<string, any>;\n\n        const key = tag + css;\n\n        if (!customStyleMap[key]) {\n            customStyleMap[key] = styled(tag, css);\n        }\n        return customStyleMap[key];\n    }\n    public checkUpdateRect = () => {\n        if (this.isDragging()) {\n            return;\n        }\n        const parentMoveable = this.props.parentMoveable;\n\n        if (parentMoveable) {\n            (parentMoveable as MoveableManager).checkUpdateRect();\n            return;\n        }\n        cancelAnimationFrame(this._observerId);\n        this._observerId = requestAnimationFrame(() => {\n            if (this.isDragging()) {\n                return;\n            }\n            this.updateRect();\n        });\n    }\n    public getState(): MoveableManagerState {\n        const props = this.props;\n        if (props.target || (props as any).targets?.length) {\n            this._hasFirstTarget = true;\n        }\n        const hasControlBox = this.controlBox;\n        const persistData = props.persistData;\n        const firstRenderState = props.firstRenderState;\n\n        if (firstRenderState && !hasControlBox) {\n            return firstRenderState;\n        }\n        if (!this._hasFirstTarget && persistData) {\n            const persistState = getPersistState(persistData);\n\n            if (persistState) {\n                this.updateState(persistState, false);\n                return this.state;\n            }\n        }\n        (this.state as any).isPersisted = false;\n        return this.state;\n    }\n    public updateSelectors() { }\n    protected unsetAbles() {\n        this.targetAbles.forEach(able => {\n            if (able.unset) {\n                able.unset(this);\n            }\n        });\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const enabledAbles = this.getEnabledAbles(ables);\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n\n        this.enabledAbles = enabledAbles;\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            if (this.isUnmounted) {\n                return;\n            }\n            this.setState(nextState);\n        } else {\n            const state = this.state;\n\n            for (const name in nextState) {\n                (state as any)[name] = nextState[name];\n            }\n        }\n    }\n    protected getEnabledAbles(ables: Able[] = this.props.ables!) {\n        const props = this.props as any;\n\n        return ables.filter(able => able && (\n            (able.always && props[able.name] !== false)\n            || props[able.name]));\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const Renderer = {\n            createElement,\n        };\n\n        this.renderState = {};\n\n        return groupByMap(flat<any>(\n            filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(({ render }) => {\n                return render!(this, Renderer) || [];\n            })).filter(el => el), ({ key }) => key).map(group => group[0]);\n    }\n    protected updateCheckInput() {\n        this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n    }\n    protected _getRequestStyles() {\n        const styleNames = this.getEnabledAbles().reduce((names, able) => {\n            const ableStyleNames = (able.requestStyle?.() ?? []) as Array<keyof CSSStyleDeclaration>;\n\n            return [...names, ...ableStyleNames];\n        }, [] as Array<keyof CSSStyleDeclaration>);\n\n\n        return styleNames;\n    }\n    protected _updateObserver(prevProps: MoveableDefaultOptions) {\n        const props = this.props;\n        const target = props.target;\n\n        if (!window.ResizeObserver || !target || !props.useResizeObserver) {\n            this._observer?.disconnect();\n            return;\n        }\n\n        if (prevProps.target === target && this._observer) {\n            return;\n        }\n\n        const observer = new ResizeObserver(this.checkUpdateRect);\n\n        observer.observe(target!, {\n            box: \"border-box\",\n        });\n        this._observer = observer;\n\n        return;\n    }\n    protected _updateEvents() {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const isUnset = (!hasTargetAble && this.targetGesto)\n            || this._isTargetChanged(true);\n\n        if (isUnset) {\n            unset(this, \"targetGesto\");\n            this.updateState({ gesto: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlGesto\");\n        }\n\n        if (target && hasTargetAble && !this.targetGesto) {\n            this.targetGesto = getTargetAbleGesto(this, target!, \"\");\n        }\n        if (!this.controlGesto && hasControlAble) {\n            this.controlGesto = getAbleGesto(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n    }\n    protected _updateTargets() {\n        const props = this.props;\n\n        this._prevTarget = props.dragTarget || props.target;\n        this._prevDragArea = props.dragArea!;\n    }\n    private _renderLines() {\n        const props = this.props;\n        const {\n            zoom,\n            hideDefaultLines,\n            hideChildMoveableDefaultLines,\n            parentMoveable,\n        } = props as MoveableManagerProps<GroupableProps>;\n\n        if (hideDefaultLines || (parentMoveable && hideChildMoveableDefaultLines)) {\n            return [];\n        }\n        const renderPoses = this.getState().renderPoses;\n        const Renderer = {\n            createElement,\n        };\n\n        return [\n            [0, 1],\n            [1, 3],\n            [3, 2],\n            [2, 0],\n        ].map(([from, to], i) => {\n            return renderLine(Renderer, \"\", renderPoses[from], renderPoses[to], zoom!, `render-line-${i}`);\n        });\n    }\n    private _onPreventClick = (e: any) => {\n        e.stopPropagation();\n        e.preventDefault();\n        // removeEvent(window, \"click\", this._onPreventClick, true);\n    }\n    private _isTargetChanged(useDragArea?: boolean) {\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const prevTarget = this._prevTarget;\n        const prevDragArea = this._prevDragArea;\n        const dragArea = props.dragArea;\n\n        // check target without dragArea\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;\n\n        return isTargetChanged || isDragAreaChanged;\n    }\n    private _updateNativeEvents() {\n        const props = this.props;\n        const target = props.dragArea ? this.areaElement : this.state.target;\n        const events = this.events;\n        const eventKeys = getKeys(events);\n\n        if (this._isTargetChanged()) {\n            for (const eventName in events) {\n                const manager = events[eventName];\n                manager && manager.destroy();\n                events[eventName] = null;\n            }\n        }\n        if (!target) {\n            return;\n        }\n        const enabledAbles = this.enabledAbles;\n        eventKeys.forEach(eventName => {\n            const ables = filterAbles(enabledAbles, [eventName] as any);\n            const hasAbles = ables.length > 0;\n            let manager = events[eventName];\n\n            if (!hasAbles) {\n                if (manager) {\n                    manager.destroy();\n                    events[eventName] = null;\n                }\n                return;\n            }\n            if (!manager) {\n                manager = new EventManager(target, this, eventName);\n                events[eventName] = manager;\n            }\n            manager.setAbles(ables);\n        });\n    }\n    private _checkUpdateRootContainer() {\n        const rootContainer = this.props.rootContainer;\n\n        if (!this._rootContainer && rootContainer) {\n            this._rootContainer = getRefTarget(rootContainer, true);\n        }\n    }\n    private _checkUpdateViewContainer() {\n        const viewContainerOption = this.props.viewContainer;\n\n        if (!this._viewContainer && viewContainerOption) {\n            this._viewContainer = getRefTarget(viewContainerOption, true);\n        }\n        const viewContainer = this._viewContainer;\n\n        if (viewContainer) {\n            this._changeAbleViewClassNames([\n                ...this._getAbleViewClassNames(),\n                this.isDragging() ? VIEW_DRAGGING : \"\",\n            ]);\n        }\n    }\n    private _changeAbleViewClassNames(classNames: string[]) {\n        const viewContainer = this._viewContainer!;\n        const nextClassNames = groupBy(\n            classNames.filter(Boolean),\n            el => el,\n        ).map(([className]) => className);\n        const prevClassNames = this._viewClassNames;\n\n        const {\n            removed,\n            added,\n        } = diff(prevClassNames, nextClassNames);\n\n        removed.forEach(index => {\n            removeClass(viewContainer, prevClassNames[index]);\n        });\n        added.forEach(index => {\n            addClass(viewContainer, nextClassNames[index]);\n        });\n\n        this._viewClassNames = nextClassNames;\n\n    }\n    private _getAbleViewClassNames() {\n        return (this.getEnabledAbles().map(able => {\n            return (able.viewClassName?.(this) || \"\");\n        }).join(\" \") + ` ${this._getAbleClassName(\"-view\")}`).split(/\\s+/g);\n    }\n    private _getAbleClassName(classPrefix = \"\") {\n        const ables = this.getEnabledAbles();\n\n        const targetGesto = this.targetGesto;\n        const controlGesto = this.controlGesto;\n        const targetGestoData: Record<string, any> = targetGesto?.isFlag()\n            ? targetGesto.getEventData() : {};\n        const controlGestoData: Record<string, any> = controlGesto?.isFlag()\n            ? controlGesto.getEventData() : {};\n\n        return ables.map(able => {\n            const name = able.name;\n            let className = able.className?.(this) || \"\";\n\n            if (\n                targetGestoData[name]?.isEventStart\n                || controlGestoData[name]?.isEventStart\n            ) {\n                className += ` ${prefix(`${name}${classPrefix}-dragging`)}`;\n            }\n            return className.trim();\n        }).filter(Boolean).join(\" \");\n    }\n}\n\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Zooms in the elements of a moveable.\n * @name Moveable#zoom\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Whether the target size is detected and updated whenever it changes.\n * @name Moveable#useResizeObserver\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.useResizeObserver = true;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox.\n * @name Moveable#className\n * @default \"\"\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s)\n * @name Moveable#dragTarget\n * @default target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n","import { minus } from \"@scena/matrix\";\nimport { refs } from \"framework-utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderLine } from \"../renderDirections\";\nimport { Renderer, MoveableGroupInterface, GroupableProps } from \"../types\";\nimport { flat } from \"../utils\";\n\nexport default {\n    name: \"groupable\",\n    props: {\n        defaultGroupRotate: Number,\n        defaultGroupOrigin: String,\n        groupable: Boolean,\n        groupableProps: Object,\n        targetGroups: Object,\n        hideChildMoveableDefaultLines: Boolean,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableGroupInterface<GroupableProps>, React: Renderer): any[] {\n        const props = moveable.props;\n        let targets: Array<HTMLElement | SVGElement | undefined | null> = props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top, isPersisted } = moveable.getState();\n        const position = [left, top];\n        const zoom = props.zoom || 1;\n        const renderGroupRects = moveable.renderGroupRects;\n        let persistDatChildren = props.persistData?.children || [];\n\n        if (isPersisted) {\n            targets = persistDatChildren.map(() => null);\n        } else {\n            persistDatChildren = [];\n        }\n\n        return [\n            ...targets.map((target, i) => {\n                return <MoveableManager<GroupableProps>\n                    key={\"moveable\" + i}\n                    ref={refs(moveable, \"moveables\", i)}\n                    target={target}\n                    origin={false}\n                    cssStyled={props.cssStyled}\n                    customStyledMap={props.customStyledMap}\n                    useResizeObserver={props.useResizeObserver}\n                    hideChildMoveableDefaultLines={props.hideChildMoveableDefaultLines}\n                    parentMoveable={moveable}\n                    parentPosition={position}\n                    persistData={persistDatChildren[i]}\n                    zoom={zoom}\n                />;\n            }),\n            ...flat(renderGroupRects.map(({ pos1, pos2, pos3, pos4 }, i) => {\n                const poses = [pos1, pos2, pos3, pos4];\n\n                return [\n                    [0, 1],\n                    [1, 3],\n                    [3, 2],\n                    [2, 0],\n                ].map(([from, to], j) => {\n                    return renderLine(\n                        React,\n                        \"\",\n                        minus(poses[from], position),\n                        minus(poses[to], position),\n                        zoom,\n                        `group-rect-${i}-${j}`,\n                    );\n                });\n            })),\n        ];\n    },\n};\n","import {\n    MoveableManagerInterface, MoveableGroupInterface,\n    ClickableProps, OnClick, OnClickGroup,\n} from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { findIndex } from \"@daybrush/utils\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"clickable\", {\n    props: {\n        clickable: Boolean,\n    },\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    always: true,\n    dragRelation: \"weak\",\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    dragStart() {\n        return;\n    },\n    dragControlStart() {\n        return;\n    },\n    dragGroupStart(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        const target = moveable.props.target!;\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n        const isMoveableElement = moveable.isMoveableElement(inputTarget);\n        const containsElement = !isMoveableElement && moveable.controlBox.getElement().contains(inputTarget);\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            || containsElement\n            // External event duplicate target or dragAreaElement\n        ) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            isDouble: e.isDouble,\n            inputTarget,\n            isTarget: target === inputTarget,\n            moveableTarget: moveable.props.target!,\n            containsTarget,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<ClickableProps>, e: any) {\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            // External event duplicate target or dragAreaElement\n            || e.datas.inputTarget === inputTarget\n        ) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent(moveable, \"onClickGroup\", fillParams<OnClickGroup>(moveable, e, {\n            isDouble: e.isDouble,\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n            moveableTarget: targets[targetIndex],\n        }));\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.dragEnd(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.dragEnd(moveable, e);\n    },\n});\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n","import { hasClass } from \"@daybrush/utils\";\nimport { DraggableProps, MoveableGroupInterface, MoveableManagerInterface, Renderer } from \"../types\";\nimport { prefix } from \"../utils\";\nimport Draggable from \"./Draggable\";\nimport { makeAble } from \"./AbleManager\";\nimport { renderEdgeLines } from \"../renderDirections\";\n\nfunction getDraggableEvent(e: any) {\n    let datas = e.originalDatas.draggable;\n    if (!datas) {\n        e.originalDatas.draggable = {};\n        datas = e.originalDatas.draggable;\n    }\n    return { ...e, datas };\n}\nexport default makeAble(\"edgeDraggable\", {\n    css: [\n        `.edge.edgeDraggable.line {\n    cursor: move;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<DraggableProps>, React: Renderer) {\n        const props = moveable.props;\n        const edge = props.edgeDraggable!;\n\n        if (!edge) {\n            return [];\n        }\n        return renderEdgeLines(\n            React,\n            \"edgeDraggable\",\n            edge,\n            moveable.getState().renderPoses,\n            props.zoom!,\n        );\n    },\n    dragCondition(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        const props = moveable.props;\n        const target = e.inputEvent?.target;\n\n        if (!props.edgeDraggable || !target) {\n            return false;\n        }\n\n        return !props.draggable\n            && hasClass(target, prefix(\"direction\"))\n            && hasClass(target, prefix(\"edge\"))\n            && hasClass(target, prefix(\"edgeDraggable\"));\n    },\n    dragStart(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        return Draggable.dragStart(moveable, getDraggableEvent(e));\n    },\n    drag(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        return Draggable.drag(moveable, getDraggableEvent(e));\n    },\n    dragEnd(moveable: MoveableManagerInterface<DraggableProps, any>, e: any) {\n        return Draggable.dragEnd(moveable, getDraggableEvent(e));\n    },\n    dragGroupCondition(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        const props = moveable.props;\n        const target = e.inputEvent?.target;\n\n        if (!props.edgeDraggable || !target) {\n            return false;\n        }\n        return !props.draggable && hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"line\"));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\n    },\n    dragGroup(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        return Draggable.dragGroup(moveable, getDraggableEvent(e));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<DraggableProps, any>, e: any) {\n        return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\n    },\n    unset(moveable: any) {\n        return Draggable.unset(moveable);\n    },\n});\n\n/**\n * Whether to move by dragging the edge line (default: false)\n * @name Moveable.Draggable#edgeDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  draggable: true,\n *  edgeDraggable: false,\n * });\n *\n * moveable.edgeDraggable = true;\n */\n","export default {\n    name: \"individualGroupable\",\n    props: {\n        individualGroupable: Boolean,\n    } as const,\n    events: {} as const,\n} as const;\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\nimport Padding from \"./Padding\";\nimport Clippable from \"./Clippable\";\nimport OriginDraggable from \"./OriginDraggable\";\nimport Roundable from \"./Roundable\";\nimport { UnionToIntersection } from \"../types\";\nimport { invertObject } from \"../utils\";\nimport Groupable from \"./Groupable\";\nimport BeforeRenderable from \"./BeforeRenderable\";\nimport Renderable from \"./Renderable\";\nimport Clickable from \"./Clickable\";\nimport edgeDraggable from \"./edgeDraggable\";\nimport IndividualGroupable from \"./IndividualGroupable\";\n\nexport const MOVEABLE_ABLES = /*#__PURE__*/[\n    BeforeRenderable,\n    Default, Snappable, Pinchable, Draggable, edgeDraggable,\n    Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin,\n    OriginDraggable,\n    Clippable, Roundable, Groupable, IndividualGroupable,\n    Clickable,\n    DragArea,\n    Renderable,\n] as const;\n\nexport const MOVEABLE_EVENTS_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...(\"events\" in able ? able.events : {})};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"events\"]>;\nexport const MOVEABLE_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...able.props};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"props\"]>;\n\nexport const MOVEABLE_EVENTS_MAP = /*#__PURE__*/invertObject(MOVEABLE_EVENTS_PROPS_MAP);\nexport const MOVEABLE_EVENTS: string[] = /*#__PURE__*/Object.keys(MOVEABLE_EVENTS_MAP);\nexport const MOVEABLE_PROPS: string[] = /*#__PURE__*/Object.keys(MOVEABLE_PROPS_MAP);\n","export function solveConstantsDistance(\n    [a, b, c]: [number, number, number],\n    pos: number[],\n) {\n    return (a * pos[0] + b * pos[1] + c) / Math.sqrt(a * a + b * b);\n}\nexport function solveC(\n    [a, b]: [number, number],\n    pos: number[],\n) {\n    // ax + by + c = 0\n    // -ax -by;\n    return -a * pos[0] - b * pos[1];\n}\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, GroupRect, MoveableTargetGroupsType, RectInfo } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleGesto, getTargetAbleGesto } from \"./gesto/getAbleGesto\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport {\n    getAbsolutePosesByState, equals, unset, rotatePosesInfo,\n    convertTransformOriginArray,\n    isDeepArrayEquals,\n} from \"./utils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport { getIntersectionPointsByConstants, getMinMaxs } from \"overlap-area\";\nimport { find, isArray, throttle } from \"@daybrush/utils\";\nimport { getMoveableTargetInfo } from \"./utils/getMoveableTargetInfo\";\nimport { solveC, solveConstantsDistance } from \"./Snappable/utils\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\n\n\nfunction getGroupRect(parentPoses: number[][][], rotation: number): GroupRect {\n    let pos1 = [0, 0];\n    let pos2 = [0, 0];\n    let pos3 = [0, 0];\n    let pos4 = [0, 0];\n    let width = 0;\n    let height = 0;\n\n    if (!parentPoses.length) {\n        return {\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            minX: 0,\n            minY: 0,\n            maxX: 0,\n            maxY: 0,\n            width,\n            height,\n            rotation,\n        };\n    }\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = fixedRotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        // ax = y  // -ax + y = 0 // 0 => 1\n        // -ax = y // ax + y = 0  // 0 => 3\n        const a1MinMax = [MAX_NUM, MIN_NUM];\n        const a1MinMaxPos = [[0, 0], [0, 0]];\n        const a2MinMax = [MAX_NUM, MIN_NUM];\n        const a2MinMaxPos = [[0, 0], [0, 0]];\n\n        parentPoses.forEach(poses => {\n            poses.forEach(pos => {\n\n                // const b1 = pos[1] - a1 * pos[0];\n                // const b2 = pos[1] - a2 * pos[0];\n\n                const a1Dist = solveConstantsDistance([-a1, 1, 0], pos);\n                const a2Dist = solveConstantsDistance([-a2, 1, 0], pos);\n\n                if (a1MinMax[0] > a1Dist) {\n                    a1MinMaxPos[0] = pos;\n                    a1MinMax[0] = a1Dist;\n                }\n                if (a1MinMax[1] < a1Dist) {\n                    a1MinMaxPos[1] = pos;\n                    a1MinMax[1] = a1Dist;\n                }\n                if (a2MinMax[0] > a2Dist) {\n                    a2MinMaxPos[0] = pos;\n                    a2MinMax[0] = a2Dist;\n                }\n                if (a2MinMax[1] < a2Dist) {\n                    a2MinMaxPos[1] = pos;\n                    a2MinMax[1] = a2Dist;\n                }\n            });\n        });\n\n        const [a1MinPos, a1MaxPos] = a1MinMaxPos;\n        const [a2MinPos, a2MaxPos] = a2MinMaxPos;\n\n        const minHorizontalLine = [-a1, 1, solveC([-a1, 1], a1MinPos)];\n        const maxHorizontalLine = [-a1, 1, solveC([-a1, 1], a1MaxPos)];\n\n        const minVerticalLine = [-a2, 1, solveC([-a2, 1], a2MinPos)];\n        const maxVerticalLine = [-a2, 1, solveC([-a2, 1], a2MaxPos)];\n\n        [pos1, pos2, pos3, pos4] = [\n            [minHorizontalLine, minVerticalLine],\n            [minHorizontalLine, maxVerticalLine],\n            [maxHorizontalLine, minVerticalLine],\n            [maxHorizontalLine, maxVerticalLine],\n        ].map(([line1, line2]) => getIntersectionPointsByConstants(line1, line2)[0]);\n\n        width = a2MinMax[1] - a2MinMax[0];\n        height = a1MinMax[1] - a1MinMax[0];\n    } else {\n        const minX = getMinPos(parentPoses, 0);\n        const minY = getMinPos(parentPoses, 1);\n        const maxX = getMaxPos(parentPoses, 0);\n        const maxY = getMaxPos(parentPoses, 1);\n\n        pos1 = [minX, minY];\n        pos2 = [maxX, minY];\n        pos3 = [minX, maxY];\n        pos4 = [maxX, maxY];\n        width = maxX - minX;\n        height = maxY - minY;\n        if (fixedRotation % 180) {\n            // 0\n            // 1 2\n            // 3 4\n            // 90\n            // 3 1\n            // 4 2\n            // 180\n            // 4 3\n            // 2 1\n            // 270\n            // 2 4\n            // 1 3\n            // 1, 2, 3,4 = 3 1 4 2\n            const changedX = [pos3, pos1, pos4, pos2];\n\n            [pos1, pos2, pos3, pos4] = changedX;\n            width = maxY - minY;\n            height = maxX - minX;\n        }\n\n    }\n    if (fixedRotation % 360 > 180) {\n        // 1 2   4 3\n        // 3 4   2 1\n        const changedX = [pos4, pos3, pos2, pos1];\n\n        [pos1, pos2, pos3, pos4] = changedX;\n    }\n    const { minX, minY, maxX, maxY } = getMinMaxs([pos1, pos2, pos3, pos4]);\n\n    return {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n        width,\n        height,\n        minX,\n        minY,\n        maxX,\n        maxY,\n        rotation,\n    };\n}\ntype SelfGroup = Array<MoveableManager | null | SelfGroup>;\ntype CheckedMoveableManager = { finded: boolean; manager: MoveableManager };\n\nfunction findMoveableGroups(\n    moveables: CheckedMoveableManager[],\n    childTargetGroups: MoveableTargetGroupsType,\n): SelfGroup {\n    const groups = childTargetGroups.map(targetGroup => {\n        if (isArray(targetGroup)) {\n            const childMoveableGroups = findMoveableGroups(moveables, targetGroup);\n            const length = childMoveableGroups.length;\n\n            if (length > 1) {\n                return childMoveableGroups;\n            } else if (length === 1) {\n                return childMoveableGroups[0];\n            } else {\n                return null;\n            }\n        } else {\n            const checked = find(moveables, ({ manager }) => manager.props.target === targetGroup)!;\n\n            if (checked) {\n                checked.finded = true;\n                return checked.manager;\n            }\n            return null;\n        }\n    }).filter(Boolean);\n\n    if (groups.length === 1 && isArray(groups[0])) {\n        return groups[0];\n    }\n    return groups;\n}\n\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\nclass MoveableGroup extends MoveableManager<GroupableProps> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n        defaultGroupOrigin: \"50% 50%\",\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public transformOrigin = \"50% 50%\";\n    public renderGroupRects: GroupRect[] = [];\n    private _targetGroups: MoveableTargetGroupsType = [];\n    private _hasFirstTargets = false;\n\n    public componentDidMount() {\n        super.componentDidMount();\n    }\n    public checkUpdate() {\n        this._isPropTargetChanged = false;\n        this.updateAbles();\n    }\n    public getTargets() {\n        return this.props.targets!;\n    }\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState = true) {\n        const state = this.state;\n\n        if (!this.controlBox || state.isPersisted) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const props = this.props;\n        const moveables = this.moveables;\n        const target = state.target! || props.target!;\n        const checkeds = moveables.map(moveable => ({ finded: false, manager: moveable }));\n        const targetGroups = this.props.targetGroups || [];\n        const moveableGroups = findMoveableGroups(\n            checkeds,\n            targetGroups,\n        );\n\n        moveableGroups.push(...checkeds.filter(({ finded }) => !finded).map(({ manager }) => manager));\n\n        const renderGroupRects: GroupRect[] = [];\n        const isReset = !isTarget || (type !== \"\" && props.updateGroup);\n        let defaultGroupRotate = props.defaultGroupRotate || 0;\n\n        if (!this._hasFirstTargets) {\n            const persistedRoatation = this.props.persistData?.rotation;\n\n            if (persistedRoatation != null) {\n                defaultGroupRotate = persistedRoatation;\n            }\n        }\n\n        function getMoveableGroupRect(group: SelfGroup, parentRotation: number, isRoot?: boolean): GroupRect {\n            const posesRotations = group.map(moveable => {\n                if (isArray(moveable)) {\n                    const rect = getMoveableGroupRect(moveable, parentRotation);\n                    const poses = [rect.pos1, rect.pos2, rect.pos3, rect.pos4];\n\n                    renderGroupRects.push(rect);\n                    return { poses, rotation: rect.rotation };\n                } else {\n                    return {\n                        poses: getAbsolutePosesByState(moveable!.state),\n                        rotation: moveable!.getRotation(),\n                    };\n                }\n            });\n            const rotations = posesRotations.map(({ rotation }) => rotation);\n\n            let groupRotation = 0;\n            const firstRotation = rotations[0];\n            const isSameRotation = rotations.every(nextRotation => {\n                return Math.abs(firstRotation - nextRotation) < 0.1;\n            });\n\n            if (isReset) {\n                groupRotation = isSameRotation ? firstRotation : defaultGroupRotate;\n            } else {\n                groupRotation = !isRoot && isSameRotation ? firstRotation : parentRotation;\n            }\n            const groupPoses = posesRotations.map(({ poses }) => poses);\n            const groupRect = getGroupRect(\n                groupPoses,\n                groupRotation,\n            );\n\n            return groupRect;\n        }\n        const rootGroupRect = getMoveableGroupRect(moveableGroups, this.rotation, true);\n\n        if (isReset) {\n            // reset rotataion\n            this.rotation = rootGroupRect.rotation;\n            this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n            this.scale = [1, 1];\n        }\n\n\n        this._targetGroups = targetGroups;\n        this.renderGroupRects = renderGroupRects;\n        const transformOrigin = this.transformOrigin;\n        const rotation = this.rotation;\n        const scale = this.scale;\n        const { width, height, minX, minY } = rootGroupRect;\n        const posesInfo = rotatePosesInfo(\n            [\n                [0, 0],\n                [width, 0],\n                [0, height],\n                [width, height],\n            ],\n            convertTransformOriginArray(transformOrigin, width, height),\n            this.rotation / 180 * Math.PI,\n        );\n\n        const { minX: deltaX, minY: deltaY } = getMinMaxs(posesInfo.result);\n        const rotateScale = ` rotate(${rotation}deg)`\n            + ` scale(${scale[0] >= 0 ? 1 : -1}, ${scale[1] >= 0 ? 1 : -1})`;\n        const transform = `translate(${-deltaX}px, ${-deltaY}px)${rotateScale}`;\n\n        this.controlBox.getElement().style.transform\n            = `translate3d(${minX}px, ${minY}px, ${this.props.translateZ || 0})`;\n\n        target.style.cssText += `left:0px;top:0px;`\n            + `transform-origin:${transformOrigin};`\n            + `width:${width}px;height:${height}px;`\n            + `transform: ${transform}`;\n        state.width = width;\n        state.height = height;\n\n        const container = this.getContainer();\n        const info = getMoveableTargetInfo(\n            this.controlBox.getElement(),\n            target,\n            this.controlBox.getElement(),\n            this.getContainer(),\n            this._rootContainer || container,\n            [],\n        );\n        const pos = [info.left!, info.top!];\n        const [\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        ] = getAbsolutePosesByState(info); // info.left + info.pos(1 ~ 4)\n\n        const minPos = getMinMaxs([pos1, pos2, pos3, pos4]);\n        const delta = [minPos.minX, minPos.minY];\n        const direction = scale[0] * scale[1] > 0 ? 1 : -1;\n\n        info.pos1 = minus(pos1, delta);\n        info.pos2 = minus(pos2, delta);\n        info.pos3 = minus(pos3, delta);\n        info.pos4 = minus(pos4, delta);\n        // info.left = info.left + delta[0];\n        // info.top = info.top + delta[1];\n        info.left = minX - info.left! + delta[0];\n        info.top = minY - info.top! + delta[1];\n        info.origin = minus(plus(pos, info.origin!), delta);\n        info.beforeOrigin = minus(plus(pos, info.beforeOrigin!), delta);\n        info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin!);\n        info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);\n        target.style.transform\n            = `translate(${-deltaX - delta[0]}px, ${-deltaY - delta[1]}px)`\n            + rotateScale;\n        this.updateState(\n            {\n                ...info,\n                posDelta: delta,\n                direction,\n                beforeDirection: direction,\n            },\n            isSetState,\n        );\n    }\n    public getRect(): RectInfo {\n        return {\n            ...super.getRect(),\n            children: this.moveables.map(child => child.getRect()),\n        };\n    }\n    public triggerEvent(name: string, e: any, isManager?: boolean): any {\n        if (isManager || name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        } else {\n            this._emitter.trigger(name, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n    protected _updateTargets() {\n        super._updateTargets();\n        this._prevTarget = this.props.dragTarget || this.areaElement;\n    }\n    protected _updateEvents() {\n        const state = this.state;\n        const props = this.props;\n\n        const prevTarget = this._prevTarget;\n        const nextTarget = props.dragTarget || this.areaElement;\n\n        if (prevTarget !== nextTarget) {\n            unset(this, \"targetGesto\");\n            unset(this, \"controlGesto\");\n            state.target = null;\n        }\n        if (!state.target) {\n            state.target = this.areaElement;\n            this.controlBox.getElement().style.display = \"block\";\n        }\n        if (state.target) {\n            if (!this.targetGesto) {\n                this.targetGesto = getTargetAbleGesto(this, nextTarget, \"Group\");\n            }\n            if (!this.controlGesto) {\n                this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n            }\n        }\n        const isContainerChanged = !equals(state.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const targets = props.targets!;\n        const { added, changed, removed } = this.differ.update(targets);\n        const isTargetChanged = added.length || removed.length;\n\n        if (\n            isContainerChanged\n            || isTargetChanged\n            || this.transformOrigin !== (props.defaultGroupOrigin || \"50% 50%\")\n            || changed.length\n            || targets.length && !isDeepArrayEquals(this._targetGroups, props.targetGroups || [])\n        ) {\n            this.updateRect();\n            this._hasFirstTargets = true;\n        }\n        this._isPropTargetChanged = !!isTargetChanged;\n    }\n    protected _updateObserver() { }\n}\n\n/**\n * Sets the initial rotation of the group.\n * @name Moveable.Group#defaultGroupRotate\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Sets the initial origin of the group.\n * @name Moveable.Group#defaultGroupOrigin\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupOrigin: \"50% 50%\",\n * });\n *\n * moveable.defaultGroupOrigin = \"20% 40%\";\n */\n\n\n/**\n * Whether to hide the line in child moveable for group corresponding to the rect of the target.\n * @name Moveable.Group#hideChildMoveableDefaultLines\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   hideChildMoveableDefaultLines: false,\n * });\n *\n * moveable.hideChildMoveableDefaultLines = true;\n */\nexport default MoveableGroup;\n","import { ref, refs } from \"framework-utils\";\nimport * as React from \"react\";\nimport MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, RectInfo } from \"./types\";\nimport { prefix } from \"./utils\";\n\n/**\n * @namespace Moveable.IndividualGroup\n * @description Create targets individually, not as a group.Create targets individually, not as a group.\n */\nclass MoveableIndividualGroup extends MoveableManager<GroupableProps> {\n    public moveables: MoveableManager[] = [];\n    public render() {\n        const props = this.props;\n        const {\n            cspNonce,\n            cssStyled: ControlBoxElement,\n            persistData,\n        } = props;\n\n        let targets: Array<HTMLElement | SVGElement | null | undefined> = props.targets || [];\n        const length = targets.length;\n        const canPersist = this.isUnmounted || !length;\n        let persistDatChildren = persistData?.children ?? [];\n        if (canPersist && !length && persistDatChildren.length) {\n            targets = persistDatChildren.map(() => null);\n        } else if (!canPersist) {\n            persistDatChildren = [];\n        }\n\n        return <ControlBoxElement\n            cspNonce={cspNonce}\n            ref={ref(this, \"controlBox\")}\n            className={prefix(\"control-box\")}>\n            {targets!.map((target, i) => {\n                return <MoveableManager\n                    key={\"moveable\" + i}\n                    ref={refs(this, \"moveables\", i)}\n                    {...this.props}\n                    target={target}\n                    wrapperMoveable={this}\n                    isWrapperMounted={this.isMoveableMounted}\n                    persistData={persistDatChildren[i]}\n\n                />;\n            })}\n        </ControlBoxElement>;\n    }\n    public componentDidUpdate() {}\n    public getTargets() {\n        return this.props.targets!;\n    }\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, isTarget, isSetState);\n        });\n    }\n    public getRect(): RectInfo {\n        return {\n            ...super.getRect(),\n            children: this.moveables.map(child => child.getRect()),\n        };\n    }\n    public request() {\n        return {\n            request() {\n                return this;\n            },\n            requestEnd() {\n                return this;\n            },\n        };\n    }\n    public dragStart() {\n        return this;\n    }\n    public hitTest() {\n        return 0;\n    }\n    public isInside() {\n        return false;\n    }\n    public isDragging() {\n        return false;\n    }\n    public updateRenderPoses() { }\n    public checkUpdate() { }\n    public triggerEvent() { }\n    protected updateAbles() { }\n    protected _updateEvents() { }\n    protected _updateObserver() {}\n}\n\n/**\n * Create targets individually, not as a group.\n * @name Moveable.IndividualGroup#individualGroupable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   individualGroupable: true,\n * });\n */\nexport default MoveableIndividualGroup;\n","import * as React from \"react\";\nimport {\n    Able, MoveableInterface, GroupableProps, MoveableDefaultProps,\n    IndividualGroupableProps, MoveableManagerInterface, MoveableRefTargetsResultType,\n    MoveableTargetGroupsType, BeforeRenderableProps, RenderableProps, MoveableManagerState,\n} from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref, withMethods, prefixCSS } from \"framework-utils\";\nimport { find, getKeys, IObject, isArray, isString } from \"@daybrush/utils\";\nimport { MOVEABLE_METHODS, PREFIX, MOVEABLE_CSS } from \"./consts\";\nimport Default from \"./ables/Default\";\nimport Groupable from \"./ables/Groupable\";\nimport DragArea from \"./ables/DragArea\";\nimport styled from \"react-css-styled\";\nimport { getRefTargets } from \"./utils\";\nimport IndividualGroupable from \"./ables/IndividualGroupable\";\nimport MoveableIndividualGroup from \"./MoveableIndividualGroup\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\n\n\nfunction getElementTargets(\n    refTargets: MoveableRefTargetsResultType,\n    selectorMap: IObject<Array<HTMLElement | SVGElement>>,\n): Array<SVGElement | HTMLElement> {\n    const elementTargets: Array<SVGElement | HTMLElement> = [];\n\n    refTargets.forEach(target => {\n        if (!target) {\n            return;\n        }\n        if (isString(target)) {\n            if (selectorMap[target]) {\n                elementTargets.push(...selectorMap[target]);\n            }\n            return;\n        }\n        if (isArray(target)) {\n            elementTargets.push(...getElementTargets(target, selectorMap));\n        } else {\n            elementTargets.push(target);\n        }\n    });\n\n    return elementTargets;\n}\nfunction getTargetGroups(\n    refTargets: MoveableRefTargetsResultType,\n    selectorMap: IObject<Array<HTMLElement | SVGElement>>,\n) {\n    const targetGroups: MoveableTargetGroupsType = [];\n\n    refTargets.forEach(target => {\n        if (!target) {\n            return;\n        }\n        if (isString(target)) {\n            if (selectorMap[target]) {\n                targetGroups.push(...selectorMap[target]);\n            }\n            return;\n        }\n        if (isArray(target)) {\n            targetGroups.push(getTargetGroups(target, selectorMap));\n        } else {\n            targetGroups.push(target);\n        }\n    });\n\n    return targetGroups;\n}\nfunction compareRefTargets(\n    prevRefTargets: MoveableRefTargetsResultType,\n    nextRefTargets: MoveableRefTargetsResultType,\n): boolean {\n    return (prevRefTargets.length !== nextRefTargets.length) || prevRefTargets.some((target, i) => {\n        const nextTarget = nextRefTargets[i];\n\n        if (!target && !nextTarget) {\n            return false;\n        } else if (target != nextTarget) {\n            if (isArray(target) && isArray(nextTarget)) {\n                return compareRefTargets(target, nextTarget);\n            }\n            return true;\n        }\n        return false;\n    });\n}\n\ntype DefaultAbles = GroupableProps & IndividualGroupableProps & BeforeRenderableProps & RenderableProps;\n\nexport class InitialMoveable<T = {}>\n    extends React.PureComponent<MoveableDefaultProps & DefaultAbles & T> {\n    public static defaultAbles: Able[] = [];\n    public static customStyledMap: Record<string, any> = {};\n    public static defaultStyled: any = null;\n    public static makeStyled() {\n        const cssMap: IObject<boolean> = {};\n\n        const ables = this.getTotalAbles();\n        ables.forEach(({ css }: Able) => {\n            if (!css) {\n                return;\n            }\n            css.forEach(text => {\n                cssMap[text] = true;\n            });\n        });\n        const style = getKeys(cssMap).join(\"\\n\");\n\n        this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + style));\n    }\n    public static getTotalAbles(): Able[] {\n\n        return [Default, Groupable, IndividualGroupable, DragArea, ...this.defaultAbles];\n    }\n    @withMethods(MOVEABLE_METHODS)\n    public moveable!: MoveableManager | MoveableGroup | MoveableIndividualGroup;\n    public refTargets: MoveableRefTargetsResultType = [];\n    public selectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n    private _differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    private _elementTargets: Array<HTMLElement | SVGElement> = [];\n    private _onChangeTargets: (() => void) | null = null;\n    public render() {\n        const moveableContructor = (this.constructor as typeof InitialMoveable);\n\n        if (!moveableContructor.defaultStyled) {\n            moveableContructor.makeStyled();\n        }\n        const {\n            ables: userAbles,\n            props: userProps,\n            ...props\n        } = this.props;\n        const refTargets = this._updateRefs(true);\n        const elementTargets = getElementTargets(refTargets, this.selectorMap);\n\n        let isGroup = elementTargets.length > 1;\n        const totalAbles = moveableContructor.getTotalAbles();\n        const ables = [\n            ...totalAbles,\n            ...(userAbles as any || []),\n        ];\n        const nextProps = {\n            ...props,\n            ...(userProps || {}),\n            ables,\n            cssStyled: moveableContructor.defaultStyled,\n            customStyledMap: moveableContructor.customStyledMap,\n        };\n\n        this._elementTargets = elementTargets;\n\n        let firstRenderState: MoveableManagerState | null = null;\n        const prevMoveable = this.moveable;\n\n\n        const persistData = props.persistData;\n\n        if (persistData?.children) {\n            isGroup = true;\n        }\n        if (isGroup) {\n            if (props.individualGroupable) {\n                return <MoveableIndividualGroup key=\"individual-group\" ref={ref(this, \"moveable\")}\n                    {...nextProps}\n                    target={null}\n                    targets={elementTargets}\n                />;\n            }\n            const targetGroups = getTargetGroups(refTargets, this.selectorMap);\n\n            // manager\n            if (prevMoveable && !prevMoveable.props.groupable && !(prevMoveable.props as any).individualGroupable) {\n                const target = prevMoveable.props.target!;\n\n                if (target && elementTargets.indexOf(target) > -1) {\n                    firstRenderState = { ...prevMoveable.state };\n                }\n            }\n\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps}\n                {...props.groupableProps ?? {}}\n                target={null}\n                targets={elementTargets}\n                targetGroups={targetGroups}\n                firstRenderState={firstRenderState}\n            />;\n        } else {\n            const target = elementTargets[0];\n            // manager\n            if (prevMoveable && (prevMoveable.props.groupable || (prevMoveable.props as any).individualGroupable)) {\n                const moveables = (prevMoveable as MoveableGroup | MoveableIndividualGroup).moveables || [];\n                const prevTargetMoveable = find(moveables, mv => mv.props.target === target);\n\n                if (prevTargetMoveable) {\n                    firstRenderState = { ...prevTargetMoveable.state };\n                }\n            }\n\n            return <MoveableManager<any> key=\"single\" ref={ref(this, \"moveable\")}\n                {...nextProps}\n                target={target}\n                firstRenderState={firstRenderState} />;\n        }\n    }\n    public componentDidMount() {\n        this._checkChangeTargets();\n        this._updateRefs();\n    }\n    public componentDidUpdate() {\n        this._checkChangeTargets();\n    }\n    public componentWillUnmount() {\n        this.selectorMap = {};\n        this.refTargets = [];\n    }\n    /**\n     * Get targets set in moveable through target or targets of props.\n     * @method Moveable#getTargets\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body, {\n     *    target: [targetRef, \".target\", document.querySelectorAll(\".target\")],\n     * });\n     *\n     * console.log(moveable.getTargets());\n     */\n    public getTargets() {\n        return this.moveable?.getTargets() ?? [];\n    }\n    /**\n     * If the element list corresponding to the selector among the targets is changed, it is updated.\n     * @method Moveable#updateSelectors\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body, {\n     *    target: \".target\",\n     * });\n     *\n     * moveable.updateSelectors();\n     */\n    public updateSelectors() {\n        this.selectorMap = {};\n        this._updateRefs();\n    }\n    /**\n     * User changes target and waits for target to change.\n     * @method Moveable#waitToChangeTarget\n     * @story combination-with-other-components--use-selecto\n     * @example\n     * document.querySelector(\".target\").addEventListener(\"mousedown\", e => {\n     *   moveable.waitToChangeTarget().then(() => {\n     *      moveable.dragStart(e.currentTarget);\n     *   });\n     *   moveable.target = e.currentTarget;\n     * });\n     */\n    public waitToChangeTarget(): Promise<void> {\n        // let resolvePromise: (e: OnChangeTarget) => void;\n\n        // this._onChangeTargets = () => {\n        //     this._onChangeTargets = null;\n        //     resolvePromise({\n        //         moveable: this.getManager(),\n        //         targets: this._elementTargets,\n        //     });\n        // };\n\n        // return new Promise<OnChangeTarget>(resolve => {\n        //     resolvePromise = resolve;\n        // });\n        let resolvePromise: () => void;\n\n        this._onChangeTargets = () => {\n            this._onChangeTargets = null;\n            resolvePromise();\n        };\n\n        return new Promise(resolve => {\n            resolvePromise = resolve;\n        });\n    }\n    public waitToChangeTargets(): Promise<void> {\n        return this.waitToChangeTarget();\n    }\n    public getManager(): MoveableManagerInterface<any, any> {\n        return this.moveable;\n    }\n    private _updateRefs(isRender?: boolean) {\n        const prevRefTargets = this.refTargets;\n        const nextRefTargets = getRefTargets((this.props.target || this.props.targets) as any);\n        const isBrowser = typeof document !== \"undefined\";\n\n        let isUpdate = compareRefTargets(prevRefTargets, nextRefTargets);\n        const selectorMap = this.selectorMap;\n        const nextSelectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n\n        this.refTargets.forEach(function updateSelectorMap(target) {\n            if (isString(target)) {\n                const selectorTarget = selectorMap[target];\n\n                if (selectorTarget) {\n                    nextSelectorMap[target] = selectorMap[target];\n                } else if (isBrowser) {\n                    isUpdate = true;\n                    nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));\n                }\n            } else if (isArray(target)) {\n                target.forEach(updateSelectorMap);\n            }\n        });\n\n        this.refTargets = nextRefTargets;\n        this.selectorMap = nextSelectorMap;\n\n        if (!isRender && isUpdate) {\n            this.forceUpdate();\n        }\n        return nextRefTargets;\n    }\n    private _checkChangeTargets() {\n        const { added, removed } = this._differ.update(this._elementTargets);\n        const isTargetChanged = added.length || removed.length;\n\n        if (isTargetChanged) {\n            this.props.onChangeTargets?.({\n                moveable: this.moveable,\n                targets: this._elementTargets,\n            });\n            this._onChangeTargets?.();\n        }\n        this._updateRefs();\n\n    }\n}\nexport interface InitialMoveable<T = {}>\n    extends React.PureComponent<MoveableDefaultProps & DefaultAbles & T>,\n    MoveableInterface {\n    setState(state: any, callback?: () => any): any;\n    forceUpdate(callback?: () => any): any;\n}\n","import { MoveableProps, Able } from \"./types\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport { InitialMoveable } from \"./InitialMoveable\";\n\nexport default class Moveable<T = {}> extends InitialMoveable<MoveableProps & T> {\n    public static defaultAbles: Able[] = MOVEABLE_ABLES as any;\n}\n","\"use strict\";function _interopRequireDefault(o){return o&&o.__esModule?o:{default:o}}function _objectWithoutProperties(o,e){var r={};for(var t in o)e.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(o,t)&&(r[t]=o[t]);return r}function make(o,e){var r=e.distance,t=e.left,p=e.right,a=e.up,l=e.down,i=e.top,u=e.bottom,n=e.big,s=e.mirror,d=e.opposite,_=(r?r.toString():0)+((t?1:0)|(p?2:0)|(i||l?4:0)|(u||a?8:0)|(s?16:0)|(d?32:0)|(o?64:0)|(n?128:0));if(lookup.hasOwnProperty(_))return lookup[_];var f=t||p||a||l||i||u,y=void 0,b=void 0;if(f){if(!s!=!(o&&d)){var v=[p,t,u,i,l,a];t=v[0],p=v[1],i=v[2],u=v[3],a=v[4],l=v[5]}var c=r||(n?\"2000px\":\"100%\");y=t?\"-\"+c:p?c:\"0\",b=l||i?\"-\"+c:a||u?c:\"0\"}return lookup[_]=(0,_globals.animation)((o?\"to\":\"from\")+\" {opacity: 0;\"+(f?\" transform: translate3d(\"+y+\", \"+b+\", 0);\":\"\")+\"}\\n     \"+(o?\"from\":\"to\")+\" {opacity: 1;transform: none;} \"),lookup[_]}function Fade(){var o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:_globals.defaults,e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=o.children,t=(o.out,o.forever),p=o.timeout,a=o.duration,l=void 0===a?_globals.defaults.duration:a,i=o.delay,u=void 0===i?_globals.defaults.delay:i,n=o.count,s=void 0===n?_globals.defaults.count:n,d=_objectWithoutProperties(o,[\"children\",\"out\",\"forever\",\"timeout\",\"duration\",\"delay\",\"count\"]),_={make:make,duration:void 0===p?l:p,delay:u,forever:t,count:s,style:{animationFillMode:\"both\"},reverse:d.left};return e?(0,_wrap2.default)(d,_,_,r):_}Object.defineProperty(exports,\"__esModule\",{value:!0});var _propTypes=require(\"prop-types\"),_globals=require(\"./globals\"),_wrap=require(\"./wrap\"),_wrap2=_interopRequireDefault(_wrap),propTypes={out:_propTypes.bool,left:_propTypes.bool,right:_propTypes.bool,top:_propTypes.bool,bottom:_propTypes.bool,big:_propTypes.bool,mirror:_propTypes.bool,opposite:_propTypes.bool,duration:_propTypes.number,timeout:_propTypes.number,distance:_propTypes.string,delay:_propTypes.number,count:_propTypes.number,forever:_propTypes.bool},lookup={};Fade.propTypes=propTypes,exports.default=Fade,module.exports=exports.default;","var o;import t from\"react\";import{useIsoMorphicEffect as d}from'./use-iso-morphic-effect.js';import{useServerHandoffComplete as f}from'./use-server-handoff-complete.js';import{env as r}from'../utils/env.js';let I=(o=t.useId)!=null?o:function(){let n=f(),[e,u]=t.useState(n?()=>r.nextId():null);return d(()=>{e===null&&u(r.nextId())},[e]),e!=null?\"\"+e:void 0};export{I as useId};\n","var o=(r=>(r.Space=\" \",r.Enter=\"Enter\",r.Escape=\"Escape\",r.Backspace=\"Backspace\",r.Delete=\"Delete\",r.ArrowLeft=\"ArrowLeft\",r.ArrowUp=\"ArrowUp\",r.ArrowRight=\"ArrowRight\",r.ArrowDown=\"ArrowDown\",r.Home=\"Home\",r.End=\"End\",r.PageUp=\"PageUp\",r.PageDown=\"PageDown\",r.Tab=\"Tab\",r))(o||{});export{o as Keys};\n","function f(r){throw new Error(\"Unexpected object: \"+r)}var a=(e=>(e[e.First=0]=\"First\",e[e.Previous=1]=\"Previous\",e[e.Next=2]=\"Next\",e[e.Last=3]=\"Last\",e[e.Specific=4]=\"Specific\",e[e.Nothing=5]=\"Nothing\",e))(a||{});function x(r,n){let t=n.resolveItems();if(t.length<=0)return null;let l=n.resolveActiveIndex(),s=l!=null?l:-1,d=(()=>{switch(r.focus){case 0:return t.findIndex(e=>!n.resolveDisabled(e));case 1:{let e=t.slice().reverse().findIndex((i,c,u)=>s!==-1&&u.length-c-1>=s?!1:!n.resolveDisabled(i));return e===-1?e:t.length-1-e}case 2:return t.findIndex((e,i)=>i<=s?!1:!n.resolveDisabled(e));case 3:{let e=t.slice().reverse().findIndex(i=>!n.resolveDisabled(i));return e===-1?e:t.length-1-e}case 4:return t.findIndex(e=>n.resolveId(e)===r.id);case 5:return null;default:f(r)}})();return d===-1?l:d}export{a as Focus,x as calculateActiveIndex};\n","function r(n){let e=n.parentElement,l=null;for(;e&&!(e instanceof HTMLFieldSetElement);)e instanceof HTMLLegendElement&&(l=e),e=e.parentElement;let t=(e==null?void 0:e.getAttribute(\"disabled\"))===\"\";return t&&i(l)?!1:t}function i(n){if(!n)return!1;let e=n.previousElementSibling;for(;e!==null;){if(e instanceof HTMLLegendElement)return!1;e=e.previousElementSibling}return!0}export{r as isDisabledReactIssue7711};\n","import{env as n}from'./env.js';function e(r){return n.isServer?null:r instanceof Node?r.ownerDocument:r!=null&&r.hasOwnProperty(\"current\")&&r.current instanceof Node?r.current.ownerDocument:document}export{e as getOwnerDocument};\n","import{disposables as b}from'./disposables.js';import{match as M}from'./match.js';import{getOwnerDocument as m}from'./owner.js';let f=[\"[contentEditable=true]\",\"[tabindex]\",\"a[href]\",\"area[href]\",\"button:not([disabled])\",\"iframe\",\"input:not([disabled])\",\"select:not([disabled])\",\"textarea:not([disabled])\"].map(e=>`${e}:not([tabindex='-1'])`).join(\",\");var L=(r=>(r[r.First=1]=\"First\",r[r.Previous=2]=\"Previous\",r[r.Next=4]=\"Next\",r[r.Last=8]=\"Last\",r[r.WrapAround=16]=\"WrapAround\",r[r.NoScroll=32]=\"NoScroll\",r))(L||{}),N=(o=>(o[o.Error=0]=\"Error\",o[o.Overflow=1]=\"Overflow\",o[o.Success=2]=\"Success\",o[o.Underflow=3]=\"Underflow\",o))(N||{}),T=(n=>(n[n.Previous=-1]=\"Previous\",n[n.Next=1]=\"Next\",n))(T||{});function E(e=document.body){return e==null?[]:Array.from(e.querySelectorAll(f)).sort((t,n)=>Math.sign((t.tabIndex||Number.MAX_SAFE_INTEGER)-(n.tabIndex||Number.MAX_SAFE_INTEGER)))}var F=(n=>(n[n.Strict=0]=\"Strict\",n[n.Loose=1]=\"Loose\",n))(F||{});function h(e,t=0){var n;return e===((n=m(e))==null?void 0:n.body)?!1:M(t,{[0](){return e.matches(f)},[1](){let l=e;for(;l!==null;){if(l.matches(f))return!0;l=l.parentElement}return!1}})}function g(e){let t=m(e);b().nextFrame(()=>{t&&!h(t.activeElement,0)&&S(e)})}function S(e){e==null||e.focus({preventScroll:!0})}let H=[\"textarea\",\"input\"].join(\",\");function w(e){var t,n;return(n=(t=e==null?void 0:e.matches)==null?void 0:t.call(e,H))!=null?n:!1}function A(e,t=n=>n){return e.slice().sort((n,l)=>{let o=t(n),i=t(l);if(o===null||i===null)return 0;let r=o.compareDocumentPosition(i);return r&Node.DOCUMENT_POSITION_FOLLOWING?-1:r&Node.DOCUMENT_POSITION_PRECEDING?1:0})}function v(e,t){return I(E(),t,{relativeTo:e})}function I(e,t,{sorted:n=!0,relativeTo:l=null,skipElements:o=[]}={}){let i=Array.isArray(e)?e.length>0?e[0].ownerDocument:document:e.ownerDocument,r=Array.isArray(e)?n?A(e):e:E(e);o.length>0&&r.length>1&&(r=r.filter(s=>!o.includes(s))),l=l!=null?l:i.activeElement;let d=(()=>{if(t&5)return 1;if(t&10)return-1;throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\")})(),x=(()=>{if(t&1)return 0;if(t&2)return Math.max(0,r.indexOf(l))-1;if(t&4)return Math.max(0,r.indexOf(l))+1;if(t&8)return r.length-1;throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\")})(),p=t&32?{preventScroll:!0}:{},c=0,a=r.length,u;do{if(c>=a||c+a<=0)return 0;let s=x+c;if(t&16)s=(s+a)%a;else{if(s<0)return 3;if(s>=a)return 1}u=r[s],u==null||u.focus(p),c+=d}while(u!==i.activeElement);return t&6&&w(u)&&u.select(),u.hasAttribute(\"tabindex\")||u.setAttribute(\"tabindex\",\"0\"),2}export{L as Focus,N as FocusResult,F as FocusableMode,S as focusElement,v as focusFrom,I as focusIn,E as getFocusableElements,h as isFocusableElement,g as restoreFocusIfNecessary,A as sortByDomNode};\n","import{useEffect as m}from\"react\";import{useLatestValue as c}from'./use-latest-value.js';function d(e,r,n){let o=c(r);m(()=>{function t(u){o.current(u)}return document.addEventListener(e,t,n),()=>document.removeEventListener(e,t,n)},[e,n])}export{d as useDocumentEvent};\n","import{useEffect as d,useRef as s}from\"react\";import{FocusableMode as p,isFocusableElement as C}from'../utils/focus-management.js';import{useDocumentEvent as a}from'./use-document-event.js';function L(m,E,c=!0){let i=s(!1);d(()=>{requestAnimationFrame(()=>{i.current=c})},[c]);function f(e,o){if(!i.current||e.defaultPrevented)return;let l=function r(t){return typeof t==\"function\"?r(t()):Array.isArray(t)||t instanceof Set?t:[t]}(m),n=o(e);if(n!==null&&!!n.getRootNode().contains(n)){for(let r of l){if(r===null)continue;let t=r instanceof HTMLElement?r:r.current;if(t!=null&&t.contains(n)||e.composed&&e.composedPath().includes(t))return}return!C(n,p.Loose)&&n.tabIndex!==-1&&e.preventDefault(),E(e,n)}}let u=s(null);a(\"mousedown\",e=>{var o,l;i.current&&(u.current=((l=(o=e.composedPath)==null?void 0:o.call(e))==null?void 0:l[0])||e.target)},!0),a(\"click\",e=>{!u.current||(f(e,()=>u.current),u.current=null)},!0),a(\"blur\",e=>f(e,()=>window.document.activeElement instanceof HTMLIFrameElement?window.document.activeElement:null),!0)}export{L as useOutsideClick};\n","import{useState as o}from\"react\";import{useIsoMorphicEffect as r}from'./use-iso-morphic-effect.js';function i(t){var n;if(t.type)return t.type;let e=(n=t.as)!=null?n:\"button\";if(typeof e==\"string\"&&e.toLowerCase()===\"button\")return\"button\"}function s(t,e){let[n,u]=o(()=>i(t));return r(()=>{u(i(t))},[t.type,t.as]),r(()=>{n||!e.current||e.current instanceof HTMLButtonElement&&!e.current.hasAttribute(\"type\")&&u(\"button\")},[n,e]),n}export{s as useResolveButtonType};\n","import{useRef as o}from\"react\";function t(e){return[e.screenX,e.screenY]}function u(){let e=o([-1,-1]);return{wasMoved(r){let n=t(r);return e.current[0]===n[0]&&e.current[1]===n[1]?!1:(e.current=n,!0)},update(r){e.current=t(r)}}}export{u as useTrackedPointer};\n","import K,{Fragment as _,createContext as q,createRef as N,useContext as J,useEffect as z,useMemo as P,useReducer as X,useRef as H}from\"react\";import{match as j}from'../../utils/match.js';import{forwardRefWithAs as E,render as x,Features as Q}from'../../utils/render.js';import{disposables as L}from'../../utils/disposables.js';import{useDisposables as W}from'../../hooks/use-disposables.js';import{useIsoMorphicEffect as D}from'../../hooks/use-iso-morphic-effect.js';import{useSyncRefs as C}from'../../hooks/use-sync-refs.js';import{useId as k}from'../../hooks/use-id.js';import{Keys as m}from'../keyboard.js';import{Focus as I,calculateActiveIndex as Y}from'../../utils/calculate-active-index.js';import{isDisabledReactIssue7711 as Z}from'../../utils/bugs.js';import{isFocusableElement as ee,FocusableMode as te,sortByDomNode as ne,Focus as V,focusFrom as re,restoreFocusIfNecessary as $}from'../../utils/focus-management.js';import{useOutsideClick as oe}from'../../hooks/use-outside-click.js';import{useTreeWalker as ae}from'../../hooks/use-tree-walker.js';import{useOpenClosed as ie,State as w,OpenClosedProvider as ue}from'../../internal/open-closed.js';import{useResolveButtonType as se}from'../../hooks/use-resolve-button-type.js';import{useOwnerDocument as le}from'../../hooks/use-owner.js';import{useEvent as y}from'../../hooks/use-event.js';import{useTrackedPointer as ce}from'../../hooks/use-tracked-pointer.js';var pe=(o=>(o[o.Open=0]=\"Open\",o[o.Closed=1]=\"Closed\",o))(pe||{}),de=(o=>(o[o.Pointer=0]=\"Pointer\",o[o.Other=1]=\"Other\",o))(de||{}),me=(e=>(e[e.OpenMenu=0]=\"OpenMenu\",e[e.CloseMenu=1]=\"CloseMenu\",e[e.GoToItem=2]=\"GoToItem\",e[e.Search=3]=\"Search\",e[e.ClearSearch=4]=\"ClearSearch\",e[e.RegisterItem=5]=\"RegisterItem\",e[e.UnregisterItem=6]=\"UnregisterItem\",e))(me||{});function U(t,i=o=>o){let o=t.activeItemIndex!==null?t.items[t.activeItemIndex]:null,s=ne(i(t.items.slice()),u=>u.dataRef.current.domRef.current),a=o?s.indexOf(o):null;return a===-1&&(a=null),{items:s,activeItemIndex:a}}let fe={[1](t){return t.menuState===1?t:{...t,activeItemIndex:null,menuState:1}},[0](t){return t.menuState===0?t:{...t,menuState:0}},[2]:(t,i)=>{var a;let o=U(t),s=Y(i,{resolveItems:()=>o.items,resolveActiveIndex:()=>o.activeItemIndex,resolveId:u=>u.id,resolveDisabled:u=>u.dataRef.current.disabled});return{...t,...o,searchQuery:\"\",activeItemIndex:s,activationTrigger:(a=i.trigger)!=null?a:1}},[3]:(t,i)=>{let s=t.searchQuery!==\"\"?0:1,a=t.searchQuery+i.value.toLowerCase(),n=(t.activeItemIndex!==null?t.items.slice(t.activeItemIndex+s).concat(t.items.slice(0,t.activeItemIndex+s)):t.items).find(d=>{var l;return((l=d.dataRef.current.textValue)==null?void 0:l.startsWith(a))&&!d.dataRef.current.disabled}),e=n?t.items.indexOf(n):-1;return e===-1||e===t.activeItemIndex?{...t,searchQuery:a}:{...t,searchQuery:a,activeItemIndex:e,activationTrigger:1}},[4](t){return t.searchQuery===\"\"?t:{...t,searchQuery:\"\",searchActiveItemIndex:null}},[5]:(t,i)=>{let o=U(t,s=>[...s,{id:i.id,dataRef:i.dataRef}]);return{...t,...o}},[6]:(t,i)=>{let o=U(t,s=>{let a=s.findIndex(u=>u.id===i.id);return a!==-1&&s.splice(a,1),s});return{...t,...o,activationTrigger:1}}},G=q(null);G.displayName=\"MenuContext\";function O(t){let i=J(G);if(i===null){let o=new Error(`<${t} /> is missing a parent <Menu /> component.`);throw Error.captureStackTrace&&Error.captureStackTrace(o,O),o}return i}function Te(t,i){return j(i.type,fe,t,i)}let ye=_,Ie=E(function(i,o){let s=X(Te,{menuState:1,buttonRef:N(),itemsRef:N(),items:[],searchQuery:\"\",activeItemIndex:null,activationTrigger:1}),[{menuState:a,itemsRef:u,buttonRef:n},e]=s,d=C(o);oe([n,u],(R,A)=>{var g;e({type:1}),ee(A,te.Loose)||(R.preventDefault(),(g=n.current)==null||g.focus())},a===0);let l=y(()=>{e({type:1})}),f=P(()=>({open:a===0,close:l}),[a,l]),M=i,T={ref:d};return K.createElement(G.Provider,{value:s},K.createElement(ue,{value:j(a,{[0]:w.Open,[1]:w.Closed})},x({ourProps:T,theirProps:M,slot:f,defaultTag:ye,name:\"Menu\"})))}),ge=\"button\",Me=E(function(i,o){var g;let s=k(),{id:a=`headlessui-menu-button-${s}`,...u}=i,[n,e]=O(\"Menu.Button\"),d=C(n.buttonRef,o),l=W(),f=y(c=>{switch(c.key){case m.Space:case m.Enter:case m.ArrowDown:c.preventDefault(),c.stopPropagation(),e({type:0}),l.nextFrame(()=>e({type:2,focus:I.First}));break;case m.ArrowUp:c.preventDefault(),c.stopPropagation(),e({type:0}),l.nextFrame(()=>e({type:2,focus:I.Last}));break}}),M=y(c=>{switch(c.key){case m.Space:c.preventDefault();break}}),T=y(c=>{if(Z(c.currentTarget))return c.preventDefault();i.disabled||(n.menuState===0?(e({type:1}),l.nextFrame(()=>{var b;return(b=n.buttonRef.current)==null?void 0:b.focus({preventScroll:!0})})):(c.preventDefault(),e({type:0})))}),R=P(()=>({open:n.menuState===0}),[n]),A={ref:d,id:a,type:se(i,n.buttonRef),\"aria-haspopup\":\"menu\",\"aria-controls\":(g=n.itemsRef.current)==null?void 0:g.id,\"aria-expanded\":i.disabled?void 0:n.menuState===0,onKeyDown:f,onKeyUp:M,onClick:T};return x({ourProps:A,theirProps:u,slot:R,defaultTag:ge,name:\"Menu.Button\"})}),Re=\"div\",be=Q.RenderStrategy|Q.Static,Ae=E(function(i,o){var b,S;let s=k(),{id:a=`headlessui-menu-items-${s}`,...u}=i,[n,e]=O(\"Menu.Items\"),d=C(n.itemsRef,o),l=le(n.itemsRef),f=W(),M=ie(),T=(()=>M!==null?M===w.Open:n.menuState===0)();z(()=>{let r=n.itemsRef.current;!r||n.menuState===0&&r!==(l==null?void 0:l.activeElement)&&r.focus({preventScroll:!0})},[n.menuState,n.itemsRef,l]),ae({container:n.itemsRef.current,enabled:n.menuState===0,accept(r){return r.getAttribute(\"role\")===\"menuitem\"?NodeFilter.FILTER_REJECT:r.hasAttribute(\"role\")?NodeFilter.FILTER_SKIP:NodeFilter.FILTER_ACCEPT},walk(r){r.setAttribute(\"role\",\"none\")}});let R=y(r=>{var h,F;switch(f.dispose(),r.key){case m.Space:if(n.searchQuery!==\"\")return r.preventDefault(),r.stopPropagation(),e({type:3,value:r.key});case m.Enter:if(r.preventDefault(),r.stopPropagation(),e({type:1}),n.activeItemIndex!==null){let{dataRef:p}=n.items[n.activeItemIndex];(F=(h=p.current)==null?void 0:h.domRef.current)==null||F.click()}$(n.buttonRef.current);break;case m.ArrowDown:return r.preventDefault(),r.stopPropagation(),e({type:2,focus:I.Next});case m.ArrowUp:return r.preventDefault(),r.stopPropagation(),e({type:2,focus:I.Previous});case m.Home:case m.PageUp:return r.preventDefault(),r.stopPropagation(),e({type:2,focus:I.First});case m.End:case m.PageDown:return r.preventDefault(),r.stopPropagation(),e({type:2,focus:I.Last});case m.Escape:r.preventDefault(),r.stopPropagation(),e({type:1}),L().nextFrame(()=>{var p;return(p=n.buttonRef.current)==null?void 0:p.focus({preventScroll:!0})});break;case m.Tab:r.preventDefault(),r.stopPropagation(),e({type:1}),L().nextFrame(()=>{re(n.buttonRef.current,r.shiftKey?V.Previous:V.Next)});break;default:r.key.length===1&&(e({type:3,value:r.key}),f.setTimeout(()=>e({type:4}),350));break}}),A=y(r=>{switch(r.key){case m.Space:r.preventDefault();break}}),g=P(()=>({open:n.menuState===0}),[n]),c={\"aria-activedescendant\":n.activeItemIndex===null||(b=n.items[n.activeItemIndex])==null?void 0:b.id,\"aria-labelledby\":(S=n.buttonRef.current)==null?void 0:S.id,id:a,onKeyDown:R,onKeyUp:A,role:\"menu\",tabIndex:0,ref:d};return x({ourProps:c,theirProps:u,slot:g,defaultTag:Re,features:be,visible:T,name:\"Menu.Items\"})}),ve=_,Se=E(function(i,o){let s=k(),{id:a=`headlessui-menu-item-${s}`,disabled:u=!1,...n}=i,[e,d]=O(\"Menu.Item\"),l=e.activeItemIndex!==null?e.items[e.activeItemIndex].id===a:!1,f=H(null),M=C(o,f);D(()=>{if(e.menuState!==0||!l||e.activationTrigger===0)return;let p=L();return p.requestAnimationFrame(()=>{var v,B;(B=(v=f.current)==null?void 0:v.scrollIntoView)==null||B.call(v,{block:\"nearest\"})}),p.dispose},[f,l,e.menuState,e.activationTrigger,e.activeItemIndex]);let T=H({disabled:u,domRef:f});D(()=>{T.current.disabled=u},[T,u]),D(()=>{var p,v;T.current.textValue=(v=(p=f.current)==null?void 0:p.textContent)==null?void 0:v.toLowerCase()},[T,f]),D(()=>(d({type:5,id:a,dataRef:T}),()=>d({type:6,id:a})),[T,a]);let R=y(()=>{d({type:1})}),A=y(p=>{if(u)return p.preventDefault();d({type:1}),$(e.buttonRef.current)}),g=y(()=>{if(u)return d({type:2,focus:I.Nothing});d({type:2,focus:I.Specific,id:a})}),c=ce(),b=y(p=>c.update(p)),S=y(p=>{!c.wasMoved(p)||u||l||d({type:2,focus:I.Specific,id:a,trigger:0})}),r=y(p=>{!c.wasMoved(p)||u||!l||d({type:2,focus:I.Nothing})}),h=P(()=>({active:l,disabled:u,close:R}),[l,u,R]);return x({ourProps:{id:a,ref:M,role:\"menuitem\",tabIndex:u===!0?void 0:-1,\"aria-disabled\":u===!0?!0:void 0,disabled:void 0,onClick:A,onFocus:g,onPointerEnter:b,onMouseEnter:b,onPointerMove:S,onMouseMove:S,onPointerLeave:r,onMouseLeave:r},theirProps:n,slot:h,defaultTag:ve,name:\"Menu.Item\"})}),Ze=Object.assign(Ie,{Button:Me,Items:Ae,Item:Se});export{Ze as Menu};\n","import{useMemo as t}from\"react\";import{getOwnerDocument as o}from'../utils/owner.js';function n(...e){return t(()=>o(...e),[...e])}export{n as useOwnerDocument};\n","import{useRef as E,useEffect as m}from\"react\";import{useIsoMorphicEffect as T}from'./use-iso-morphic-effect.js';import{getOwnerDocument as N}from'../utils/owner.js';function F({container:e,accept:t,walk:r,enabled:c=!0}){let o=E(t),l=E(r);m(()=>{o.current=t,l.current=r},[t,r]),T(()=>{if(!e||!c)return;let n=N(e);if(!n)return;let f=o.current,p=l.current,d=Object.assign(i=>f(i),{acceptNode:f}),u=n.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,d,!1);for(;u.nextNode();)p(u.currentNode)},[e,c,o,l])}export{F as useTreeWalker};\n","import{useRef as r}from\"react\";import{useIsoMorphicEffect as t}from'./use-iso-morphic-effect.js';function f(){let e=r(!1);return t(()=>(e.current=!0,()=>{e.current=!1}),[]),e}export{f as useIsMounted};\n","import{once as T}from'../../../utils/once.js';import{disposables as s}from'../../../utils/disposables.js';import{match as p}from'../../../utils/match.js';function v(t,...e){t&&e.length>0&&t.classList.add(...e)}function f(t,...e){t&&e.length>0&&t.classList.remove(...e)}function F(t,e){let n=s();if(!t)return n.dispose;let{transitionDuration:a,transitionDelay:i}=getComputedStyle(t),[m,d]=[a,i].map(o=>{let[r=0]=o.split(\",\").filter(Boolean).map(l=>l.includes(\"ms\")?parseFloat(l):parseFloat(l)*1e3).sort((l,g)=>g-l);return r});if(m+d!==0){let o=n.addEventListener(t,\"transitionend\",r=>{r.target===r.currentTarget&&(e(),o())})}else e();return n.add(()=>e()),n.dispose}function M(t,e,n,a){let i=n?\"enter\":\"leave\",m=s(),d=a!==void 0?T(a):()=>{};i===\"enter\"&&(t.removeAttribute(\"hidden\"),t.style.display=\"\");let u=p(i,{enter:()=>e.enter,leave:()=>e.leave}),o=p(i,{enter:()=>e.enterTo,leave:()=>e.leaveTo}),r=p(i,{enter:()=>e.enterFrom,leave:()=>e.leaveFrom});return f(t,...e.enter,...e.enterTo,...e.enterFrom,...e.leave,...e.leaveFrom,...e.leaveTo,...e.entered),v(t,...u,...r),m.nextFrame(()=>{f(t,...r),v(t,...o),F(t,()=>(f(t,...u),v(t,...e.entered),d()))}),m.dispose}export{M as transition};\n","function l(r){let e={called:!1};return(...t)=>{if(!e.called)return e.called=!0,r(...t)}}export{l as once};\n","import{transition as d}from'../components/transitions/utils/transition.js';import{disposables as l}from'../utils/disposables.js';import{useDisposables as f}from'./use-disposables.js';import{useIsMounted as m}from'./use-is-mounted.js';import{useIsoMorphicEffect as p}from'./use-iso-morphic-effect.js';import{useLatestValue as b}from'./use-latest-value.js';function D({container:i,direction:t,classes:o,onStart:s,onStop:u}){let a=m(),c=f(),r=b(t);p(()=>{let e=l();c.add(e.dispose);let n=i.current;if(!!n&&r.current!==\"idle\"&&!!a.current)return e.dispose(),s.current(r.current),e.add(d(n,o.current,r.current===\"enter\",()=>{e.dispose(),u.current(r.current)})),e.dispose},[t])}export{D as useTransition};\n","import T,{Fragment as Q,createContext as X,useContext as W,useEffect as H,useMemo as Y,useRef as c,useState as q}from\"react\";import{Features as fe,forwardRefWithAs as z,render as Z,RenderStrategy as g}from'../../utils/render.js';import{OpenClosedProvider as Te,State as O,useOpenClosed as $}from'../../internal/open-closed.js';import{match as N}from'../../utils/match.js';import{useIsMounted as ce}from'../../hooks/use-is-mounted.js';import{useIsoMorphicEffect as me}from'../../hooks/use-iso-morphic-effect.js';import{useLatestValue as F}from'../../hooks/use-latest-value.js';import{useServerHandoffComplete as ee}from'../../hooks/use-server-handoff-complete.js';import{useSyncRefs as te}from'../../hooks/use-sync-refs.js';import{useTransition as pe}from'../../hooks/use-transition.js';import{useEvent as R}from'../../hooks/use-event.js';import{useDisposables as ve}from'../../hooks/use-disposables.js';import{classNames as he}from'../../utils/class-names.js';import{env as Ce}from'../../utils/env.js';function P(i=\"\"){return i.split(\" \").filter(e=>e.trim().length>1)}let A=X(null);A.displayName=\"TransitionContext\";var ge=(s=>(s.Visible=\"visible\",s.Hidden=\"hidden\",s))(ge||{});function be(){let i=W(A);if(i===null)throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");return i}function Ee(){let i=W(M);if(i===null)throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");return i}let M=X(null);M.displayName=\"NestingContext\";function I(i){return\"children\"in i?I(i.children):i.current.filter(({el:e})=>e.current!==null).filter(({state:e})=>e===\"visible\").length>0}function ne(i,e){let s=F(i),n=c([]),m=ce(),y=ve(),b=R((l,r=g.Hidden)=>{let t=n.current.findIndex(({el:o})=>o===l);t!==-1&&(N(r,{[g.Unmount](){n.current.splice(t,1)},[g.Hidden](){n.current[t].state=\"hidden\"}}),y.microTask(()=>{var o;!I(n)&&m.current&&((o=s.current)==null||o.call(s))}))}),E=R(l=>{let r=n.current.find(({el:t})=>t===l);return r?r.state!==\"visible\"&&(r.state=\"visible\"):n.current.push({el:l,state:\"visible\"}),()=>b(l,g.Unmount)}),S=c([]),u=c(Promise.resolve()),p=c({enter:[],leave:[],idle:[]}),d=R((l,r,t)=>{S.current.splice(0),e&&(e.chains.current[r]=e.chains.current[r].filter(([o])=>o!==l)),e==null||e.chains.current[r].push([l,new Promise(o=>{S.current.push(o)})]),e==null||e.chains.current[r].push([l,new Promise(o=>{Promise.all(p.current[r].map(([f,a])=>a)).then(()=>o())})]),r===\"enter\"?u.current=u.current.then(()=>e==null?void 0:e.wait.current).then(()=>t(r)):t(r)}),v=R((l,r,t)=>{Promise.all(p.current[r].splice(0).map(([o,f])=>f)).then(()=>{var o;(o=S.current.shift())==null||o()}).then(()=>t(r))});return Y(()=>({children:n,register:E,unregister:b,onStart:d,onStop:v,wait:u,chains:p}),[E,b,n,d,v,p,u])}function Se(){}let xe=[\"beforeEnter\",\"afterEnter\",\"beforeLeave\",\"afterLeave\"];function re(i){var s;let e={};for(let n of xe)e[n]=(s=i[n])!=null?s:Se;return e}function Pe(i){let e=c(re(i));return H(()=>{e.current=re(i)},[i]),e}let He=\"div\",ie=fe.RenderStrategy,oe=z(function(e,s){let{beforeEnter:n,afterEnter:m,beforeLeave:y,afterLeave:b,enter:E,enterFrom:S,enterTo:u,entered:p,leave:d,leaveFrom:v,leaveTo:l,...r}=e,t=c(null),o=te(t,s),f=r.unmount?g.Unmount:g.Hidden,{show:a,appear:x,initial:se}=be(),[h,_]=q(a?\"visible\":\"hidden\"),K=Ee(),{register:D,unregister:V}=K,j=c(null);H(()=>D(t),[D,t]),H(()=>{if(f===g.Hidden&&!!t.current){if(a&&h!==\"visible\"){_(\"visible\");return}return N(h,{[\"hidden\"]:()=>V(t),[\"visible\"]:()=>D(t)})}},[h,t,D,V,a,f]);let U=F({enter:P(E),enterFrom:P(S),enterTo:P(u),entered:P(p),leave:P(d),leaveFrom:P(v),leaveTo:P(l)}),L=Pe({beforeEnter:n,afterEnter:m,beforeLeave:y,afterLeave:b}),k=ee();H(()=>{if(k&&h===\"visible\"&&t.current===null)throw new Error(\"Did you forget to passthrough the `ref` to the actual DOM node?\")},[t,h,k]);let G=se&&!x,le=(()=>!k||G||j.current===a?\"idle\":a?\"enter\":\"leave\")(),ae=R(C=>N(C,{enter:()=>L.current.beforeEnter(),leave:()=>L.current.beforeLeave(),idle:()=>{}})),ue=R(C=>N(C,{enter:()=>L.current.afterEnter(),leave:()=>L.current.afterLeave(),idle:()=>{}})),w=ne(()=>{_(\"hidden\"),V(t)},K);pe({container:t,classes:U,direction:le,onStart:F(C=>{w.onStart(t,C,ae)}),onStop:F(C=>{w.onStop(t,C,ue),C===\"leave\"&&!I(w)&&(_(\"hidden\"),V(t))})}),H(()=>{!G||(f===g.Hidden?j.current=null:j.current=a)},[a,G,h]);let B=r,de={ref:o};return x&&a&&Ce.isServer&&(B={...B,className:he(r.className,...U.current.enter,...U.current.enterFrom)}),T.createElement(M.Provider,{value:w},T.createElement(Te,{value:N(h,{[\"visible\"]:O.Open,[\"hidden\"]:O.Closed})},Z({ourProps:de,theirProps:B,defaultTag:He,features:ie,visible:h===\"visible\",name:\"Transition.Child\"})))}),J=z(function(e,s){let{show:n,appear:m=!1,unmount:y,...b}=e,E=c(null),S=te(E,s);ee();let u=$();if(n===void 0&&u!==null&&(n=N(u,{[O.Open]:!0,[O.Closed]:!1})),![!0,!1].includes(n))throw new Error(\"A <Transition /> is used but it is missing a `show={true | false}` prop.\");let[p,d]=q(n?\"visible\":\"hidden\"),v=ne(()=>{d(\"hidden\")}),[l,r]=q(!0),t=c([n]);me(()=>{l!==!1&&t.current[t.current.length-1]!==n&&(t.current.push(n),r(!1))},[t,n]);let o=Y(()=>({show:n,appear:m,initial:l}),[n,m,l]);H(()=>{if(n)d(\"visible\");else if(!I(v))d(\"hidden\");else{let a=E.current;if(!a)return;let x=a.getBoundingClientRect();x.x===0&&x.y===0&&x.width===0&&x.height===0&&d(\"hidden\")}},[n,v]);let f={unmount:y};return T.createElement(M.Provider,{value:v},T.createElement(A.Provider,{value:o},Z({ourProps:{...f,as:Q,children:T.createElement(oe,{ref:S,...f,...b})},theirProps:{},defaultTag:Q,features:ie,visible:p===\"visible\",name:\"Transition\"})))}),Ne=z(function(e,s){let n=W(A)!==null,m=$()!==null;return T.createElement(T.Fragment,null,!n&&m?T.createElement(J,{ref:s,...e}):T.createElement(oe,{ref:s,...e}))}),Ke=Object.assign(J,{Child:Ne,Root:J});export{Ke as Transition};\n","import{useState as s,useEffect as o}from\"react\";import{disposables as t}from'../utils/disposables.js';function p(){let[e]=s(t);return o(()=>()=>e.dispose(),[e]),e}export{p as useDisposables};\n","import a from\"react\";import{useLatestValue as n}from'./use-latest-value.js';let o=function(t){let e=n(t);return a.useCallback((...r)=>e.current(...r),[e])};export{o as useEvent};\n","import{useLayoutEffect as t,useEffect as c}from\"react\";import{env as i}from'../utils/env.js';let l=(e,f)=>{i.isServer?c(e,f):t(e,f)};export{l as useIsoMorphicEffect};\n","import{useRef as t}from\"react\";import{useIsoMorphicEffect as o}from'./use-iso-morphic-effect.js';function s(e){let r=t(e);return o(()=>{r.current=e},[e]),r}export{s as useLatestValue};\n","import{useState as r,useEffect as o}from\"react\";import{env as t}from'../utils/env.js';function l(){let[e,f]=r(t.isHandoffComplete);return e&&t.isHandoffComplete===!1&&f(!1),o(()=>{e!==!0&&f(!0)},[e]),o(()=>t.handoff(),[]),e}export{l as useServerHandoffComplete};\n","import{useRef as l,useEffect as i}from\"react\";import{useEvent as r}from'./use-event.js';let u=Symbol();function T(t,n=!0){return Object.assign(t,{[u]:n})}function y(...t){let n=l(t);i(()=>{n.current=t},[t]);let c=r(e=>{for(let o of n.current)o!=null&&(typeof o==\"function\"?o(e):o.current=e)});return t.every(e=>e==null||(e==null?void 0:e[u]))?void 0:c}export{T as optionalRef,y as useSyncRefs};\n","import r,{createContext as l,useContext as d}from\"react\";let o=l(null);o.displayName=\"OpenClosedContext\";var p=(e=>(e[e.Open=0]=\"Open\",e[e.Closed=1]=\"Closed\",e))(p||{});function s(){return d(o)}function C({value:t,children:n}){return r.createElement(o.Provider,{value:t},n)}export{C as OpenClosedProvider,p as State,s as useOpenClosed};\n","function e(...n){return n.filter(Boolean).join(\" \")}export{e as classNames};\n","function t(e){typeof queueMicrotask==\"function\"?queueMicrotask(e):Promise.resolve().then(e).catch(o=>setTimeout(()=>{throw o}))}export{t as microTask};\n","import{microTask as o}from'./micro-task.js';function m(){let a=[],i=[],r={enqueue(e){i.push(e)},addEventListener(e,t,n,s){return e.addEventListener(t,n,s),r.add(()=>e.removeEventListener(t,n,s))},requestAnimationFrame(...e){let t=requestAnimationFrame(...e);return r.add(()=>cancelAnimationFrame(t))},nextFrame(...e){return r.requestAnimationFrame(()=>r.requestAnimationFrame(...e))},setTimeout(...e){let t=setTimeout(...e);return r.add(()=>clearTimeout(t))},microTask(...e){let t={current:!0};return o(()=>{t.current&&e[0]()}),r.add(()=>{t.current=!1})},add(e){return a.push(e),()=>{let t=a.indexOf(e);if(t>=0){let[n]=a.splice(t,1);n()}}},dispose(){for(let e of a.splice(0))e()},async workQueue(){for(let e of i.splice(0))await e()},style(e,t,n){let s=e.style.getPropertyValue(t);return Object.assign(e.style,{[t]:n}),this.add(()=>{Object.assign(e.style,{[t]:s})})}};return r}export{m as disposables};\n","var i=Object.defineProperty;var d=(t,e,n)=>e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var r=(t,e,n)=>(d(t,typeof e!=\"symbol\"?e+\"\":e,n),n);class o{constructor(){r(this,\"current\",this.detect());r(this,\"handoffState\",\"pending\");r(this,\"currentId\",0)}set(e){this.current!==e&&(this.handoffState=\"pending\",this.currentId=0,this.current=e)}reset(){this.set(this.detect())}nextId(){return++this.currentId}get isServer(){return this.current===\"server\"}get isClient(){return this.current===\"client\"}detect(){return typeof window==\"undefined\"||typeof document==\"undefined\"?\"server\":\"client\"}handoff(){this.handoffState===\"pending\"&&(this.handoffState=\"complete\")}get isHandoffComplete(){return this.handoffState===\"complete\"}}let s=new o;export{s as env};\n","function u(r,n,...a){if(r in n){let e=n[r];return typeof e==\"function\"?e(...a):e}let t=new Error(`Tried to handle \"${r}\" but there is no handler defined. Only defined handlers are: ${Object.keys(n).map(e=>`\"${e}\"`).join(\", \")}.`);throw Error.captureStackTrace&&Error.captureStackTrace(t,u),t}export{u as match};\n","import{Fragment as g,cloneElement as b,createElement as E,forwardRef as x,isValidElement as N}from\"react\";import{classNames as R}from'./class-names.js';import{match as S}from'./match.js';var j=(a=>(a[a.None=0]=\"None\",a[a.RenderStrategy=1]=\"RenderStrategy\",a[a.Static=2]=\"Static\",a))(j||{}),w=(e=>(e[e.Unmount=0]=\"Unmount\",e[e.Hidden=1]=\"Hidden\",e))(w||{});function X({ourProps:r,theirProps:t,slot:e,defaultTag:a,features:s,visible:n=!0,name:l}){let o=h(t,r);if(n)return m(o,e,a,l);let u=s!=null?s:0;if(u&2){let{static:i=!1,...d}=o;if(i)return m(d,e,a,l)}if(u&1){let{unmount:i=!0,...d}=o;return S(i?0:1,{[0](){return null},[1](){return m({...d,hidden:!0,style:{display:\"none\"}},e,a,l)}})}return m(o,e,a,l)}function m(r,t={},e,a){var y;let{as:s=e,children:n,refName:l=\"ref\",...o}=T(r,[\"unmount\",\"static\"]),u=r.ref!==void 0?{[l]:r.ref}:{},i=typeof n==\"function\"?n(t):n;o.className&&typeof o.className==\"function\"&&(o.className=o.className(t));let d={};if(t){let f=!1,c=[];for(let[p,F]of Object.entries(t))typeof F==\"boolean\"&&(f=!0),F===!0&&c.push(p);f&&(d[\"data-headlessui-state\"]=c.join(\" \"))}if(s===g&&Object.keys(P(o)).length>0){if(!N(i)||Array.isArray(i)&&i.length>1)throw new Error(['Passing props on \"Fragment\"!',\"\",`The current component <${a} /> is rendering a \"Fragment\".`,\"However we need to passthrough the following props:\",Object.keys(o).map(p=>`  - ${p}`).join(`\n`),\"\",\"You can apply a few solutions:\",['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\"Render a single element as the child so that we can forward the props onto that element.\"].map(p=>`  - ${p}`).join(`\n`)].join(`\n`));let f=R((y=i.props)==null?void 0:y.className,o.className),c=f?{className:f}:{};return b(i,Object.assign({},h(i.props,P(T(o,[\"ref\"]))),d,u,O(i.ref,u.ref),c))}return E(s,Object.assign({},T(o,[\"ref\"]),s!==g&&u,s!==g&&d),i)}function O(...r){return{ref:r.every(t=>t==null)?void 0:t=>{for(let e of r)e!=null&&(typeof e==\"function\"?e(t):e.current=t)}}}function h(...r){var a;if(r.length===0)return{};if(r.length===1)return r[0];let t={},e={};for(let s of r)for(let n in s)n.startsWith(\"on\")&&typeof s[n]==\"function\"?((a=e[n])!=null||(e[n]=[]),e[n].push(s[n])):t[n]=s[n];if(t.disabled||t[\"aria-disabled\"])return Object.assign(t,Object.fromEntries(Object.keys(e).map(s=>[s,void 0])));for(let s in e)Object.assign(t,{[s](n,...l){let o=e[s];for(let u of o){if((n instanceof Event||(n==null?void 0:n.nativeEvent)instanceof Event)&&n.defaultPrevented)return;u(n,...l)}}});return t}function V(r){var t;return Object.assign(x(r),{displayName:(t=r.displayName)!=null?t:r.name})}function P(r){let t=Object.assign({},r);for(let e in t)t[e]===void 0&&delete t[e];return t}function T(r,t=[]){let e=Object.assign({},r);for(let a of t)a in e&&delete e[a];return e}export{j as Features,w as RenderStrategy,P as compact,V as forwardRefWithAs,X as render};\n","'use client';\nimport React from 'react';\n\n/**\n * @internal\n */\nconst SkeletonThemeContext = React.createContext({});\n\n/* eslint-disable react/no-array-index-key */\nconst defaultEnableAnimation = true;\n// For performance & cleanliness, don't add any inline styles unless we have to\nfunction styleOptionsToCssProperties({ baseColor, highlightColor, width, height, borderRadius, circle, direction, duration, enableAnimation = defaultEnableAnimation, }) {\n    const style = {};\n    if (direction === 'rtl')\n        style['--animation-direction'] = 'reverse';\n    if (typeof duration === 'number')\n        style['--animation-duration'] = `${duration}s`;\n    if (!enableAnimation)\n        style['--pseudo-element-display'] = 'none';\n    if (typeof width === 'string' || typeof width === 'number')\n        style.width = width;\n    if (typeof height === 'string' || typeof height === 'number')\n        style.height = height;\n    if (typeof borderRadius === 'string' || typeof borderRadius === 'number')\n        style.borderRadius = borderRadius;\n    if (circle)\n        style.borderRadius = '50%';\n    if (typeof baseColor !== 'undefined')\n        style['--base-color'] = baseColor;\n    if (typeof highlightColor !== 'undefined')\n        style['--highlight-color'] = highlightColor;\n    return style;\n}\nfunction Skeleton({ count = 1, wrapper: Wrapper, className: customClassName, containerClassName, containerTestId, circle = false, style: styleProp, ...originalPropsStyleOptions }) {\n    var _a, _b, _c;\n    const contextStyleOptions = React.useContext(SkeletonThemeContext);\n    const propsStyleOptions = { ...originalPropsStyleOptions };\n    // DO NOT overwrite style options from the context if `propsStyleOptions`\n    // has properties explicity set to undefined\n    for (const [key, value] of Object.entries(originalPropsStyleOptions)) {\n        if (typeof value === 'undefined') {\n            delete propsStyleOptions[key];\n        }\n    }\n    // Props take priority over context\n    const styleOptions = {\n        ...contextStyleOptions,\n        ...propsStyleOptions,\n        circle,\n    };\n    // `styleProp` has the least priority out of everything\n    const style = {\n        ...styleProp,\n        ...styleOptionsToCssProperties(styleOptions),\n    };\n    let className = 'react-loading-skeleton';\n    if (customClassName)\n        className += ` ${customClassName}`;\n    const inline = (_a = styleOptions.inline) !== null && _a !== void 0 ? _a : false;\n    const elements = [];\n    const countCeil = Math.ceil(count);\n    for (let i = 0; i < countCeil; i++) {\n        let thisStyle = style;\n        if (countCeil > count && i === countCeil - 1) {\n            // count is not an integer and we've reached the last iteration of\n            // the loop, so add a \"fractional\" skeleton.\n            //\n            // For example, if count is 3.5, we've already added 3 full\n            // skeletons, so now we add one more skeleton that is 0.5 times the\n            // original width.\n            const width = (_b = thisStyle.width) !== null && _b !== void 0 ? _b : '100%'; // 100% is the default since that's what's in the CSS\n            const fractionalPart = count % 1;\n            const fractionalWidth = typeof width === 'number'\n                ? width * fractionalPart\n                : `calc(${width} * ${fractionalPart})`;\n            thisStyle = { ...thisStyle, width: fractionalWidth };\n        }\n        const skeletonSpan = (React.createElement(\"span\", { className: className, style: thisStyle, key: i }, \"\\u200C\"));\n        if (inline) {\n            elements.push(skeletonSpan);\n        }\n        else {\n            // Without the <br />, the skeleton lines will all run together if\n            // `width` is specified\n            elements.push(React.createElement(React.Fragment, { key: i },\n                skeletonSpan,\n                React.createElement(\"br\", null)));\n        }\n    }\n    return (React.createElement(\"span\", { className: containerClassName, \"data-testid\": containerTestId, \"aria-live\": \"polite\", \"aria-busy\": (_c = styleOptions.enableAnimation) !== null && _c !== void 0 ? _c : defaultEnableAnimation }, Wrapper\n        ? elements.map((el, i) => React.createElement(Wrapper, { key: i }, el))\n        : elements));\n}\n\nfunction SkeletonTheme({ children, ...styleOptions }) {\n    return (React.createElement(SkeletonThemeContext.Provider, { value: styleOptions }, children));\n}\n\nexport { SkeletonTheme, Skeleton as default };\n"],"names":["InvalidCharacterError","message","this","prototype","Error","name","window","atob","bind","input","str","String","replace","length","bs","buffer","bc","idx","output","charAt","fromCharCode","indexOf","decodeURIComponent","m","p","code","charCodeAt","toString","toUpperCase","err","InvalidTokenError","token","options","pos","header","JSON","parse","base64_url_decode","split","e","some","arr","callback","i","find","getUserAgentString","agent","userAgent","navigator","toLowerCase","execRegExp","pattern","text","RegExp","exec","hasUserAgentData","userAgentData","brands","uaList","convertVersion","findPreset","presets","userPreset","version","preset","result","test","brand","versionAlias","versionTest","findVersion","findPresetBrand","brandInfo","findBrand","id","_a","BROWSER_PRESETS","CHROMIUM_PRESETS","WEBKIT_PRESETS","WEBVIEW_PRESETS","OS_PRESETS","isWebView","getClientHintsAgent","osData","fullVersionList","isMobile","mobile","firstBrand","platform","browser","majorVersion","webkit","webkitVersion","chromium","chromiumVersion","webview","os","chromiumBrand","webkitBrand","platfomResult","platformVersion","browserBrandByFullVersionList","browserBrand","uaFullVersion","parseInt","isHints","nextAgent","browserPreset","browserVersion","osPreset","osVersion","chromiumPreset","webkitPreset","getLegacyAgent","prefixNames","prefix","classNames","map","className","join","ref","target","refs","UNDEFINED","IS_WINDOW","OPEN_CLOSED_CHARACTERS","document","open","close","TINY_NUM","DEFAULT_UNIT_PRESETS","size","innerWidth","innerHeight","Math","max","min","dot","a1","a2","b1","b2","isUndefined","value","isObject","isArray","Array","isString","isNumber","isFunction","findOpen","openCharacter","texts","index","openCloseCharacters","findIgnore","closeCharacter","character","trim","nextIndex","findClose","ignore","otherText","slice","splitText","splitOptions","separator","_b","isSeparateFirst","isSeparateOnlyOpenClose","_c","isSeparateOpenClose","_d","openClosedText","regex","filter","Boolean","values","tempValues","resetTemp","push","nextOpenCloseCharacters","splice","isEqualSeparator","splitSpace","splitComma","splitBracket","matches","suffix","splitUnit","unit","NaN","parseFloat","now","Date","getTime","findIndex","defaultIndex","defalutValue","requestAnimationFrame","firstTime","raf","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","currTime","setTimeout","cancelAnimationFrame","caf","webkitCancelAnimationFrame","mozCancelAnimationFrame","msCancelAnimationFrame","handle","clearTimeout","getKeys","obj","Object","keys","convertUnitSize","sizeFunction","between","checkBoundSize","targetSize","compareSize","isMax","ratio","throttle","every","defaultSize","throttledSize","average","nums","total","getRad","pos1","pos2","distX","distY","rad","atan2","PI","getShapeDirection","points","center","getCenterPoint","pos1Rad","pos2Rad","getDist","a","b","sqrt","pow","num","reverseUnit","round","throttleArray","forEach","_","hasClass","element","classList","contains","match","addClass","add","removeClass","remove","reg","addEvent","el","type","listener","addEventListener","removeEvent","removeEventListener","matrix","inverseMatrix","startIndex","fromIndex","n","k","x","fromX","swap","v","iv","divide","ignoreDimension","newMatrix","invert","createIdentityMatrix","identityIndex","j","targetStartIndex","getOrigin","originMatrix","w","convertPositionMatrix","convertDimension","multiplies","matrixes","multiply","matrix2","l","plus","nextPos","minus","convertMatrixtoCSS","is2d","calculate","rotateX3d","cos","sin","rotateY3d","rotateZ3d","createRotateMatrix","scale3d","sx","sy","rotate","translate3d","tx","ty","matrix3d","matrix1","createScaleMatrix","scale","createOriginMatrix","origin","createWarpMatrix","pos0","pos3","nextPos0","nextPos1","nextPos2","nextPos3","x0","y0","x1","y1","x2","y2","x3","y3","u0","v0","u1","v1","u2","v2","u3","v3","h","transpose","parseMat","transform","toMat","matrixInfos","info","matrixFunction","functionValue","t","functionName","posX","posY","posZ","_e","_f","_g","sz","_h","unitValue","key","prevIndex","object","SUPPORT_MAP","Map","prevLink","nextLink","prev","next","link","prevList","list","added","removed","changed","maintained","changedBeforeAdded","fixed","cacheOrdered","caculateOrdered","cachePureChanged","ordered","fromLinks","toLinks","from","to","Link","connect","fromLink","toLink","getIndex","disconnect","undefined","orderChanged","pureChanged","fromBefore","toBefore","diff","findKeyCallback","mapClass","HashMap","PolyMap","prevKeys","prevKeyMap","keyMap","removedMap","addedCount","removedCount","prevListIndex","set","listIndex","get","reverse","Result","call","newData","childrenCount","__DIFF_KEY__","_super","tslib_1","ListDiffer","tinyThrottle","getAreaSize","abs","sum","point","nextPoint","fitPoints","rect","width","height","left","top","getMinMaxs","minX","minY","maxX","maxY","ratioX","ratioY","xs","ys","isInside","excludeLine","y","xLine","xLinearConstants","getLinearConstants","lines","convertLines","intersectionPosInfos","line","linearConstants2","linearConstants","standardPoint","getPointsOnLines","getIntersectionPointsByConstants","linePoint","point2","point1","intersectionCount","xMap","prevValue","nextValue","dx","dy","c","linearConstants1","c1","c2","isZeroA","isZeroB","results","Infinity","minMaxs","order","minMax","right","bottom","pointX","pointY","__spreadArrays","getOverlapPointInfos","points1","points2","targetPoints1","targetPoints2","lines1","lines2","linearConstantsList1","line1","linearConstantsList2","line2","overlapInfos","linePointInfos","index1","index2","sort","isNext","pointMap","getOverlapSize","getOverlapPoints","_events","__proto","eventName","on","_addEvent","off","events","once","Promise","resolve","_this","param","isStop","eventType","stop","currentTarget","emit","getDefaultScrollPosition","container","body","scrollLeft","documentElement","scrollTop","checkDefaultScrollEvent","getContainerElement","querySelector","Element","current","_currentOptions","_lock","inputEvent","checkScroll","__extends","getBoundingClientRect","_flag","_startPos","clientX","clientY","_startRect","_prevScrollPos","_getScrollPosition","_registerScrollEvent","_timer","threshold","direction","_continueDrag","isDrag","_isWait","prevScrollPos","throttleTime","nextScrollPos","offsetX","offsetY","nextDirection","_unregisterScrollEvent","useScroll","nowTime","distTime","_prevTime","requestScroll","checkScrollEvent","_unregister","_onScroll","EventEmitter","extendStatics","d","setPrototypeOf","__proto__","hasOwnProperty","__assign","assign","s","arguments","apply","getRotatiion","touches","getEventClients","clients","getClient","getClients","getPosition","prevClients","startClients","getAverageClient","originalClientX","originalClientY","prevX","prevY","deltaX","deltaY","sumClient","client","ClientStore","isAdd","position","movement","startClient","currentClient","prevClient","INPUT_TAGNAMES","Gesto","isTrusted","flag","cancelable","pinchOutside","preventWheelClick","preventRightClick","preventDefault","checkInput","preventClickEventOnDragStart","preventClickEventOnDrag","preventClickEventByCondition","isTouch","isDragStart","_isSecondaryButton","which","button","activeElement","tagName","hasInput","hasContentEditable","isContentEditable","activeTagName","blur","_onClick","clientStores","_isTrusted","_dragFlag","_prevInputEvent","data","doubleFlag","prevTime","_isMouseEvent","isMouseEvent","_preventMouseEvent","datas","isSecondaryButton","isDouble","getCurrentStore","preventDrag","timer","_attchDragEvent","onDragStart","passive","isMultiTouch","changedTouches","pinchFlag","onPinchStart","isScroll","moveClients","onPinch","_allowClickEvent","onPinchEnd","keepDragging","_addStore","_getPosition","currentTime","_dettachDragEvent","isClick","onDragEnd","stopPropagation","elements","concat","targets","checkWindowBlur","pinchThreshold","isMouse","_passCallback","_onContextMenu","onBlur","passive_1","__","constructor","create","getMovement","reduce","cur","isPinch","isCallDrag","move","onDrag","nextClients","currentData","name_1","setEventData","store","angle","getAngle","getPositions","rotation","getRotation","getScale","distance","getDistance","isPrevDrag","isFirstDrag","storePosition","injectStyle","css","shadowRoot","style","createElement","setAttribute","nonce","innerHTML","original","selector","trimmedSelector","subSelector","trimmedSubSelector","replaceStyle","head","appendChild","injectElement","injectClassName","stringHash","injectCount","inject","styleElement","parentElement","getRootNode","rootNode","nodeType","getShadowRoot","firstMount","destroy","removeChild","parentNode","portalContainer","cspNonce","attributes","cssId","injector","Tag","tag","portalAttributes","injectResult","props","Component","cssStyled","StyledElement","makeAble","able","getAgent","IS_WEBKIT","IS_WEBKIT605","navi","res","IS_FIREFOX","IS_SAFARI_ABOVE15","PREFIX","MOVEABLE_CSS","degree","getSVGCursor","degree45","defaultCursor","getCursorCSS","NEARBY_POS","FLOAT_POINT_NUM","MIN_SCALE","MAX_NUM","MIN_NUM","DIRECTIONS4","DIRECTIONS","DIRECTION_REGION_TO_DIRECTION","nw","ne","sw","se","DIRECTION_INDEXES","DIRECTION_ROTATIONS","MOVEABLE_METHODS","setCustomDrag","state","delta","isConvert","ableName","gestos","originalDatas","ableDatas","convertDragDist","parentEvent","startX","startY","isFlag","draggable","parentGesto","CustomGesto","calculatePointerDist","moveable","moveableClientRect","rootMatrix","is3d","calculateInversePosition","getDragDist","setDragStart","allMatrix","beforeMatrix","offsetMatrix","targetMatrix","transformOrigin","inverseBeforeMatrix","absoluteOrigin","startDragBeforeDist","startDragDist","resolveTransformEvent","event","beforeRenderable","transformIndex","nextTransforms","nextTransformAppendedIndexes","transforms","beforeFunctionTexts","beforeFunctionTexts2","targetFunctionText","afterFunctionTexts","afterFunctionTexts2","beforeFunctions","beforeFunctions2","targetFunctions","afterFunctions","afterFunctions2","beforeFunctionMatrix","beforeFunctionMatrix2","afterFunctionMatrix","afterFunctionMatrix2","allFunctionMatrix","targetFunctionMatrix","targetFunction","convertTransformInfo","matFunctionName","beforeTransform","beforeTransform2","targetTansform","afterTransform","afterTransform2","targetAllTransform","isAppendTransform","__spreadArray","isAppend","convertTransformFormat","dist","getTransformDist","getBeforeDragDist","getTransfromMatrix","fromTranslation","isAfter","nextTargetMatrix","res1","isBefore","getPosIndexesByDirection","indexes","getPosByDirection","poses","xRatio","yRatio","getNextMatrix","getAbsoluteMatrix","fillTransformStartEvent","getBeforeRenderableDatas","setTransform","startTransforms","setTransformIndex","setDefaultTransformIndex","property","func","startValue","fillOriginalTransform","getNextTransforms","getNextTransformText","getNextStyle","nextStyle","fillTransformEvent","nextTransform","drag","Draggable","fillCSSObject","getTranslateDist","fixedDirection","fixedPosition","groupable","nextMatrix","getNextTransformMatrix","groupLeft","groupTop","getDirectionOffset","getDirectionByPos","calculatePosition","getResizeDist","prevOrigin","prevWidth","prevHeight","nextOrigin","prevSize","isNaN","calculateTransformOrigin","startPos","fixedPos","calculatePoses","getAbsolutePosition","getAbsolutePosesByState","_i","defaultSync","fn","getTransformMatrix","getBeforeTransformOrigin","getTransformOrigin","getComputedStyle","o","isHorizontal","getSVGViewBox","ownerSVGElement","measureSVGSize","getElementTransform","computedStyle","computedTransform","baseVal","chr","getOffsetInfo","lastParent","isParent","checkZoom","targetStyle","parentSlotElement","doc","ownerDocument","hasSlot","assignedSlotParentElement","assignedSlot","isCustomElement","isEnd","offsetZoom","targetZoom","zoom","targetPosition","willChange","slotParentNode","targetParentNode","host","isStatic","offsetParent","getOffsetPosInfo","targetOrigin","offsetLeft","offsetTop","isSVG","hasOffset","isGTarget","getBBox","bbox","viewBox","getSVGGraphicsOffset","offset","getBodyOffset","bodyStyle","bodyPosition","marginLeft","marginTop","convert3DMatrixes","getPositionFixedInfo","fixedContainer","hasTransform","makeMatrixCSS","clientWidth","clientHeight","getSVGMatrix","viewBoxWidth","viewBoxHeight","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","translate","xAlign","yAlign","floor","scaleDimension","scaleMatrix","getRect","posesX","posesY","calculateRect","calculateMoveablePosition","x4","y4","originX","originY","pos4","getDistSize","vec","getDiagonalSize","getLineStyle","getControlTransform","getProps","self","getSize","offsetWidth","offsetHeight","cssWidth","cssHeight","contentWidth","contentHeight","minWidth","minHeight","minOffsetWidth","minOffsetHeight","maxWidth","maxHeight","maxOffsetWidth","maxOffsetHeight","inlineCSSWidth","inlineCSSHeight","svg","boxSizing","borderLeft","borderLeftWidth","borderRight","borderRightWidth","borderTop","borderTopWidth","borderBottom","borderBottomWidth","horizontalPadding","paddingLeft","paddingRight","verticalPadding","paddingTop","paddingBottom","horizontalOffset","verticalOffset","containerWidth","containerHeight","parentStyle","getRotationRad","getExtendsRect","isRoot","extendsRect","clientLeft","clientTop","scrollWidth","scrollHeight","overflow","getClientRectByPosition","base","isExtends","baseTop","baseLeft","getClientRect","clientRect","getTotalDirection","parentDirection","getDirection","deg","getAttribute","direciton","dir","getAbsolutePoses","unset","resolvedEvent","cssText","all","letter","letter2","fillAfterTransform","prevEvent","nextEvent","fillParams","params","isBeforeEvent","nextParams","stopAble","isEventStart","stopDrag","isStartEvent","lastEvent","fillEndParams","catchEvent","_emitter","triggerEvent","isManager","pseudoElt","filterAbles","ables","methods","triggerAblesSimultaneously","enabledAbles","ableGroups","method","ableGroup","equals","groupBy","groups","groupKeys","groupKey","keyIndex","group","flat","maxOffset","args","calculatePadding","convertCSSSize","isRelative","getTinyDist","getDirectionViewClassName","isDragging","targetGesto","controlGesto","getEventData","getGestoData","getDirectionCondition","checkAbles","isRequest","requestAble","invertObject","nextObj","getRefTarget","isSelector","getRefTargets","querySelectorAll","getDragDistByState","calculateMatrixDist","getSizeDistByDist","startSize","keepRatio","startOffsetWidth","startOffsetHeight","distWidth","distHeight","standardRad","signSize","startWidthSize","startHeightSize","distSize","ratioRad","getOffsetSizeDist","sizeDirection","parentDistance","parentDist","parentScale","startFixedDirection","directionsDists","directionRatios","ratioDistance","dist_1","convertTransformUnit","xy","leftOrigin","rightOrigin","originObject","nextOriginObject","convertTransformOriginArray","isDeepArrayEquals","arr1","arr2","value1","value2","isArray1","isArray2","onPinchGroupStart","onPinchGroup","onPinchGroupEnd","dragStart","pinchStart","pinchable","controlEventName","pinchAbles","controlAbles","canPinch","ableEvent","parentRotate","snapRenderInfo","request","pinch","pinchScale","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","fillChildEvents","groupableDatas","childDatas","moveables","triggerChildGesto","isStart","childs","ev","childMoveable","childEvent","childGestos","parentFlag","child","triggerChildAbles","eachEvent","VERTICAL_NAMES","HORIZONTAL_NAMES","VERTICAL_NAMES_MAP","start","end","HORIZONTAL_NAMES_MAP","hasGuidelines","snappable","bounds","innerBounds","verticalGuidelines","horizontalGuidelines","snapGridWidth","snapGridHeight","guidelines","enableSnap","getSnapDirections","snapDirections","splitSnapDirectionPoses","snapPoses","nextSnapPoses","nextSnapDirections","mapSnapDirectionPoses","horizontalNames","verticalNames","horizontal","vertical","checkMoveableSnapPoses","customSnapThreshold","snapThreshold","selectValue","checkSnapPoses","checkSnap","checkSnaps","getNearestSnapGuidelineInfo","snapInfo","isSnap","guideline","posInfo","posInfos","guidelineInfo","guidelineInfos","targetType","targetPoses","posType","snapPosInfos","targetPos","snapPosInfo","getSnapInfosByDirection","snapDirection","nextPoses","getPosesByDirection","alignPoses","checkSnapBoundPriority","aDist","bDist","isBound","getNearOffsetInfo","offsets","aSign","sign","bSign","aOffset","bOffset","isStartLine","cx","cy","hitTestLine","test1","test2","isSameStartLine","dots","centerSign","error","checkInnerBoundDot","checkLineBoundCollision","boundLine","isRender","dot1","boundDot1","boundDot2","dy2","hasDx","hasDy","slope","getInnerBoundInfo","lineInfos","verticalSign","horizontalSign","lineConstants","isAllBound","isVerticalBound","isHorizontalBound","leftLine","topLine","rightLine","bottomLine","topBoundInfo","bottomBoundInfo","leftBoundInfo","rightBoundInfo","isAllVerticalBound","isAllHorizontalBound","checkInnerBound","multiple","sizeOffset","getInnerBoundDragInfo","innerBoundInfo","getCheckInnerBoundLineInfos","widthOffsetInfo","heightOffsetInfo","getInverseDragDist","virtualPoses","lineDirections","getCheckSnapLineDirections","dir1","dir2","virtualLine","solveLineConstants","isBoundRotate","relativePoses","boundDots","checkRotateInnerBounds","prevPoses","relativeLeft","relativeRight","relativeTop","relativeBottom","dotInfos","lineRad","solveReverseLine","lineDist","getDistPointLine","dotDist","dotRad","distRad","acos","nextRad","checkBoundPoses","verticalPoses","horizontalPoses","nextBounds","checkBounds","getBounds","externalBounds","snapOffsetLeft","snapOffsetTop","snapOffsetRight","snapOffsetBottom","isCSS","isVertical","startBoundPos","endBoundPos","minPos","maxPos","boundInfos","boundRect","checkRotateBounds","boundPos","relativeRad1","r","boundRotate","relativeRad2","renderInnerGuideline","React","scaleType","renderGuideline","sizeValue","posValue","renderSnapPoses","renderPos","renderGuidelines","targetRect","isDisplayInnerSnapDigit","mainNames","targetStart","targetEnd","hide","elementRect","renderDigitLine","lineType","gap","snapDigit","isDisplaySnapDigit","snapDistFormat","sizeName","absGap","snapSize","toFixed","renderDashedGuidelines","rendered","nextGuidelines","otherIndex","names","elementRect1","elementRect2","inner","groupByElementGuidelines","sideNames","sidePos","prevRect","nextRect","size1","size2","renderPos1","renderPos2","solveNextOffset","snapOffset","solveEquation","isOutside","dist1","dist2","getSnapBound","boundInfo","checkSnapBoundsDrag","throttleDragRotate","absolutePoses","boundPoses","checkMoveableSnapBounds","middle","verticalSnapBoundInfo","horizontalSnapBoundInfo","verticalInnerBoundInfo","horizontalInnerBoundInfo","isVerticalSnap","isHorizontalSnap","adjustPoses","adjustPos","prevDistY","checkThrottleDragRotate","horizontalBoundInfos","verticalBoundInfos","horizontalSnapInfo","verticalSnapInfo","horizontalDist","verticalDist","snapIndex","snap","checkSnapBounds","guideines","getSnapBoundInfo","directions","startDirection","endDirection","otherStartPos","otherEndPos","snapBoundInfo","endPos","endX","endY","isBottom","isRight","verticalInfo","horizontalInfo","checkBoundKeepRatio","horizontalBoundInfo","verticalBoundInfo","verticalGuideline","horizontalGuideline","horizontalPos","verticalPos","checkSnapKeepRatio","getSnapBoundOffset","checkSnapBoundsKeepRatio","otherHorizontalOffset","isOtherHorizontalBound","isOtherHorizontalSnap","otherVerticalOffset","isOtherVerticalBound","isOtherVerticalSnap","snapLine","rad180","isHorizontalLine","isVerticalLine","checkSnapRightLine","getTotalGuidelines","containerClientRect","hasFixed","containerClientHeight","containerClientWidth","snapGap","maxSnapElementGuidelineDistance","elementGuidelines","elementRects","prevValues","snapRect","refresh","nextElementGuidelines","listdiff","nextValues","containerRect","clientPos","calculateContainerPos","containerLeft","containerTop","targetLeft","targetTop","distLeft","distTop","elementLeft","elementTop","elementRight","elementBottom","getSnapElementRects","elementSnapDirections","topValue","leftValue","rightValue","bottomValue","centerValue","middleValue","rectTop","rectLeft","sizes","getElementGuidelines","totalGuidelines","maxSnapElementGapDistance","gapGuidelines","targetCenter","targetStart2","targetEnd2","nextElementRects","snapRect1","snapRect2","rect1","rect2","rect1Start","rect1End","rect2Start","rect2End","isCenter","checkBetweenRects","gapRects","getGapGuidelines","getGridGuidelines","top_1","left_1","getDefaultGuidelines","snapWidth","snapHeight","nextPosInfo","checkSnapInfo","snapContainer","snapContainerTarget","snapContainerRect","offset1","offset2","getNextFixedPoses","getSizeOffsetInfo","endDirection_1","signX","signY","getCheckSnapDirections","innerBoundLineInfos","checkSizeDist","getNextPoses","widthOffset","heightOffset","isWidthBound","isHeightBound","nextWidthOffset","nextHeightOffset","widthDist","heightDist","right_1","bottom_1","otherDirection","isCheckVertical","isCheckHorizontal","otherPos","nextOtherPos","isHeightOutside","isWidthOutside","checkMaxBounds","snapPos","recheckSizeByTwoDirection","checkSnapScale","sizeDist","getSnapGuidelines","addBoundGuidelines","verticalSnapPoses","horizontalSnapPoses","boundMap","lineInfo","isHorizontalStart","isVerticalStart","checkInnerBoundPoses","verticalInnerBoundPoses","horizontalInnerBoundPoses","innerPos","directionCondition","dragRelation","Number","snapRenderThreshold","Function","onSnap","render","minLeft","minTop","externalPoses","snapInfos","hasExternalPoses","externalRect","verticalPosInfos","horizontalPosInfos","allGuidelines","gaps","targetSideStart","targetSideEnd","sideStartPos","sideEndPos","sideCenterPos","renderGapGuidelines","dragEnd","dragControlCondition","rotatableDragControlCondtion","dragControlStart","dragControl","dragControlEnd","dragGroupStart","dragGroup","dragGroupEnd","dragGroupControlStart","dragGroupControl","dragGroupControlEnd","renderDirectionControlsByInfos","renderDirections","getState","renderPoses","rotationRad","degRotation","directionMap","renderState","renderDirectionMap","directionRotation","dataAttrs","renderDirectionControls","defaultDirections","renderLine","renderEdgeLines","edge","getRenderDirections","renderDiagonalDirections","renderAllDirections","throttleDrag","startDragRotate","edgeDraggable","onDragGroupStart","onDragGroup","onDragGroupEnd","requestStyle","dragInfo","beforeOrigin","startCheckSnapDrag","prevDist","prevBeforeDist","deltaOffset","startRect","parentMoveable","dragRotateRad","ry","beforeTranslate","beforeDist","beforeDelta","passDelta","passDist","dragAfter","isControl","requestStart","requestEnd","resizable","throttleResize","resizeFormat","keepRatioFinally","checkResizableError","onResizeStart","onBeforeResize","onResize","onResizeEnd","onResizeGroupStart","onBeforeResizeGroup","onResizeGroup","onResizeGroupEnd","viewClassName","isGroup","parentFixedDirection","minSize","startWidth","startHeight","maxSize","setRatio","isFinite","setFixedDirection","startPositions","setFixedPosition","setMin","setMax","nextMaxSize","startOffsetMatrix","startTransformOrigin","isWidth","parentIsWidth","startRatio","setOrigin","startFixedPosition","isResize","parentKeepRatio","dragClient","resolveMatrix","targetN","nextAllMatrix","getNextBoundingSize","boundingWidth","boundingHeight","nextFixedDirection","nextFixedPosition","setSize","snapDist","checkSnapResize","isNoSnap","computeSize","calculateBoundSize","inverseDelta","nextWidth","nextHeight","nextSize","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","dragGroupControlCondition","originalEvents","setDist","originalX","originalY","parentStartOffsetWidth","parentStartOffsetHeight","updateGroupMin","originalMinSize","childMinSize","childStartOffsetWidth","childStartOffsetHeight","parentMinWidth","parentMinHeight","updateGroupMax","originalMaxSize","childMaxSize","parentMaxWidth","parentMaxHeight","deltaWidth","deltaHeight","setRotateStartInfo","startAbsoluteOrigin","prevDeg","defaultDeg","prevSnapDeg","loop","startDist","getAbsoluteDist","normalizedPrevDeg","getAbsoluteDistByClient","getRotateInfo","moveableRect","throttleRotate","snapRotation","origin2","checkSnapRotate","snapDeg","getRotationPositions","rotationPosition","radPoses","isReverse","rotationTarget","directionCSS","rotatable","rotateAroundControls","resolveAblesWithRotatable","onRotateStart","onBeforeRotate","onRotate","onRotateEnd","onRotateGroupStart","onBeforeRotateGroup","onRotateGroup","onRotateGroupEnd","positions","jsxs","resolveMap_1","directionControlInfos","renderAroundControls","beforeDirection","targetTransform","resizeStart","startClientX","startClientY","externalRotate","beforeInfo","afterInfo","absoluteInfo","inputTarget","regionDirection","controlDirection","isAroundControl","resolveAble","clientPoses","rootClientRect","rootPoses","calculateMoveableClientPositions","originalFixedPosition_1","fixedBeforeOrigin","fixedAfterOrigin","posDelta","Resizable","parentPosition","controlPosition","parentFixedPosition","rotatation","isRotate","clientDistX","clientDistY","groupDelta","beforeRotation","absoluteDelta","absoluteDist","absoluteRotation","targetDirection","getTransformDirection","startRotation","absoluteStartRotation","nextClientX","nextClientY","setRotation","nextRotation","inverseDist","rotateDist","getRotateDist","prevInverseDist","requestValue","dragEvent","transformEvent","resize","resizeEvent","beforeRotate","absoluteRotate","parentLeft","parentTop","parentBeforeOrigin","childClient","startGroupClient","groupClient","prevClientX","prevClientY","setGroupRotation","distRotate","deltaRotate","scalable","throttleScale","onScaleStart","onBeforeScale","onScale","onScaleEnd","onScaleGroupStart","onBeforeScaleGroup","onScaleGroup","onScaleGroupEnd","scaleWidth","scaleHeight","scaleXRatio","scaleYRatio","isScale","getNextScale","stateDirection","setScale","nextScale","scaleDist","getScaleDist","scaleEndParam","moveableScale","getMiddleLinePos","getTriangleRad","rad1","warpable","onWarpStart","onWarp","onWarpEnd","linePosFrom1","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","warpTargetMatrix","targetInverseMatrix","prevMatrix","posIndexes","isWarp","selectedPoses","nearByPoses","poses1","poses2","rad2","pi","isValidPos","totalMatrix","AREA_PIECES","AREA_PIECE","AVOID","VIEW_DRAGGING","restoreStyle","areaElement","renderPieces","dragArea","passDragArea","onClick","onClickGroup","isDragArea","rects","children","nextElementSibling","disableNativeEvent","enableNativeEvent","scrollContainer","scrollable","scrollThreshold","scrollThrottleTime","getScrollPosition","scrollOptions","onScroll","onScrollGroup","getContainer","dragScroll","DragScroll","scrollContainerElement","gestoName","scrollBy","getCurrentEvent","dragGroupControEnd","dragTarget","rootContainer","useResizeObserver","translateZ","hideDefaultLines","flushSync","preventClickDefault","viewContainer","persistData","useAccuratePosition","firstRenderState","linePadding","onChangeTargets","padding","paddingDirections","RADIUS_DIRECTIONS","calculateRatio","sumSize","sumRatio","HORIZONTAL_RADIUS_ORDER","VERTICAL_RADIUS_ORDER","HORIZONTAL_RADIUS_DIRECTIONS","VERTICAL_RADIUS_DIRECTIONS","getRadiusStyles","clipStyles","radiusPoses","virtual","raws","rawPos","styles","getRadiusRange","controlPoses","horizontalRange","verticalRange","clipPose","sub","getRadiusValues","minCounts","full","splitIndex","splitLength","horizontalValues","verticalValues","horizontalValuesLength","verticalValuesLength","hasVerticalValues","nwValue","neValue","seValue","swValue","wnValue","_j","_k","enValue","_l","esValue","_m","wsValue","horizontalRawPoses","verticalRawPoses","nextHorizontalPoses","nextVerticalPoses","raw","CLIP_DIRECTIONS","CLIP_RECT_DIRECTIONS","getClipStyles","clipPath","clipRelative","clipType","clipPoses","isRect","isCircle","subWidth","subHeight","getRectPoses","dirx","diry","getControlSize","xRange","yRange","getClipPath","defaultClip","customClip","clipText","clip","clipPrefix","splitter","xPos","yPos","radiusX_1","radiusY_1","radius","xRadius","yRadius","centerPos_1","radiusX","radiusY","roundIndex","rectLength","radiusValues","_o","_p","nextRight","nextBottom","addClipPath","clipIndex","horizontalIndex","verticalIndex","startVerticalIndex","addRadiusPos","clipStyle","clipEventType","removeClipPath","radiuslIndex","deleteCount","removeRadiusPos","clippable","defaultClipPath","customClipPath","clipArea","dragWithClip","clipTargetBounds","clipVerticalGuidelines","clipHorizontalGuidelines","clipSnapThreshold","onClipStart","onClip","onClipEnd","clipPathState","snapBoundInfos","calculatedPos","controls","isInset","isPolygon","linePoses_1","clipLeft","clipTop","ellipseClipPath","piece","areaPoses","allWidth","allHeight","allLeft_1","allTop_1","directionType","snapPos1","snapPos2","isDragTarget","isClipStart","isLine","isArea","originalDraggable","originalDist","firstDist","isDragWithTarget","isAll","dists","verticalDirections","horizontalDirections","verticalDirection_1","horizontalDirection_1","nextDist","nextControlPoses_1","controlPose","controlDir","dirDir","dirHorizontal","dirVertical","moveControlPos","guidePoses","isEllipse","guideRect","rx","guideXPoses","guideYPoses","rectPoses","rectDists_1","boundDelta","snapOffsetY","snapOffsetX","width_1","height_1","nextControlPoses_2","nextClipStyles","dragDist","originDraggable","originRelative","onDragOriginStart","onDragOrigin","onDragOriginEnd","startOrigin","startTargetOrigin","isDragOrigin","distOrigin","dragDelta","deltaOrigin","getBorderRadius","borderRadius","triggerRoundEvent","roundRelative","horizontals","verticals","splitRadiusPoses","borderRadiusState","getStyleBorderRadius","firstTarget","getTargets","roundable","minRoundControls","maxRoundControls","roundClickable","roundPadding","isDisplayShadowRoundControls","onRoundStart","onRound","onRoundEnd","onRoundGroupStart","onRoundGroup","onRoundGroupEnd","verticalCount","horizontalCount","basePos","originalPos","isDisplay","display","controlIndex","lineIndex","indexAttr","isRound","selectedControlPose","selectedVertical","selectedHorizontal","pose","poseDist","horizontalsLength","verticalsLength","controlPoseInfo","addBorderRadius","addBorderRadiusByLine","removeBorderRadius","onBeforeRenderStart","onBeforeRender","onBeforeRenderEnd","onBeforeRenderGroupStart","onBeforeRenderGroup","onBeforeRenderGroupEnd","cssMatrix","startTransform","identityMatrix","isIdentityMatrix","resetStyle","fillDragStartParams","fillDragParams","onRenderStart","onRender","onRenderEnd","onRenderGroupStart","onRenderGroup","onRenderGroupEnd","resultCount","fillDragEndParams","triggerAble","ableType","eventOperation","eventAffix","requestInstant","conditionName","isFirstStart","updateRect","requestAble_1","eventAbles","BeforeRenderable","Renderable","elementFromPoint","isDragStop","isUpdate","nextDatas","isForceEnd","isUnmounted","forceUpdate","checkMoveableTarget","eventTarget","isMoveableElement","controlBox","getElement","getTargetAbleGesto","moveableTarget","getAbleGesto","conditionFunctions","isTargetAbles","gesto","_onEvent","setAbles","EventManager","getMatrixStackInfo","checkContainer","targetTransformOrigin","offsetContainer","convertCSStoMatrix","isFixed","fixedInfo","offsetPos","isOffsetEnd","offsetInfo","customOffsetParent","customOffsetLeft","customOffsetTop","parentClientLeft","parentClientTop","fixedClientLeft","fixedClientTop","margin","isElementTarget","calculateMatrixStack","isAbsolute3d","prevTargetMatrix","containerZoom","rootMatrixes","isRoot3d","offsetRootContainer","rootZoom","isNext3d","isSVGGraphicElement","originalRootContainer","endContainer","rootMatrixBeforeOffset","targetInfo","rectWidth","rectHeight","mat","prevLeft","prevTop","posOrigin","rectOrigin","count","getSVGOffset","isMatrix3d","originalRootMatrix","hasZoom","calculateElementInfo","allResult","getMoveableTargetInfo","moveableElement","parentContainer","targetClientRect","rootContainerClientRect","offsetDelta","computedStyle_1","beforePosition","absoluteTargetPosition","absoluteContainerPosition","containerClientRectLeft","containerClientRectTop","containterClientLeft","containerClientTop","clientDelta","originalBeforeOrigin","getPersistState","isPersisted","checkUpdateRect","_observerId","propsTarget","ControlBoxElement","_checkUpdateRootContainer","checkUpdate","updateRenderPoses","stateTarget","groupTargets","ableAttributes","getEnabledAbles","ableClassName","_getAbleClassName","_hasFirstTarget","isVisible","_onPreventClick","renderAbles","_renderLines","isMoveableMounted","wrapperMoveable","_checkUpdateViewContainer","_updateTargets","_updateNativeEvents","_updateEvents","updateCheckInput","_updateObserver","componentDidUpdate","prevProps","_viewContainer","_changeAbleViewClassNames","manager","getAble","triggerDragStart","hitTest","totalSize","isTarget","isSetState","_rootContainer","nextState","_getRequestStyles","persistState","updateState","updateTarget","statePos","getAbsoluteRotation","isInstant","requsetAble","ableRequester","requester","ableParam","componentWillUnmount","stateLeft","stateTop","_isPropTargetChanged","stateContainer","updateAbles","isTargetChanged","moveableContainer","unsetAbles","trigger","customStyleMap","customStyledMap","styled","hasControlBox","updateSelectors","targetAbles","setState","always","Renderer","groupByMap","ableStyleNames","ResizeObserver","_observer","observer","observe","box","controlBoxElement","hasTargetAble","hasControlAble","_isTargetChanged","_prevTarget","_prevDragArea","hideChildMoveableDefaultLines","useDragArea","prevTarget","prevDragArea","eventKeys","hasAbles","viewContainerOption","_getAbleViewClassNames","nextClassNames","prevClassNames","_viewClassNames","classPrefix","targetGestoData","controlGestoData","MoveableManager","isWrapperMounted","defaultGroupRotate","defaultGroupOrigin","groupableProps","targetGroups","renderGroupRects","persistDatChildren","clickable","containsElement","containsTarget","targetIndex","parentTarget","getDraggableEvent","dragCondition","dragGroupCondition","individualGroupable","MOVEABLE_ABLES","Default","Snappable","Pinchable","Scalable","Warpable","Rotatable","Scrollable","Padding","Origin","OriginDraggable","Clippable","Roundable","Groupable","IndividualGroupable","Clickable","DragArea","MOVEABLE_EVENTS_PROPS_MAP","MOVEABLE_PROPS_MAP","MOVEABLE_EVENTS_MAP","solveConstantsDistance","solveC","getMaxPos","getMinPos","findMoveableGroups","childTargetGroups","targetGroup","childMoveableGroups","checked","finded","ChildrenDiffer","componentDidMount","checkeds","moveableGroups","isReset","updateGroup","_hasFirstTargets","persistedRoatation","rootGroupRect","getMoveableGroupRect","parentRotation","posesRotations","rotations","groupRotation","firstRotation","isSameRotation","groupPoses","groupRect","parentPoses","fixedRotation","a1_1","tan","a2_1","a1MinMax_1","a1MinMaxPos_1","a2MinMax_1","a2MinMaxPos_1","a1Dist","a2Dist","a1MinPos","a1MaxPos","a2MinPos","a2MaxPos","minHorizontalLine","maxHorizontalLine","minVerticalLine","maxVerticalLine","changedX","minX_1","minY_1","maxX_1","maxY_1","getGroupRect","_targetGroups","posesInfo","rotatePosesInfo","rotateScale","nextTarget","isContainerChanged","differ","update","MoveableGroup","defaultProps","canPersist","MoveableIndividualGroup","getElementTargets","refTargets","selectorMap","elementTargets","getTargetGroups","compareRefTargets","prevRefTargets","nextRefTargets","duplicate","InitialMoveable","cssMap","getTotalAbles","defaultStyled","prefixCSS","defaultAbles","moveableContructor","makeStyled","userAbles","userProps","__rest","_updateRefs","nextProps","_elementTargets","prevMoveable","target_1","prevTargetMoveable","mv","_checkChangeTargets","resolvePromise","_onChangeTargets","waitToChangeTarget","isBrowser","nextSelectorMap","updateSelectorMap","_differ","__decorate","propertyName","methodName","Moveable","_objectWithoutProperties","make","up","down","u","big","mirror","opposite","lookup","f","_globals","animation","Fade","defaults","out","forever","timeout","duration","delay","animationFillMode","_wrap2","default","defineProperty","exports","_propTypes","require","_wrap","__esModule","propTypes","bool","number","string","module","I","Space","Enter","Escape","Backspace","Delete","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","Home","End","PageUp","PageDown","Tab","First","Previous","Next","Last","Specific","Nothing","resolveItems","resolveActiveIndex","focus","resolveDisabled","resolveId","HTMLFieldSetElement","HTMLLegendElement","previousElementSibling","Node","L","WrapAround","NoScroll","N","Overflow","Success","Underflow","T","E","tabIndex","MAX_SAFE_INTEGER","F","Strict","Loose","M","g","nextFrame","preventScroll","S","H","A","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","sorted","relativeTo","skipElements","includes","select","hasAttribute","defaultPrevented","Set","HTMLElement","composed","composedPath","C","HTMLIFrameElement","as","HTMLButtonElement","screenX","screenY","pe","Open","Closed","de","Pointer","Other","me","OpenMenu","CloseMenu","GoToItem","Search","ClearSearch","RegisterItem","UnregisterItem","U","activeItemIndex","items","dataRef","domRef","fe","menuState","Y","disabled","searchQuery","activationTrigger","textValue","startsWith","searchActiveItemIndex","G","q","O","J","captureStackTrace","Te","displayName","ye","Ie","X","buttonRef","itemsRef","oe","R","ee","te","P","K","Provider","ue","ourProps","theirProps","slot","defaultTag","Me","W","Z","onKeyDown","onKeyUp","be","Q","Ae","le","ie","z","accept","walk","enabled","acceptNode","createTreeWalker","NodeFilter","SHOW_ELEMENT","nextNode","currentNode","ae","FILTER_REJECT","FILTER_SKIP","FILTER_ACCEPT","dispose","click","$","re","shiftKey","V","role","features","visible","ve","Se","D","B","scrollIntoView","block","textContent","wasMoved","ce","active","onFocus","onPointerEnter","onMouseEnter","onPointerMove","onMouseMove","onPointerLeave","onMouseLeave","Ze","Button","Items","Item","called","removeAttribute","enter","leave","enterTo","leaveTo","enterFrom","leaveFrom","entered","transitionDuration","transitionDelay","classes","onStart","onStop","ge","Visible","Hidden","microTask","idle","chains","then","wait","shift","register","unregister","xe","beforeEnter","afterEnter","beforeLeave","afterLeave","unmount","show","appear","initial","Ee","Pe","Ce","he","Ne","Ke","Child","Root","Symbol","queueMicrotask","catch","enqueue","workQueue","getPropertyValue","enumerable","configurable","writable","detect","handoffState","currentId","None","RenderStrategy","Static","Unmount","static","hidden","refName","entries","fromEntries","Event","nativeEvent","SkeletonThemeContext","Skeleton","Wrapper","wrapper","customClassName","containerClassName","containerTestId","circle","styleProp","originalPropsStyleOptions","contextStyleOptions","propsStyleOptions","styleOptions","baseColor","highlightColor","enableAnimation","styleOptionsToCssProperties","inline","countCeil","ceil","thisStyle","fractionalPart","fractionalWidth","skeletonSpan"],"sourceRoot":""}